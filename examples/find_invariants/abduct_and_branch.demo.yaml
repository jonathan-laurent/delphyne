# Demonstrations for `prove_program_via_abduction_and_branching`
#
# Note: all demonstrations in this file can be evaluated without installing `why3py` since the
# results of all solver calls are hardcoded (see __Computation__ queries). However, modifying a
# demonstration or adding a new one may require installing `why3py`. See README.md for details.

# A demonstration with conditionals, which involves abducting an additional assumption
- strategy: prove_program_via_abduction_and_branching
  args:
    prog: |
      use int.Int

      let example1 () diverges =
        let ref x = any int in
        let ref y = 3 in
        let ref z = 0 in
        assume { x < 0 };
        while x < 10 do
          x <- x + 1;
          z <- z - 1;
          if z < 0 then y <- y + 1
        done;
        assert { x <> y }
  tests:
    - run | success
    - run 'partial' | success
    # Demonstrating `EvaluateProofState`
    - at EvaluateProofState#1 'partial' | answer eval
    - at EvaluateProofState#2 'partial propose_same' | answer eval
    # Demonstrating `IsProposalNovel`
    - at iterate#1 | go cands | go next(next(nil){'partial'}[1]) | save second_attempt
    - load second_attempt | at IsProposalNovel 'blacklisted' | answer cands
    - load second_attempt | at IsProposalNovel 'not_blacklisted' | answer cands
  queries: 
    - query: ProposeInvariants
      args:
        unproved:
          name: VC for example1 (assertion)
          proved: false
          relevance_hints: |-
            use int.Int

            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }  (* GOAL *)
          goal_formula: not x = y
        blacklist: []
      answers:
        - answer: |
            The final assertion `x <> y` failed to prove, meaning that Why3 could not deduce it after assuming the provided loop invariants (none) and the negation of the loop guard. Let's see if `x <> y` itself might be an invariant. For this to hold, it has to be true before the loop and preserved by each loop iteration.

            Right before the loop, `x <> y` holds thanks to the `x < 0` assumption. Assuming `x <> y` holds at the start of a loop iteration, can it be shown to hold afterwards? What happens to `x` and `y` in the loop body depends on whether or not the conditional statement is executed, which in turns depends on the value of `z`. Looking at `z`, it starts with value `0` at the beginning of the program and it is then never increased. Thus, `z <= 0` is an invariant and the conditional statement is always executed. Thus, at each loop iteration, both `x` and `y` are increased by 1 and so `x <> y` is preserved.

            Summarizing, we can prove `x <> y` to be an invariant, assuming that `z <= 0` is added as an invariant too. Thus, we propose to update the program by adding the following two invariants:

            ```
            - "z <= 0"
            - "x <> y"
            ```
          example: true
        - label: partial
          example: false
          answer: |
            ```
            - "x <> y"
            ```
    - query: ProposeInvariants
      args:
        unproved:
          name: VC for example1 (loop invariant preservation)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                invariant { x <> y }  (* GOAL, premise *)
                x <- x + 1;  (* premise *)
                z <- z - 1;  (* premise *)
                if z < 0 then y <- y + 1  (* premise *)
              done;
              assert { x <> y }
          goal_formula: not (x + 1) = y
        blacklist: []
      answers:
        - answer: |
            Why3 wasn't able to prove that the invariant `x <> y` is preserved by the loop body. Let's dig into this. Within the loop body, `x` is incremented. What happens to `y` depends on whether the conditional statement is executed or not, which in turns depends on `z`. However, we can see that `z = 0` initially and then `z` never increases. Thus, `z <= 0` is an invariant and the conditional statement always executes. As a consequence, both `x` and `y` increase by the same amount at each loop iteration and thus `x <> y` is preserved.

            As a consequence, we propose adding `z <= 0` as an invariant:

            ```
            - "z <= 0"
            ```
          example: true
        - label: propose_same
          example: false
          answer: | 
            ```
            - "not (x = y)"
            ```
    - query: EvaluateProofState
      args:
        unproved:
          name: VC for example1 (loop invariant preservation)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                invariant { x <> y }  (* GOAL, premise *)
                x <- x + 1;  (* premise *)
                z <- z - 1;  (* premise *)
                if z < 0 then y <- y + 1  (* premise *)
              done;
              assert { x <> y }
          goal_formula: not (x + 1) = y
      answers:
        - answer: |
            Only one invariant is listed so it cannot be redundant.

            ```
            has_redundant_invs: no
            ```
          example: true
    - query: EvaluateProofState
      args:
        unproved:
          name: VC for example1 (loop invariant preservation)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                invariant { not (x = y) }  (* GOAL, premise *)
                invariant { x <> y }  (* premise *)
                x <- x + 1;  (* premise *)
                z <- z - 1;  (* premise *)
                if z < 0 then y <- y + 1  (* premise *)
              done;
              assert { x <> y }
          goal_formula: not (x + 1) = y
      answers:
        - answer: |
            Invariant `not (x = 0)` is redundant with invariant `x <> y`.

            ```
            has_redundant_invs: yes
            ```
          example: true
    - query: ProposeInvariants
      args:
        unproved:
          name: VC for example1 (assertion)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }  (* GOAL *)
          goal_formula: not x = y
        blacklist:
          - [x <> y]
      answers:
        - label: blacklisted
          answer: |
            ```
            - "not (x = y)"
            ```
          example: false
        - label: not_blacklisted
          answer: |
            ```
            - "z <= 0"
            ```
          example: false
    - query: IsProposalNovel
      args:
        proposal: [not (x = y)]
        blacklist:
          - [x <> y]
      answers:
        - answer: | 
            The new formula is equivalent to blacklisted formula `x <> y` so it is not novel.

            ```
            no
            ```
          example: true
    - query: IsProposalNovel
      args:
        proposal: [z <= 0]
        blacklist:
          - [x <> y]
      answers:
        - answer: |
            The new formula `z <= 0` is not equivalent to the only blacklisted formula `x <> y` so it is novel.

            ```
            yes
            ```
          example: true
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
          annotated: |
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
      answers:
        - answer: |
            error:
            obligations:
              - name: VC for example1 (assertion)
                proved: no
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                goal_formula: not x = y
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
          annotated: |-
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                invariant { z <= 0 }
                invariant { x <> y }
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
      answers:
        - answer: |
            error:
      
            obligations:
              - name: VC for example1 (loop invariant init)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in  (* GOAL *)
                    assume { x < 0 };  (* premise *)
                    while x < 10 do
                      invariant { z <= 0 }  (* GOAL *)
                      invariant { x <> y }
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }
                goal_formula: 0 <= 0
              - name: VC for example1 (loop invariant init)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* GOAL, premise *)
                    let ref y = 3 in  (* GOAL *)
                    let ref z = 0 in  (* premise *)
                    assume { x < 0 };  (* premise *)
                    while x < 10 do
                      invariant { z <= 0 }  (* premise *)
                      invariant { x <> y }  (* GOAL *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }
                goal_formula: not o = 3
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { z <= 0 }  (* GOAL, premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: (z - 1) <= 0
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { z <= 0 }  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = (y + 1)
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { z <= 0 }  (* GOAL, premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: (z - 1) <= 0
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { z <= 0 }  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = y
              - name: VC for example1 (assertion)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { z <= 0 }  (* premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                goal_formula: not x = y
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
          annotated: |-
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                invariant { x <> y }
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
      answers:
        - answer: |
            error:
      
            obligations:
              - name: VC for example1 (loop invariant init)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* GOAL, premise *)
                    let ref y = 3 in  (* GOAL *)
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do
                      invariant { x <> y }  (* GOAL *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }
                goal_formula: not o = 3
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = (y + 1)
              - name: VC for example1 (loop invariant preservation)
                proved: no
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = y
              - name: VC for example1 (assertion)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                goal_formula: not x = y
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
          annotated: |-
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                invariant { not (x = y) }
                invariant { x <> y }
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
      answers:
        - answer: |
            error:
      
            obligations:
              - name: VC for example1 (loop invariant init)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* GOAL, premise *)
                    let ref y = 3 in  (* GOAL *)
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do
                      invariant { not (x = y) }  (* GOAL *)
                      invariant { x <> y }
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }
                goal_formula: not o = 3
              - name: VC for example1 (loop invariant init)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* GOAL, premise *)
                    let ref y = 3 in  (* GOAL, premise *)
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do
                      invariant { not (x = y) }  (* premise *)
                      invariant { x <> y }  (* GOAL *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }
                goal_formula: not o = 3
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { not (x = y) }  (* GOAL, premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = (y + 1)
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { not (x = y) }  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = (y + 1)
              - name: VC for example1 (loop invariant preservation)
                proved: no
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { not (x = y) }  (* GOAL, premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = y
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { not (x = y) }  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = y
              - name: VC for example1 (assertion)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { not (x = y) }  (* premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                goal_formula: not x = y



# Second demonstration: invariants involving implications
- strategy: prove_program_via_abduction_and_branching
  args:
    prog: |
      use int.Int

      let main () diverges =
        let n = any int in
        let ref x = 0 in
        while x < n do
          x <- x + 1;
        done;
        assume { n > 0 };
        assert { x = n }
  tests:
    - run | success
  queries: 
    - query: ProposeInvariants
      args:
        unproved:
          name: VC for main (assertion)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let main () diverges =  (* GOAL *)
              let n = any int in
              let ref x = 0 in
              while x < n do  (* premise *)
                x <- x + 1;
              done;
              assume { n > 0 };  (* premise *)
              assert { x = n }  (* GOAL *)
          goal_formula: x = n
        blacklist: []
      answers:
        - answer: |
            Why3 did not manage to deduce the final assertion `x = n` from the preceding assumption `n > 0` and the negation of the loop guard `x >= n`. What remains to establish indeed is that `x <= n` at the end of the program. Note that the `n > 0` assumption involves a variable `n` that is constant throughout the program. Thus, assuming `n > 0` after the loop, we also have `n > 0` before the loop. Also, assuming `n > 0`, then `x <= n` is a loop invariant. Indeed, `x <= n` is true before entering the loop thanks to the `n > 0` assumption. Moreover, before the loop body executes, we have `x < n` by the loop guard and so `x <= n` after the loop body executes since `x` is incremented. As a consequence, `x <= n` is preserved by the loop body.

            Thus, we propose `n > 0 -> x <= n` as an invariant. Note that the `n > 0` assumption is important. Otherwise, the invariant would not hold initially!

            ```
            - "n > 0 -> x <= n"
            ```
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let main () diverges =
              let n = any int in
              let ref x = 0 in
              while x < n do
                x <- x + 1;
              done;
              assume { n > 0 };
              assert { x = n }
          annotated: |
            use int.Int
      
            let main () diverges =
              let n = any int in
              let ref x = 0 in
              while x < n do
                x <- x + 1;
              done;
              assume { n > 0 };
              assert { x = n }
      answers:
        - answer: |
            error:
            obligations:
              - name: VC for main (assertion)
                proved: no
                relevance_hints: |-
                  use int.Int
      
                  let main () diverges =  (* GOAL *)
                    let n = any int in
                    let ref x = 0 in
                    while x < n do  (* premise *)
                      x <- x + 1;
                    done;
                    assume { n > 0 };  (* premise *)
                    assert { x = n }  (* GOAL *)
                goal_formula: x = n
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let main () diverges =
              let n = any int in
              let ref x = 0 in
              while x < n do
                x <- x + 1;
              done;
              assume { n > 0 };
              assert { x = n }
          annotated: |-
            use int.Int
      
            let main () diverges =
              let n = any int in
              let ref x = 0 in
              while x < n do
                invariant { n > 0 -> x <= n }
                x <- x + 1;
              done;
              assume { n > 0 };
              assert { x = n }
      answers:
        - answer: |
            error:
      
            obligations:
              - name: VC for main (loop invariant init)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let main () diverges =  (* GOAL *)
                    let n = any int in
                    let ref x = 0 in  (* GOAL *)
                    while x < n do
                      invariant { n > 0 -> x <= n }  (* GOAL, premise *)
                      x <- x + 1;
                    done;
                    assume { n > 0 };
                    assert { x = n }
                goal_formula: 0 <= n
              - name: VC for main (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let main () diverges =  (* GOAL *)
                    let n = any int in
                    let ref x = 0 in
                    while x < n do  (* premise *)
                      invariant { n > 0 -> x <= n }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                    done;
                    assume { n > 0 };
                    assert { x = n }
                goal_formula: (x + 1) <= n
              - name: VC for main (assertion)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let main () diverges =  (* GOAL *)
                    let n = any int in
                    let ref x = 0 in
                    while x < n do  (* premise *)
                      invariant { n > 0 -> x <= n }  (* premise *)
                      x <- x + 1;
                    done;
                    assume { n > 0 };  (* premise *)
                    assert { x = n }  (* GOAL *)
                goal_formula: x = n


# Third demonstration: when disjunctions are needed
- strategy: prove_program_via_abduction_and_branching
  args:
    prog: |
      use int.Int

      let main () diverges =
        let ref x = 0 in
        let ref y = any int in
        let ref z = any int in
        while x < 500 do
          x <- x + 1;
          if z <= y then
            y <- z
        done;
        assert { z >= y }
  tests:
    - run | success
  queries: 
    - query: ProposeInvariants
      args:
        unproved:
          name: VC for main (assertion)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let main () diverges =  (* GOAL *)
              let ref x = 0 in
              let ref y = any int in
              let ref z = any int in  (* GOAL *)
              while x < 500 do  (* premise *)
                x <- x + 1;
                if z <= y then
                  y <- z
              done;
              assert { z >= y }  (* GOAL *)
          goal_formula: o2 >= y
        blacklist: []
      answers:
        - answer: |
            Why3 did not manage to prove the final assertion `z >= y`. The formula `z >= y` is clearly not a loop invariant because it is not necessarily true before the loop. The reason `z >= y` really holds at the end is that executing any loop iteration will make it true (if `z >= y` is false at the start of an iteration, the conditional statement will execute and make it true). In turn, at least one loop iteration will execute since `x < 500` is true initially.

            Thus, we propose to add invariant `z >= y || x < 500`, meaning that `z >= y` is true already or the loop guard is true, meaning one more loop iteration at least will execute.

            ```
            - "z >= y || x < 500"
            ```
          example: true
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let main () diverges =
              let ref x = 0 in
              let ref y = any int in
              let ref z = any int in
              while x < 500 do
                x <- x + 1;
                if z <= y then
                  y <- z
              done;
              assert { z >= y }
          annotated: |
            use int.Int
      
            let main () diverges =
              let ref x = 0 in
              let ref y = any int in
              let ref z = any int in
              while x < 500 do
                x <- x + 1;
                if z <= y then
                  y <- z
              done;
              assert { z >= y }
      answers:
        - answer: |
            error:
            obligations:
              - name: VC for main (assertion)
                proved: no
                relevance_hints: |-
                  use int.Int
      
                  let main () diverges =  (* GOAL *)
                    let ref x = 0 in
                    let ref y = any int in
                    let ref z = any int in  (* GOAL *)
                    while x < 500 do  (* premise *)
                      x <- x + 1;
                      if z <= y then
                        y <- z
                    done;
                    assert { z >= y }  (* GOAL *)
                goal_formula: o2 >= y
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let main () diverges =
              let ref x = 0 in
              let ref y = any int in
              let ref z = any int in
              while x < 500 do
                x <- x + 1;
                if z <= y then
                  y <- z
              done;
              assert { z >= y }
          annotated: |-
            use int.Int
      
            let main () diverges =
              let ref x = 0 in
              let ref y = any int in
              let ref z = any int in
              while x < 500 do
                invariant { z >= y || x < 500 }
                x <- x + 1;
                if z <= y then
                  y <- z
              done;
              assert { z >= y }
      answers:
        - answer: |
            error:
      
            obligations:
              - name: VC for main (loop invariant init)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let main () diverges =  (* GOAL *)
                    let ref x = 0 in  (* GOAL *)
                    let ref y = any int in  (* GOAL *)
                    let ref z = any int in  (* GOAL *)
                    while x < 500 do
                      invariant { z >= y || x < 500 }  (* GOAL *)
                      x <- x + 1;
                      if z <= y then
                        y <- z
                    done;
                    assert { z >= y }
                goal_formula: o2 >= o1 || 0 < 500
              - name: VC for main (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let main () diverges =  (* GOAL *)
                    let ref x = 0 in
                    let ref y = any int in
                    let ref z = any int in
                    while x < 500 do  (* premise *)
                      invariant { z >= y || x < 500 }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      if z <= y then  (* premise *)
                        y <- z
                    done;
                    assert { z >= y }
                goal_formula: y2 >= y2 || (x + 1) < 500
              - name: VC for main (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let main () diverges =  (* GOAL *)
                    let ref x = 0 in
                    let ref y = any int in
                    let ref z = any int in  (* GOAL, premise *)
                    while x < 500 do  (* premise *)
                      invariant { z >= y || x < 500 }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      if z <= y then  (* premise *)
                        y <- z
                    done;
                    assert { z >= y }
                goal_formula: o2 >= y || (x + 1) < 500
              - name: VC for main (assertion)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let main () diverges =  (* GOAL *)
                    let ref x = 0 in
                    let ref y = any int in
                    let ref z = any int in  (* GOAL, premise *)
                    while x < 500 do  (* premise *)
                      invariant { z >= y || x < 500 }  (* premise *)
                      x <- x + 1;
                      if z <= y then
                        y <- z
                    done;
                    assert { z >= y }  (* GOAL *)
                goal_formula: o2 >= y


- strategy: prove_program_via_abduction_and_branching
  args:
    prog: |
      use int.Int

      let example1 () diverges =
        let ref x = any int in
        let ref y = 3 in
        let ref z = 0 in
        assume { x < 0 };
        while x < 10 do
          x <- x + 1;
          z <- z - 1;
          if z < 0 then y <- y + 1
        done;
        assert { x <> y }
  tests:
    - run | success
  queries: 
    - query: ProposeInvariants
      args:
        unproved:
          name: VC for example1 (assertion)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }  (* GOAL *)
          goal_formula: not x = y
        blacklist: []
      answers:
        - answer: |
            Long explanation...
            ```
            - "x <> y"
            ```
    - query: ProposeInvariants
      args:
        unproved:
          name: VC for example1 (loop invariant preservation)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                invariant { x <> y }  (* GOAL, premise *)
                x <- x + 1;  (* premise *)
                z <- z - 1;  (* premise *)
                if z < 0 then y <- y + 1  (* premise *)
              done;
              assert { x <> y }
          goal_formula: not (x + 1) = y
        blacklist: []
      answers:
        - answer: |
            ```
            - "z <= 0"
            ```
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
          annotated: |
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
      answers:
        - answer: |
            error:
            obligations:
              - name: VC for example1 (assertion)
                proved: no
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                goal_formula: not x = y
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
          annotated: |-
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                invariant { x <> y }
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
      answers:
        - answer: |
            error:
      
            obligations:
              - name: VC for example1 (loop invariant init)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* GOAL, premise *)
                    let ref y = 3 in  (* GOAL *)
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do
                      invariant { x <> y }  (* GOAL *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }
                goal_formula: not o = 3
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = (y + 1)
              - name: VC for example1 (loop invariant preservation)
                proved: no
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = y
              - name: VC for example1 (assertion)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                goal_formula: not x = y
    - query: __Computation__
      args:
        fun: check
        args:
          prog: |
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
          annotated: |-
            use int.Int
      
            let example1 () diverges =
              let ref x = any int in
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };
              while x < 10 do
                invariant { z <= 0 }
                invariant { x <> y }
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }
      answers:
        - answer: |
            error:
      
            obligations:
              - name: VC for example1 (loop invariant init)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in  (* GOAL *)
                    assume { x < 0 };  (* premise *)
                    while x < 10 do
                      invariant { z <= 0 }  (* GOAL *)
                      invariant { x <> y }
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }
                goal_formula: 0 <= 0
              - name: VC for example1 (loop invariant init)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* GOAL, premise *)
                    let ref y = 3 in  (* GOAL *)
                    let ref z = 0 in  (* premise *)
                    assume { x < 0 };  (* premise *)
                    while x < 10 do
                      invariant { z <= 0 }  (* premise *)
                      invariant { x <> y }  (* GOAL *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }
                goal_formula: not o = 3
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { z <= 0 }  (* GOAL, premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: (z - 1) <= 0
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { z <= 0 }  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = (y + 1)
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { z <= 0 }  (* GOAL, premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: (z - 1) <= 0
              - name: VC for example1 (loop invariant preservation)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { z <= 0 }  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { x <> y }
                goal_formula: not (x + 1) = y
              - name: VC for example1 (assertion)
                proved: yes
                relevance_hints: |-
                  use int.Int
      
                  let example1 () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { z <= 0 }  (* premise *)
                      invariant { x <> y }  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                goal_formula: not x = y
