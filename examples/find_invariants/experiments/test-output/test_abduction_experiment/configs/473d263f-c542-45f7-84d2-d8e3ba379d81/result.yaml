# delphyne-command

command: run_strategy
args:
  strategy: prove_program_by_recursive_abduction
  args:
    prog: |-
      use int.Int

      let main () diverges =
        let ref x = any int in
        let ref y = any int in
        x <- 1;
        y <- 0;
        while y < 100000 do
          x <- x + y;
          y <- y + 1
        done;
        assert { x >= y }
  policy: prove_program_by_saturation
  policy_args:
    model_cycle:
      - - gpt-4.1-nano
        - 2
      - - gpt-4.1-mini
        - 1
    temperature: 1.5
    num_completions: 4
    max_requests_per_attempt: 4
  budget:
    price: 0.1
  cache_file: configs/473d263f-c542-45f7-84d2-d8e3ba379d81/cache.yaml
  embeddings_cache_file: configs/473d263f-c542-45f7-84d2-d8e3ba379d81/embeddings.cache.h5
  cache_mode: create
  log_long_computations:
    - info
    - 1.0
outcome:
  diagnostics: []
  result:
    success: true
    values:
      - |-
        use int.Int

        let main () diverges =
          let ref x = any int in
          let ref y = any int in
          x <- 1;
          y <- 0;
          while y < 100000 do
            invariant { y <= 100000 }
            invariant { y >= 0 }
            invariant { x >= 1 }
            invariant { x >= y || y < 100000 }
            x <- x + y;
            y <- y + 1
          done;
          assert { x >= y }
    spent_budget:
      num_requests: 7
      num_completions: 28
      input_tokens: 23030
      output_tokens: 1338
      cached_input_tokens: 18048
      price: 0.0036565999999999994
    success_nodes:
      - 171
    raw_trace:
      nodes:
        1: nested($0)
        2: nested($1)
        3: child(%2, $2{@1})
        4: nested($3)
        5: child(%4, $4{@2})
        6: child(%4, $4{@3})
        7: child(%4, $4{@4})
        8: nested($5)
        9: child(%8, $6{@5})
        10: nested($7)
        11: child(%10, $8{@6})
        12: nested($9)
        13: child(%12, $10{@7})
        14: nested($11)
        15: child(%14, $12{@8})
        16: nested($13)
        17: child(%16, $14{@9})
        18: child(%16, $14{@10})
        19: child(%16, $14{@11})
        20: child(%16, $14{@12})
        21: child(%16, $14{@13})
        22: child(%16, $14{@14})
        23: child(%16, $14{@15})
        24: nested($15)
        25: child(%24, $16{@16})
        26: nested($17)
        27: child(%26, $18{@17})
        28: nested($19)
        29: child(%28, $20{@18})
        30: nested($21)
        31: child(%30, $22{@19})
        32: nested($23)
        33: child(%32, $24{@20})
        34: nested($25)
        35: child(%34, $26{@21})
        36: child(%4, $4{@22})
        37: child(%4, $4{@23})
        38: child(%4, $4{@24})
        39: child(%4, $4{@25})
        40: nested($27)
        41: child(%40, $28{@26})
        42: nested($29)
        43: child(%42, $30{@27})
        44: nested($31)
        45: child(%44, $32{@28})
        46: nested($33)
        47: child(%46, $34{@29})
        48: nested($35)
        49: child(%48, $36{@30})
        50: nested($37)
        51: child(%50, $38{@31})
        52: nested($39)
        53: child(%52, $40{@32})
        54: nested($41)
        55: child(%54, $42{@33})
        56: nested($43)
        57: child(%56, $44{@34})
        58: nested($45)
        59: child(%58, $46{@35})
        60: nested($47)
        61: child(%60, $48{@36})
        62: nested($49)
        63: child(%62, $50{@37})
        64: nested($51)
        65: child(%64, $52{@38})
        66: nested($53)
        67: child(%66, $54{@39})
        68: nested($55)
        69: child(%68, $56{@40})
        70: nested($57)
        71: child(%70, $58{@41})
        72: nested($59)
        73: child(%72, $60{@42})
        74: nested($61)
        75: child(%74, $62{@43})
        76: nested($63)
        77: child(%76, $64{@44})
        78: nested($65)
        79: child(%78, $66{@45})
        80: nested($67)
        81: child(%80, $68{@46})
        82: nested($69)
        83: child(%82, $70{@47})
        84: nested($71)
        85: child(%84, $72{@48})
        86: nested($73)
        87: child(%86, $74{@49})
        88: nested($75)
        89: child(%4, $4{@50})
        90: child(%4, $4{@51})
        91: child(%4, $4{@52})
        92: child(%4, $4{@53})
        93: nested($77)
        94: child(%93, $78{@54})
        95: nested($79)
        96: child(%95, $80{@55})
        97: nested($81)
        98: child(%97, $82{@56})
        99: nested($83)
        100: child(%99, $84{@57})
        101: nested($85)
        102: child(%101, $86{@58})
        103: nested($87)
        104: child(%103, $88{@59})
        105: nested($89)
        106: child(%105, $90{@60})
        107: nested($91)
        108: child(%107, $92{@61})
        109: nested($93)
        110: child(%109, $94{@62})
        111: nested($95)
        112: child(%111, $96{@63})
        113: nested($97)
        114: child(%113, $98{@64})
        115: nested($99)
        116: child(%115, $100{@65})
        117: nested($101)
        118: child(%117, $102{@66})
        119: nested($103)
        120: child(%119, $104{@67})
        121: nested($105)
        122: child(%121, $106{@68})
        123: nested($107)
        124: child(%123, $108{@69})
        125: nested($109)
        126: child(%125, $110{@70})
        127: nested($111)
        128: child(%127, $112{@71})
        129: child(%127, $112{@72})
        130: child(%127, $112{@73})
        131: nested($113)
        132: child(%131, $114{@74})
        133: nested($115)
        134: child(%133, $116{@75})
        135: nested($117)
        136: child(%135, $118{@76})
        137: nested($119)
        138: child(%137, $120{@77})
        139: child(%137, $120{@78})
        140: child(%137, $120{@79})
        141: nested($121)
        142: child(%141, $122{@80})
        143: nested($123)
        144: child(%143, $124{@81})
        145: nested($125)
        146: child(%145, $126{@82})
        147: nested($127)
        148: child(%147, $128{@83})
        149: nested($129)
        150: child(%149, $130{@84})
        151: nested($131)
        152: child(%151, $132{@85})
        153: nested($133)
        154: child(%153, $134{@86})
        155: nested($135)
        156: child(%155, $136{@87})
        157: nested($137)
        158: child(%157, $138{@88})
        159: nested($139)
        160: child(%159, $140{@89})
        161: nested($141)
        162: child(%161, $142{@90})
        163: nested($143)
        164: child(%163, $144{@91})
        165: nested($145)
        166: child(%165, $146{@92})
        167: nested($147)
        168: child(%167, $148{@93})
        169: nested($149)
        170: child(%169, $150{@94})
        171: child(%1, $149{%170}[1])
      spaces:
        0: main
        1: local(%1, prove([], nil))
        2: local(%2, query)
        3: local(%1, suggest($1{%3}[1]))
        4: local(%4, cands)
        5: local(%1, redundant([], $3{%5}[0]))
        6: local(%8, query)
        7: local(%1, prove([], $3{%5}[0]))
        8: local(%10, query)
        9: local(%1, redundant([], $3{%5}[1]))
        10: local(%12, query)
        11: local(%1, prove([], $3{%5}[1]))
        12: local(%14, query)
        13: local(%1, suggest($7{%11}[1]))
        14: local(%16, cands)
        15: local(%1, search_equivalent([$3{%5}[0], $3{%5}[1]], $13{%22}[0]))
        16: local(%24, query)
        17: local(%1, search_equivalent([$3{%5}[0], $3{%5}[1]], $13{%23}[0]))
        18: local(%26, query)
        19: local(%1, redundant([], $13{%22}[0]))
        20: local(%28, query)
        21: local(%1, prove([], $13{%22}[0]))
        22: local(%30, query)
        23: local(%1, redundant([], $13{%23}[0]))
        24: local(%32, query)
        25: local(%1, prove([], $13{%23}[0]))
        26: local(%34, query)
        27: local(%1, search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%36}[0]))
        28: local(%40, query)
        29: local(%1, search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%36}[1]))
        30: local(%42, query)
        31: local(%1, search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%37}[1]))
        32: local(%44, query)
        33: local(%1, search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%38}[1]))
        34: local(%46, query)
        35: local(%1, search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%38}[2]))
        36: local(%48, query)
        37: local(%1, search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%39}[0]))
        38: local(%50, query)
        39: local(%1, redundant([], $3{%36}[0]))
        40: local(%52, query)
        41: local(%1, prove([], $3{%36}[0]))
        42: local(%54, query)
        43: local(%1, redundant([], $3{%36}[1]))
        44: local(%56, query)
        45: local(%1, prove([], $3{%36}[1]))
        46: local(%58, query)
        47: local(%1, redundant([], $3{%37}[1]))
        48: local(%60, query)
        49: local(%1, prove([], $3{%37}[1]))
        50: local(%62, query)
        51: local(%1, redundant([$3{%37}[1]], $3{%38}[1]))
        52: local(%64, query)
        53: local(%1, prove([[$3{%37}[1], $49{%63}[1]]], $3{%38}[1]))
        54: local(%66, query)
        55: local(%1, redundant([$3{%37}[1]], $3{%38}[2]))
        56: local(%68, query)
        57: local(%1, prove([[$3{%37}[1], $49{%63}[1]]], $3{%38}[2]))
        58: local(%70, query)
        59: local(%1, redundant([$3{%37}[1]], $3{%39}[0]))
        60: local(%72, query)
        61: local(%1, prove([[$3{%37}[1], $49{%63}[1]]], $3{%39}[0]))
        62: local(%74, query)
        63: local(%1, prove([[$3{%37}[1], $49{%63}[1]], [$3{%39}[0], $61{%75}[1]]], nil))
        64: local(%76, query)
        65: local(%1, redundant([$3{%37}[1], $3{%39}[0]], $3{%5}[0]))
        66: local(%78, query)
        67: local(%1, prove([[$3{%37}[1], $49{%63}[1]], [$3{%39}[0], $61{%75}[1]]], $3{%5}[0]))
        68: local(%80, query)
        69: local(%1, redundant([$3{%37}[1], $3{%39}[0]], $3{%5}[1]))
        70: local(%82, query)
        71: local(%1, prove([[$3{%37}[1], $49{%63}[1]], [$3{%39}[0], $61{%75}[1]]], $3{%5}[1]))
        72: local(%84, query)
        73: local(%1, redundant([$3{%37}[1], $3{%39}[0]], $3{%36}[0]))
        74: local(%86, query)
        75: local(%1, suggest($67{%81}[1]))
        76: local(%88, cands)
        77: local(%1, redundant([], $3{%89}[0]))
        78: local(%93, query)
        79: local(%1, prove([], $3{%89}[0]))
        80: local(%95, query)
        81: local(%1, redundant([], $3{%90}[0]))
        82: local(%97, query)
        83: local(%1, prove([], $3{%90}[0]))
        84: local(%99, query)
        85: local(%1, redundant([], $3{%91}[0]))
        86: local(%101, query)
        87: local(%1, prove([], $3{%91}[0]))
        88: local(%103, query)
        89: local(%1, redundant([], $3{%91}[1]))
        90: local(%105, query)
        91: local(%1, prove([], $3{%91}[1]))
        92: local(%107, query)
        93: local(%1, redundant([$3{%91}[1]], $3{%92}[0]))
        94: local(%109, query)
        95: local(%1, prove([[$3{%91}[1], $91{%108}[1]]], $3{%92}[0]))
        96: local(%111, query)
        97: local(%1, redundant([$3{%91}[1]], $3{%92}[1]))
        98: local(%113, query)
        99: local(%1, prove([[$3{%91}[1], $91{%108}[1]]], $3{%92}[1]))
        100: local(%115, query)
        101: local(%1, prove([[$3{%91}[1], $91{%108}[1]]], nil))
        102: local(%117, query)
        103: local(%1, redundant([$3{%91}[1]], $3{%90}[0]))
        104: local(%119, query)
        105: local(%1, prove([[$3{%91}[1], $91{%108}[1]]], $3{%90}[0]))
        106: local(%121, query)
        107: local(%1, redundant([$3{%91}[1]], $3{%91}[0]))
        108: local(%123, query)
        109: local(%1, prove([[$3{%91}[1], $91{%108}[1]]], $3{%91}[0]))
        110: local(%125, query)
        111: local(%1, suggest($105{%122}[1]))
        112: local(%127, cands)
        113: local(%1, search_equivalent([$3{%90}[0], $3{%91}[0], $3{%92}[0], $3{%92}[1], $3{%91}[1]],
          $111{%130}[1]))
        114: local(%131, query)
        115: local(%1, redundant([$3{%91}[1]], $111{%130}[1]))
        116: local(%133, query)
        117: local(%1, prove([[$3{%91}[1], $91{%108}[1]]], $111{%130}[1]))
        118: local(%135, query)
        119: local(%1, suggest($99{%116}[1]))
        120: local(%137, cands)
        121: local(%1, search_equivalent([$3{%90}[0], $3{%91}[0], $3{%92}[0], $3{%92}[1], $3{%91}[1]],
          $119{%138}[0]))
        122: local(%141, query)
        123: local(%1, search_equivalent([$3{%90}[0], $3{%91}[0], $3{%92}[0], $3{%92}[1], $3{%91}[1]],
          $119{%140}[0]))
        124: local(%143, query)
        125: local(%1, redundant([$3{%91}[1]], $119{%138}[0]))
        126: local(%145, query)
        127: local(%1, prove([[$3{%91}[1], $91{%108}[1]]], $119{%138}[0]))
        128: local(%147, query)
        129: local(%1, redundant([$3{%91}[1], $119{%138}[0]], $119{%140}[0]))
        130: local(%149, query)
        131: local(%1, prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]]], $119{%140}[0]))
        132: local(%151, query)
        133: local(%1, prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]]], nil))
        134: local(%153, query)
        135: local(%1, redundant([$3{%91}[1], $119{%138}[0]], $3{%90}[0]))
        136: local(%155, query)
        137: local(%1, prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]]], $3{%90}[0]))
        138: local(%157, query)
        139: local(%1, redundant([$3{%91}[1], $119{%138}[0]], $3{%91}[0]))
        140: local(%159, query)
        141: local(%1, prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]]], $3{%91}[0]))
        142: local(%161, query)
        143: local(%1, redundant([$3{%91}[1], $119{%138}[0], $3{%91}[0]], $3{%92}[0]))
        144: local(%163, query)
        145: local(%1, prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]], [$3{%91}[0],
          $141{%162}[1]]], $3{%92}[0]))
        146: local(%165, query)
        147: local(%1, redundant([$3{%91}[1], $119{%138}[0], $3{%91}[0], $3{%92}[0]], $3{%92}[1]))
        148: local(%167, query)
        149: local(%1, prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]], [$3{%91}[0],
          $141{%162}[1]], [$3{%92}[0], $145{%166}[1]]], nil))
        150: local(%169, query)
      answers:
        1:
          space: 2
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (assertion)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;
                      while y < 100000 do  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }  (* GOAL *)
                  goal_formula: x >= y
        2:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= y
                  - trick: negation
                    invariant: x - y >= 0
        3:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= y
        4:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= y
                  - trick: monotone
                    invariant: x >= y
        5:
          space: 6
          answer:
            mode: null
            content: |
              false
              ...
        6:
          space: 8
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { x >= y }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { x >= y }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1)
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { x >= y }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        7:
          space: 10
          answer:
            mode: null
            content: |
              false
              ...
        8:
          space: 12
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { x - y >= 0 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: (1 - 0) >= 0
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { x - y >= 0 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: ((x + y) - (y + 1)) >= 0
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { x - y >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        9:
          space: 14
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: cond_guard
                    invariant: x >= y
                  - trick: linear
                    invariant: x >= y
        10:
          space: 14
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: strengthen_inv
                    invariant: x >= y
        11:
          space: 14
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: cond_guard
                    invariant: x >= y
        12:
          space: 14
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: relax_loop_guard
                    invariant: x >= y
                  - trick: propose_post
                    invariant: x >= y
        13:
          space: 14
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: range
                    invariant: x >= y
        14:
          space: 14
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: cond_guard
                    invariant: x >= y provisions after the loop youth lose squ parlament gift oppon strata
                      nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime
                      personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt=
        15:
          space: 14
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= y * (y - 1) / 2
        16:
          space: 16
          answer:
            mode: null
            content: |
              null
              ...
        17:
          space: 18
          answer:
            mode: null
            content: |
              null
              ...
        18:
          space: 20
          answer:
            mode: null
            content: |
              false
              ...
        19:
          space: 22
          answer:
            mode: null
            content: |
              error: 'File line 9, characters 93-94: illegal character ő'
              obligations: []
        20:
          space: 24
          answer:
            mode: null
            content: |
              false
              ...
        21:
          space: 26
          answer:
            mode: null
            content: |
              error: 'File line 9, characters 33-34: unbound function or predicate symbol ''(/)'''
              obligations: []
        22:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= 0
                  - trick: linear
                    invariant: x >= y*(y-1)/2 + y
        23:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= y
                  - trick: relax_loop_guard
                    invariant: y <= 100000
        24:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: propose_post
                    invariant: x >= y
                  - trick: linear
                    invariant: x >= y*(y - 1)/2
                  - trick: linear
                    invariant: x >= (y - 1)*y/2
        25:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= 0 && y >= 0
        26:
          space: 28
          answer:
            mode: null
            content: |
              null
              ...
        27:
          space: 30
          answer:
            mode: null
            content: |
              null
              ...
        28:
          space: 32
          answer:
            mode: null
            content: |
              null
              ...
        29:
          space: 34
          answer:
            mode: null
            content: |
              null
              ...
        30:
          space: 36
          answer:
            mode: null
            content: |
              null
              ...
        31:
          space: 38
          answer:
            mode: null
            content: |
              null
              ...
        32:
          space: 40
          answer:
            mode: null
            content: |
              false
              ...
        33:
          space: 42
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;
                      while y < 100000 do
                        invariant { x >= 0 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;
                      while y < 100000 do  (* premise *)
                        invariant { x >= 0 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 0
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;
                      while y < 100000 do  (* premise *)
                        invariant { x >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        34:
          space: 44
          answer:
            mode: null
            content: |
              false
              ...
        35:
          space: 46
          answer:
            mode: null
            content: |
              error: 'File line 9, characters 28-29: unbound function or predicate symbol ''(/)'''
              obligations: []
        36:
          space: 48
          answer:
            mode: null
            content: |
              false
              ...
        37:
          space: 50
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        x <- x + y;
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        38:
          space: 52
          answer:
            mode: null
            content: |
              false
              ...
        39:
          space: 54
          answer:
            mode: null
            content: |
              error: 'File line 10, characters 30-31: unbound function or predicate symbol ''(/)'''
              obligations: []
        40:
          space: 56
          answer:
            mode: null
            content: |
              false
              ...
        41:
          space: 58
          answer:
            mode: null
            content: |
              error: 'File line 10, characters 30-31: unbound function or predicate symbol ''(/)'''
              obligations: []
        42:
          space: 60
          answer:
            mode: null
            content: |
              false
              ...
        43:
          space: 62
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { x >= 0 && y >= 0 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0 && 0 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 0 && (y + 1) >= 0
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        44:
          space: 64
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { x >= 0 && y >= 0 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }
                  goal_formula: 1 >= 0 && 0 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { x >= y }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { x >= y }
                  goal_formula: (x + y) >= 0 && (y + 1) >= 0
                - name: VC for main (assertion)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }  (* GOAL *)
                  goal_formula: x >= y
        45:
          space: 66
          answer:
            mode: null
            content: |
              false
              ...
        46:
          space: 68
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { x >= 0 && y >= 0 }
                        invariant { x >= y }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* GOAL *)
                        invariant { x >= y }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0 && 0 >= 0
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        invariant { x >= y }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        invariant { x >= y }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                        invariant { x >= y }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 0 && (y + 1) >= 0
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        invariant { x >= y }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1)
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        invariant { x >= y }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        47:
          space: 70
          answer:
            mode: null
            content: |
              false
              ...
        48:
          space: 72
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { x >= 0 && y >= 0 }
                        invariant { x - y >= 0 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* GOAL *)
                        invariant { x - y >= 0 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0 && 0 >= 0
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        invariant { x - y >= 0 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: (1 - 0) >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        invariant { x - y >= 0 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                        invariant { x - y >= 0 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 0 && (y + 1) >= 0
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        invariant { x - y >= 0 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: ((x + y) - (y + 1)) >= 0
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        invariant { x - y >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        49:
          space: 74
          answer:
            mode: null
            content: |
              true
              ...
        50:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x - y*(y-1)/2 >= 1
        51:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: propose_post
                    invariant: x >= y
        52:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= 1
                  - trick: monotone
                    invariant: y <= 100000
        53:
          space: 4
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: true_or_continue
                    invariant: x >= y || y < 100000
                  - trick: linear
                    invariant: x >= 0
        54:
          space: 78
          answer:
            mode: null
            content: |
              false
              ...
        55:
          space: 80
          answer:
            mode: null
            content: |
              error: 'File line 9, characters 27-28: unbound function or predicate symbol ''(/)'''
              obligations: []
        56:
          space: 82
          answer:
            mode: null
            content: |
              false
              ...
        57:
          space: 84
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { x >= y }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { x >= y }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1)
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { x >= y }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        58:
          space: 86
          answer:
            mode: null
            content: |
              false
              ...
        59:
          space: 88
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;
                      while y < 100000 do
                        invariant { x >= 1 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 1
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;
                      while y < 100000 do  (* premise *)
                        invariant { x >= 1 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 1
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;
                      while y < 100000 do  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        60:
          space: 90
          answer:
            mode: null
            content: |
              false
              ...
        61:
          space: 92
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        x <- x + y;
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        62:
          space: 94
          answer:
            mode: null
            content: |
              false
              ...
        63:
          space: 96
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { x >= y || y < 100000 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0 || 0 < 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { x >= y || y < 100000 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1) || (y + 1) < 100000
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        64:
          space: 98
          answer:
            mode: null
            content: |
              false
              ...
        65:
          space: 100
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { x >= 0 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { x >= 0 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 0
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        66:
          space: 102
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        x <- x + y;
                        y <- y + 1  (* premise *)
                      done;
                      assert { x >= y }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (assertion)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }  (* GOAL *)
                  goal_formula: x >= y
        67:
          space: 104
          answer:
            mode: null
            content: |
              false
              ...
        68:
          space: 106
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { x >= y }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= y }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { x >= y }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= y }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1)
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= y }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        69:
          space: 108
          answer:
            mode: null
            content: |
              false
              ...
        70:
          space: 110
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { x >= 1 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 1 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 1
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { x >= 1 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 1 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 1
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        71:
          space: 112
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= 0
        72:
          space: 112
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: monotone
                    invariant: x >= 0
        73:
          space: 112
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= 0
                  - trick: linear
                    invariant: x >= y*(y-1)/2
        74:
          space: 114
          answer:
            mode: null
            content: |
              null
              ...
        75:
          space: 116
          answer:
            mode: null
            content: |
              false
              ...
        76:
          space: 118
          answer:
            mode: null
            content: |
              error: 'File line 10, characters 28-29: unbound function or predicate symbol ''(/)'''
              obligations: []
        77:
          space: 120
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: monotone
                    invariant: y >= 0
        78:
          space: 120
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= y
        79:
          space: 120
          answer:
            mode: null
            content:
              structured:
                suggestions:
                  - trick: linear
                    invariant: x >= (y * (y - 1)) / 2
                  - trick: linear
                    invariant: x >= 0
        80:
          space: 122
          answer:
            mode: null
            content: |
              null
              ...
        81:
          space: 124
          answer:
            mode: null
            content: |
              null
              ...
        82:
          space: 126
          answer:
            mode: null
            content: |
              false
              ...
        83:
          space: 128
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { y >= 0 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { y >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL, premise *)
                        x <- x + y;
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) >= 0
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        84:
          space: 130
          answer:
            mode: null
            content: |
              false
              ...
        85:
          space: 132
          answer:
            mode: null
            content: |
              error: 'File line 11, characters 35-36: unbound function or predicate symbol ''(/)'''
              obligations: []
        86:
          space: 134
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { y >= 0 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }
                  goal_formula: 0 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { y >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1  (* premise *)
                      done;
                      assert { x >= y }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL, premise *)
                        x <- x + y;
                        y <- y + 1  (* premise *)
                      done;
                      assert { x >= y }
                  goal_formula: (y + 1) >= 0
                - name: VC for main (assertion)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }  (* GOAL *)
                  goal_formula: x >= y
        87:
          space: 136
          answer:
            mode: null
            content: |
              false
              ...
        88:
          space: 138
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { y >= 0 }
                        invariant { x >= y }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL *)
                        invariant { x >= y }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 >= 0
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= y }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= y }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL, premise *)
                        invariant { x >= y }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) >= 0
                - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= y }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1)
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= y }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        89:
          space: 140
          answer:
            mode: null
            content: |
              false
              ...
        90:
          space: 142
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { y >= 0 }
                        invariant { x >= 1 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL *)
                        invariant { x >= 1 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 >= 0
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 1
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL, premise *)
                        invariant { x >= 1 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 1
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        91:
          space: 144
          answer:
            mode: null
            content: |
              false
              ...
        92:
          space: 146
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { y >= 0 }
                        invariant { x >= 1 }
                        invariant { x >= y || y < 100000 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL *)
                        invariant { x >= 1 }
                        invariant { x >= y || y < 100000 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 0 >= 0
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* GOAL *)
                        invariant { x >= y || y < 100000 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 1
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: 1 >= 0 || 0 < 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL, premise *)
                        invariant { x >= 1 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (y + 1) >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* GOAL, premise *)
                        invariant { x >= y || y < 100000 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 1
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1) || (y + 1) < 100000
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { true }  (* GOAL *)
                  goal_formula: 'true'
        93:
          space: 148
          answer:
            mode: null
            content: |
              true
              ...
        94:
          space: 150
          answer:
            mode: null
            content: |
              error: null
              obligations:
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* GOAL *)
                        invariant { y >= 0 }
                        invariant { x >= 1 }
                        invariant { x >= y || y < 100000 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }
                  goal_formula: 0 <= 100000
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL *)
                        invariant { x >= 1 }
                        invariant { x >= y || y < 100000 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }
                  goal_formula: 0 >= 0
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* GOAL *)
                        invariant { x >= y || y < 100000 }
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }
                  goal_formula: 1 >= 1
                - name: VC for main (loop invariant init)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* GOAL *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }
                  goal_formula: 1 >= 0 || 0 < 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* GOAL, premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { x >= y }
                  goal_formula: (y + 1) <= 100000
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* GOAL, premise *)
                        invariant { x >= 1 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { x >= y }
                  goal_formula: (y + 1) >= 0
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* GOAL, premise *)
                        invariant { x >= y || y < 100000 }  (* premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { x >= y }
                  goal_formula: (x + y) >= 1
                - name: VC for main (loop invariant preservation)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { x >= y }
                  goal_formula: (x + y) >= (y + 1) || (y + 1) < 100000
                - name: VC for main (assertion)
                  proved: true
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= 1 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }  (* GOAL *)
                  goal_formula: x >= y
    log:
      - message: 'Explore fact: None'
        level: info
        message_id: 0
        time: 2025-11-05 19:23:37.241225
        metadata:
          facts_stats:
            num_candidates: 1
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: llm_request
        level: info
        message_id: 1
        time: 2025-11-05 19:23:37.252618
        space: 4
        metadata:
          query: SuggestInvariants
          request:
            chat:
              - role: system
                content: |-
                  Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                  We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`. I insist, and this is **VERY IMPORTANT**, you must **NOT** propose invariants involving complex arithmetic such as `2 * x >= y * (y + 1)`.

                  I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest a list of new invariant candidates that may unlock the proof.

                  In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`). The name of the failing proof obligation also provides a hint about the nature of the problem, which is either:

                  - `assertion`: the final assertion is not implied by the invariants
                  - `loop invariant init`: an invariant does not hold initially
                  - `loop invariant preservation`: an invariant cannot be proved to be preserved by the loop body (it may not be preserved or an additional invariant may be needed to complete the proof)

                  Please suggest new invariant candidates. Each invariant candidate must be obtained by following one of the _tricks_ discussed below. A trick can be used multiple times. Do not suggest candidates that are already established invariants.

                  Answer as a JSON object representing a list of `(trick_name, suggested_invariant)` pairs and **nothing else**.

                  Examples are provided that include additional explanations for clarity. Do not include such explanations in your answer.


                  ## Notes on Why3

                  - The `any T` construct generates an arbitrary object of type `T`. In particular, a loop whose guard is `any bool` can run for an arbitrary number of times.


                  ## Tricks

                  Each trick is identified by a unique name. For each trick, we discuss *when* it is applicable and *what* the corresponding recipe is.

                  ### propose_post

                  If the final assertion fails to prove but appears to hold through the whole program, propose it as an invariant.

                  ### monotone

                  Whenever a variable `x` is only incremented (resp. decremented), propose invariant `x >= c` (resp. `x <= c`) for `c` some numerical constant.

                  ### linear

                  Whenever a linear equality or inequality between variables appears to hold throughout the program (e.g. `x - y >= 0`, `3*x + 2*y = 1`...), consider proposing it as an invariant.

                  ### abduct_post

                  If the final assertion fails to prove, look for a missing assumption that implies it when assuming all established invariants (along with the negation of the loop guard). Propose this assumption as a new invariant candidate.

                  ### abduct_inv

                  If an invariant cannot be proved to be preserved, look for a missing assumption and propose it as a new invariant.

                  ### strengthen_inv

                  If an invariant cannot be proved to be preserved, consider making it stronger (e.g proposing `x < y` as a replacement for `x <> y`).

                  ### guard_inv

                  If proving an invariant `inv` requires assuming a global assumption `assum` that is only made _after_ the loop, consider proposing `assum -> inv` as an invariant instead.

                  ### true_or_continue

                  If a property `P` always holds after the loop but cannot be proved as an invariant because `P` does not hold initially, consider proposing `P || loop_guard` as an invariant instead.

                  ### cond_guard

                  If proving the preservation of an invariant candidate requires proving that a specific branch in the code cannot be taken (or is always taken), consider proposing an invariant that establishes this fact.

                  ### relax_loop_guard

                  Suppose the loop guard is an inequality such as `expr < c` with `expr` an expression and `c` a constant. Then, if quantity `expr` cannot increase more than a constant amount `d` at each iteration, consider proposing `expr < c + d` as an invariant (and similarly for <=, > and >=).
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: clearly_true
                          invariant: z <= 0
                        - trick: propose_post
                          invariant: x <> y
                  justification: |
                    Explanations:
                      - Since `z` is only decremented and starts at `0`, invariant `z <= 0` clearly holds. It is also likely to be useful since it shows that the conditional statement within the loop body always executes.
                      - The post-condition `x <> y` is true initially. It is also preserved by the loop body since the conditional statement is always executed (and so both `x` and `y` are incremented at each iteration). Thus, proposing it as an invariant is reasonable.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: cond_guard
                          invariant: z <= 0
                  justification: |
                    Explanations:
                    - From the shown obligation, Why3 cannot prove that `x <> y` is preserved by the loop body. However, this is true since the conditional statement is always executed, and thus both `x` and `y` are incremented at each iteration. In turn, the conditional statement is always executed since `z` starts at `0` and is only decremented. This suggests adding `z <= 0` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = any int in  (* premise *)
                    assume { x < 5 };  (* premise *)
                    assume { x >= 2 };  (* premise *)
                    assume { y <= 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 2;
                      y <- y - 3;
                    done;
                    assert { y <= 14 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: linear
                          invariant: 3*x - 2*y >= 6
                        - trick: relax_loop_guard
                          invariant: x < 12
                  justification: |
                    Explanations:
                      - Since `y` is decremented by 3 every time `x` in incremented by `2`, the quantity `3*x - 2*y` is constant throughout the program. Since it at least `3*2 - 2*0 = 6` initially, the inequality "3*x - 2*y >= 6" is an invariant.
                      - `x` is only incremented by `2` at each loop iteration. Thus, given the loop guard `x < 10`, we have `x < 12` at the end of any loop iteration. `x < 12` also holds initially because of assumption `x < 5` so we propose `x < 12` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* premise *)
                    let ref x = 0 in
                    let ref g = any int in
                    while x < n do  (* premise *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then  (* premise *)
                      assert { g >= 1 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: abduct_post
                          invariant: n > 0 -> x >= n -> g >= 1
                  justification: |
                    Explanations:
                      - We want to add an invariant that implies the final assertion `g >= 1`, assuming `n > 0` (the guard around the assertion) and `x >= n` (the negation of the loop guard). Suggesting `g >= 1` does not work since `g >= 1` does not hold initially. We propose trying the whole obligation itself as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in
                    let ref x = 0 in
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: true_or_continue
                          invariant: g >= 1 || x < n
                  justification: |
                    Explanations:
                      - The user tried to prove `g >= 1` as an invariant but it does not hold initially. Still, it always hold after an iteration of the loop since the loop body sets `g` to 4. Thus, I am proposing to try invariant `g >= 1 || x < n` instead.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* GOAL *)
                    let ref x = 0 in  (* GOAL *)
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 || x < n }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: guard_inv
                          invariant: n > 0 -> (g >= 1 || x < n)
                  justification: |-
                    Explanations:
                      - The user tried to prove `g >= 1 || x < n` as an invariant but it does not hold initially. Indeed, no assumption about `n` is known initially. However, a useful assumption `n > 0` is made after the loop. Thus, I propose guarding the current candidate with it and suggesting `n > 0 -> (g >= 1 || x < n)` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let main () diverges =  (* GOAL *)
                    let ref x = any int in
                    let ref y = any int in
                    x <- 1;
                    y <- 0;
                    while y < 100000 do  (* premise *)
                      x <- x + y;
                      y <- y + 1
                    done;
                    assert { x >= y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for main (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
            options:
              temperature: 1.5
            num_completions: 4
            structured_output:
              name: InvariantSuggestions
              description: |-
                A sequence of suggestions, each of which consists in a trick name
                along with an invariant proposal.
              schema:
                $defs:
                  InvariantSuggestion:
                    properties:
                      trick:
                        title: Trick
                        type: string
                      invariant:
                        title: Invariant
                        type: string
                    required:
                      - trick
                      - invariant
                    title: InvariantSuggestion
                    type: object
                properties:
                  suggestions:
                    items:
                      $ref: '#/$defs/InvariantSuggestion'
                    title: Suggestions
                    type: array
                required:
                  - suggestions
                title: InvariantSuggestions
                type: object
      - message: llm_response
        level: info
        message_id: 2
        related:
          - 1
        time: 2025-11-05 19:23:39.062470
        space: 4
        metadata:
          response:
            outputs:
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= y
                      - trick: negation
                        invariant: x - y >= 0
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= y
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= y
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= y
                      - trick: monotone
                        invariant: x >= y
                tool_calls: []
            budget:
              values:
                num_requests: 1
                num_completions: 4
                input_tokens: 3273
                output_tokens: 183
                cached_input_tokens: 2944
                price: 0.00017969999999999998
            log_items: []
            model_name: gpt-4.1-nano-2025-04-14
            usage_info:
              completion_tokens: 183
              prompt_tokens: 3273
              total_tokens: 3456
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 2944
          usage:
            model: gpt-4.1-nano-2025-04-14
            usage:
              completion_tokens: 183
              prompt_tokens: 3273
              total_tokens: 3456
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 2944
      - message: 'Suggestions: [''x >= y'', ''x - y >= 0'', ''x >= y'', ''x >= y'', ''x >= y'', ''x >=
          y'']'
        level: info
        message_id: 3
        time: 2025-11-05 19:23:39.070267
        metadata:
          facts_stats:
            num_candidates: 1
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Filtered: {''x >= y'': 5, ''x - y >= 0'': 1}'
        level: info
        message_id: 4
        time: 2025-11-05 19:23:39.188934
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Explore fact: x >= y'
        level: info
        message_id: 5
        time: 2025-11-05 19:23:39.188962
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: llm_request
        level: info
        message_id: 6
        time: 2025-11-05 19:23:39.195221
        space: 14
        metadata:
          query: SuggestInvariants
          request:
            chat:
              - role: system
                content: |-
                  Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                  We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`. I insist, and this is **VERY IMPORTANT**, you must **NOT** propose invariants involving complex arithmetic such as `2 * x >= y * (y + 1)`.

                  I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest a list of new invariant candidates that may unlock the proof.

                  In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`). The name of the failing proof obligation also provides a hint about the nature of the problem, which is either:

                  - `assertion`: the final assertion is not implied by the invariants
                  - `loop invariant init`: an invariant does not hold initially
                  - `loop invariant preservation`: an invariant cannot be proved to be preserved by the loop body (it may not be preserved or an additional invariant may be needed to complete the proof)

                  Please suggest new invariant candidates. Each invariant candidate must be obtained by following one of the _tricks_ discussed below. A trick can be used multiple times. Do not suggest candidates that are already established invariants.

                  Answer as a JSON object representing a list of `(trick_name, suggested_invariant)` pairs and **nothing else**.

                  Examples are provided that include additional explanations for clarity. Do not include such explanations in your answer.


                  ## Notes on Why3

                  - The `any T` construct generates an arbitrary object of type `T`. In particular, a loop whose guard is `any bool` can run for an arbitrary number of times.


                  ## Tricks

                  Each trick is identified by a unique name. For each trick, we discuss *when* it is applicable and *what* the corresponding recipe is.

                  ### propose_post

                  If the final assertion fails to prove but appears to hold through the whole program, propose it as an invariant.

                  ### monotone

                  Whenever a variable `x` is only incremented (resp. decremented), propose invariant `x >= c` (resp. `x <= c`) for `c` some numerical constant.

                  ### linear

                  Whenever a linear equality or inequality between variables appears to hold throughout the program (e.g. `x - y >= 0`, `3*x + 2*y = 1`...), consider proposing it as an invariant.

                  ### abduct_post

                  If the final assertion fails to prove, look for a missing assumption that implies it when assuming all established invariants (along with the negation of the loop guard). Propose this assumption as a new invariant candidate.

                  ### abduct_inv

                  If an invariant cannot be proved to be preserved, look for a missing assumption and propose it as a new invariant.

                  ### strengthen_inv

                  If an invariant cannot be proved to be preserved, consider making it stronger (e.g proposing `x < y` as a replacement for `x <> y`).

                  ### guard_inv

                  If proving an invariant `inv` requires assuming a global assumption `assum` that is only made _after_ the loop, consider proposing `assum -> inv` as an invariant instead.

                  ### true_or_continue

                  If a property `P` always holds after the loop but cannot be proved as an invariant because `P` does not hold initially, consider proposing `P || loop_guard` as an invariant instead.

                  ### cond_guard

                  If proving the preservation of an invariant candidate requires proving that a specific branch in the code cannot be taken (or is always taken), consider proposing an invariant that establishes this fact.

                  ### relax_loop_guard

                  Suppose the loop guard is an inequality such as `expr < c` with `expr` an expression and `c` a constant. Then, if quantity `expr` cannot increase more than a constant amount `d` at each iteration, consider proposing `expr < c + d` as an invariant (and similarly for <=, > and >=).
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: clearly_true
                          invariant: z <= 0
                        - trick: propose_post
                          invariant: x <> y
                  justification: |
                    Explanations:
                      - Since `z` is only decremented and starts at `0`, invariant `z <= 0` clearly holds. It is also likely to be useful since it shows that the conditional statement within the loop body always executes.
                      - The post-condition `x <> y` is true initially. It is also preserved by the loop body since the conditional statement is always executed (and so both `x` and `y` are incremented at each iteration). Thus, proposing it as an invariant is reasonable.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: cond_guard
                          invariant: z <= 0
                  justification: |
                    Explanations:
                    - From the shown obligation, Why3 cannot prove that `x <> y` is preserved by the loop body. However, this is true since the conditional statement is always executed, and thus both `x` and `y` are incremented at each iteration. In turn, the conditional statement is always executed since `z` starts at `0` and is only decremented. This suggests adding `z <= 0` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = any int in  (* premise *)
                    assume { x < 5 };  (* premise *)
                    assume { x >= 2 };  (* premise *)
                    assume { y <= 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 2;
                      y <- y - 3;
                    done;
                    assert { y <= 14 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: linear
                          invariant: 3*x - 2*y >= 6
                        - trick: relax_loop_guard
                          invariant: x < 12
                  justification: |
                    Explanations:
                      - Since `y` is decremented by 3 every time `x` in incremented by `2`, the quantity `3*x - 2*y` is constant throughout the program. Since it at least `3*2 - 2*0 = 6` initially, the inequality "3*x - 2*y >= 6" is an invariant.
                      - `x` is only incremented by `2` at each loop iteration. Thus, given the loop guard `x < 10`, we have `x < 12` at the end of any loop iteration. `x < 12` also holds initially because of assumption `x < 5` so we propose `x < 12` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* premise *)
                    let ref x = 0 in
                    let ref g = any int in
                    while x < n do  (* premise *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then  (* premise *)
                      assert { g >= 1 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: abduct_post
                          invariant: n > 0 -> x >= n -> g >= 1
                  justification: |
                    Explanations:
                      - We want to add an invariant that implies the final assertion `g >= 1`, assuming `n > 0` (the guard around the assertion) and `x >= n` (the negation of the loop guard). Suggesting `g >= 1` does not work since `g >= 1` does not hold initially. We propose trying the whole obligation itself as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in
                    let ref x = 0 in
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: true_or_continue
                          invariant: g >= 1 || x < n
                  justification: |
                    Explanations:
                      - The user tried to prove `g >= 1` as an invariant but it does not hold initially. Still, it always hold after an iteration of the loop since the loop body sets `g` to 4. Thus, I am proposing to try invariant `g >= 1 || x < n` instead.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* GOAL *)
                    let ref x = 0 in  (* GOAL *)
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 || x < n }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: guard_inv
                          invariant: n > 0 -> (g >= 1 || x < n)
                  justification: |-
                    Explanations:
                      - The user tried to prove `g >= 1 || x < n` as an invariant but it does not hold initially. Indeed, no assumption about `n` is known initially. However, a useful assumption `n > 0` is made after the loop. Thus, I propose guarding the current candidate with it and suggesting `n > 0 -> (g >= 1 || x < n)` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let main () diverges =  (* GOAL *)
                    let ref x = any int in
                    let ref y = any int in
                    x <- 1;  (* premise *)
                    y <- 0;  (* premise *)
                    while y < 100000 do  (* premise *)
                      invariant { x >= y }  (* GOAL, premise *)
                      x <- x + y;  (* premise *)
                      y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for main (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
            options:
              temperature: 1.5
            num_completions: 4
            structured_output:
              name: InvariantSuggestions
              description: |-
                A sequence of suggestions, each of which consists in a trick name
                along with an invariant proposal.
              schema:
                $defs:
                  InvariantSuggestion:
                    properties:
                      trick:
                        title: Trick
                        type: string
                      invariant:
                        title: Invariant
                        type: string
                    required:
                      - trick
                      - invariant
                    title: InvariantSuggestion
                    type: object
                properties:
                  suggestions:
                    items:
                      $ref: '#/$defs/InvariantSuggestion'
                    title: Suggestions
                    type: array
                required:
                  - suggestions
                title: InvariantSuggestions
                type: object
      - message: llm_response
        level: info
        message_id: 7
        related:
          - 6
        time: 2025-11-05 19:23:40.489360
        space: 14
        metadata:
          response:
            outputs:
              - content:
                  structured:
                    suggestions:
                      - trick: cond_guard
                        invariant: x >= y
                      - trick: linear
                        invariant: x >= y
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: strengthen_inv
                        invariant: x >= y
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: cond_guard
                        invariant: x >= y
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: relax_loop_guard
                        invariant: x >= y
                      - trick: propose_post
                        invariant: x >= y
                tool_calls: []
            budget:
              values:
                num_requests: 1
                num_completions: 4
                input_tokens: 3296
                output_tokens: 191
                cached_input_tokens: 2944
                price: 0.0001852
            log_items: []
            model_name: gpt-4.1-nano-2025-04-14
            usage_info:
              completion_tokens: 191
              prompt_tokens: 3296
              total_tokens: 3487
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 2944
          usage:
            model: gpt-4.1-nano-2025-04-14
            usage:
              completion_tokens: 191
              prompt_tokens: 3296
              total_tokens: 3487
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 2944
      - message: 'Suggestions: [''x >= y'', ''x >= y'', ''x >= y'', ''x >= y'', ''x >= y'', ''x >= y'']'
        level: info
        message_id: 8
        time: 2025-11-05 19:23:40.495550
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Filtered: {''x >= y'': 6}'
        level: info
        message_id: 9
        time: 2025-11-05 19:23:40.495573
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Explore fact: x >= y'
        level: info
        message_id: 10
        time: 2025-11-05 19:23:40.495587
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: llm_request
        level: info
        message_id: 11
        time: 2025-11-05 19:23:40.503690
        space: 14
        metadata:
          query: SuggestInvariants
          request:
            chat:
              - role: system
                content: |-
                  Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                  We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`. I insist, and this is **VERY IMPORTANT**, you must **NOT** propose invariants involving complex arithmetic such as `2 * x >= y * (y + 1)`.

                  I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest a list of new invariant candidates that may unlock the proof.

                  In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`). The name of the failing proof obligation also provides a hint about the nature of the problem, which is either:

                  - `assertion`: the final assertion is not implied by the invariants
                  - `loop invariant init`: an invariant does not hold initially
                  - `loop invariant preservation`: an invariant cannot be proved to be preserved by the loop body (it may not be preserved or an additional invariant may be needed to complete the proof)

                  Please suggest new invariant candidates. Each invariant candidate must be obtained by following one of the _tricks_ discussed below. A trick can be used multiple times. Do not suggest candidates that are already established invariants.

                  Answer as a JSON object representing a list of `(trick_name, suggested_invariant)` pairs and **nothing else**.

                  Examples are provided that include additional explanations for clarity. Do not include such explanations in your answer.


                  ## Notes on Why3

                  - The `any T` construct generates an arbitrary object of type `T`. In particular, a loop whose guard is `any bool` can run for an arbitrary number of times.


                  ## Tricks

                  Each trick is identified by a unique name. For each trick, we discuss *when* it is applicable and *what* the corresponding recipe is.

                  ### propose_post

                  If the final assertion fails to prove but appears to hold through the whole program, propose it as an invariant.

                  ### monotone

                  Whenever a variable `x` is only incremented (resp. decremented), propose invariant `x >= c` (resp. `x <= c`) for `c` some numerical constant.

                  ### linear

                  Whenever a linear equality or inequality between variables appears to hold throughout the program (e.g. `x - y >= 0`, `3*x + 2*y = 1`...), consider proposing it as an invariant.

                  ### abduct_post

                  If the final assertion fails to prove, look for a missing assumption that implies it when assuming all established invariants (along with the negation of the loop guard). Propose this assumption as a new invariant candidate.

                  ### abduct_inv

                  If an invariant cannot be proved to be preserved, look for a missing assumption and propose it as a new invariant.

                  ### strengthen_inv

                  If an invariant cannot be proved to be preserved, consider making it stronger (e.g proposing `x < y` as a replacement for `x <> y`).

                  ### guard_inv

                  If proving an invariant `inv` requires assuming a global assumption `assum` that is only made _after_ the loop, consider proposing `assum -> inv` as an invariant instead.

                  ### true_or_continue

                  If a property `P` always holds after the loop but cannot be proved as an invariant because `P` does not hold initially, consider proposing `P || loop_guard` as an invariant instead.

                  ### cond_guard

                  If proving the preservation of an invariant candidate requires proving that a specific branch in the code cannot be taken (or is always taken), consider proposing an invariant that establishes this fact.

                  ### relax_loop_guard

                  Suppose the loop guard is an inequality such as `expr < c` with `expr` an expression and `c` a constant. Then, if quantity `expr` cannot increase more than a constant amount `d` at each iteration, consider proposing `expr < c + d` as an invariant (and similarly for <=, > and >=).
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: clearly_true
                          invariant: z <= 0
                        - trick: propose_post
                          invariant: x <> y
                  justification: |
                    Explanations:
                      - Since `z` is only decremented and starts at `0`, invariant `z <= 0` clearly holds. It is also likely to be useful since it shows that the conditional statement within the loop body always executes.
                      - The post-condition `x <> y` is true initially. It is also preserved by the loop body since the conditional statement is always executed (and so both `x` and `y` are incremented at each iteration). Thus, proposing it as an invariant is reasonable.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: cond_guard
                          invariant: z <= 0
                  justification: |
                    Explanations:
                    - From the shown obligation, Why3 cannot prove that `x <> y` is preserved by the loop body. However, this is true since the conditional statement is always executed, and thus both `x` and `y` are incremented at each iteration. In turn, the conditional statement is always executed since `z` starts at `0` and is only decremented. This suggests adding `z <= 0` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = any int in  (* premise *)
                    assume { x < 5 };  (* premise *)
                    assume { x >= 2 };  (* premise *)
                    assume { y <= 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 2;
                      y <- y - 3;
                    done;
                    assert { y <= 14 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: linear
                          invariant: 3*x - 2*y >= 6
                        - trick: relax_loop_guard
                          invariant: x < 12
                  justification: |
                    Explanations:
                      - Since `y` is decremented by 3 every time `x` in incremented by `2`, the quantity `3*x - 2*y` is constant throughout the program. Since it at least `3*2 - 2*0 = 6` initially, the inequality "3*x - 2*y >= 6" is an invariant.
                      - `x` is only incremented by `2` at each loop iteration. Thus, given the loop guard `x < 10`, we have `x < 12` at the end of any loop iteration. `x < 12` also holds initially because of assumption `x < 5` so we propose `x < 12` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* premise *)
                    let ref x = 0 in
                    let ref g = any int in
                    while x < n do  (* premise *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then  (* premise *)
                      assert { g >= 1 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: abduct_post
                          invariant: n > 0 -> x >= n -> g >= 1
                  justification: |
                    Explanations:
                      - We want to add an invariant that implies the final assertion `g >= 1`, assuming `n > 0` (the guard around the assertion) and `x >= n` (the negation of the loop guard). Suggesting `g >= 1` does not work since `g >= 1` does not hold initially. We propose trying the whole obligation itself as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in
                    let ref x = 0 in
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: true_or_continue
                          invariant: g >= 1 || x < n
                  justification: |
                    Explanations:
                      - The user tried to prove `g >= 1` as an invariant but it does not hold initially. Still, it always hold after an iteration of the loop since the loop body sets `g` to 4. Thus, I am proposing to try invariant `g >= 1 || x < n` instead.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* GOAL *)
                    let ref x = 0 in  (* GOAL *)
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 || x < n }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: guard_inv
                          invariant: n > 0 -> (g >= 1 || x < n)
                  justification: |-
                    Explanations:
                      - The user tried to prove `g >= 1 || x < n` as an invariant but it does not hold initially. Indeed, no assumption about `n` is known initially. However, a useful assumption `n > 0` is made after the loop. Thus, I propose guarding the current candidate with it and suggesting `n > 0 -> (g >= 1 || x < n)` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let main () diverges =  (* GOAL *)
                    let ref x = any int in
                    let ref y = any int in
                    x <- 1;  (* premise *)
                    y <- 0;  (* premise *)
                    while y < 100000 do  (* premise *)
                      invariant { x >= y }  (* GOAL, premise *)
                      x <- x + y;  (* premise *)
                      y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for main (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
            options:
              temperature: 1.5
            num_completions: 4
            structured_output:
              name: InvariantSuggestions
              description: |-
                A sequence of suggestions, each of which consists in a trick name
                along with an invariant proposal.
              schema:
                $defs:
                  InvariantSuggestion:
                    properties:
                      trick:
                        title: Trick
                        type: string
                      invariant:
                        title: Invariant
                        type: string
                    required:
                      - trick
                      - invariant
                    title: InvariantSuggestion
                    type: object
                properties:
                  suggestions:
                    items:
                      $ref: '#/$defs/InvariantSuggestion'
                    title: Suggestions
                    type: array
                required:
                  - suggestions
                title: InvariantSuggestions
                type: object
      - message: llm_response
        level: info
        message_id: 12
        related:
          - 11
        time: 2025-11-05 19:23:43.454701
        space: 14
        metadata:
          response:
            outputs:
              - content:
                  structured:
                    suggestions:
                      - trick: range
                        invariant: x >= y
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: cond_guard
                        invariant: x >= y provisions after the loop youth lose squ parlament gift oppon
                          strata nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence
                          새로운 régime personality,new clutch anzeigen时报 zwölf ondernemer oversees simple
                          pick yt=
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= y * (y - 1) / 2
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: cond_guard
                        invariant: x >= y
                tool_calls: []
            budget:
              values:
                num_requests: 1
                num_completions: 4
                input_tokens: 3296
                output_tokens: 193
                cached_input_tokens: 2944
                price: 0.000186
            log_items: []
            model_name: gpt-4.1-nano-2025-04-14
            usage_info:
              completion_tokens: 193
              prompt_tokens: 3296
              total_tokens: 3489
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 2944
          usage:
            model: gpt-4.1-nano-2025-04-14
            usage:
              completion_tokens: 193
              prompt_tokens: 3296
              total_tokens: 3489
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 2944
      - message: 'Suggestions: [''x >= y'', ''x >= y provisions after the loop youth lose squ parlament
          gift oppon strata nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운
          régime personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt='', ''x >=
          y * (y - 1) / 2'', ''x >= y'']'
        level: info
        message_id: 13
        time: 2025-11-05 19:23:43.467053
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Disproved: x >= y provisions after the loop youth lose squ parlament gift oppon strata
          nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime personality,new
          clutch anzeigen时报 zwölf ondernemer oversees simple pick yt='
        level: info
        message_id: 14
        time: 2025-11-05 19:23:43.478373
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Disproved: x >= y * (y - 1) / 2'
        level: info
        message_id: 15
        time: 2025-11-05 19:23:43.482894
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Filtered: {''x >= y'': 2}'
        level: info
        message_id: 16
        time: 2025-11-05 19:23:43.482909
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Explore fact: None'
        level: info
        message_id: 17
        time: 2025-11-05 19:23:43.482928
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: llm_request
        level: info
        message_id: 18
        time: 2025-11-05 19:23:43.492329
        space: 4
        metadata:
          query: SuggestInvariants
          request:
            chat:
              - role: system
                content: |-
                  Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                  We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`. I insist, and this is **VERY IMPORTANT**, you must **NOT** propose invariants involving complex arithmetic such as `2 * x >= y * (y + 1)`.

                  I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest a list of new invariant candidates that may unlock the proof.

                  In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`). The name of the failing proof obligation also provides a hint about the nature of the problem, which is either:

                  - `assertion`: the final assertion is not implied by the invariants
                  - `loop invariant init`: an invariant does not hold initially
                  - `loop invariant preservation`: an invariant cannot be proved to be preserved by the loop body (it may not be preserved or an additional invariant may be needed to complete the proof)

                  Please suggest new invariant candidates. Each invariant candidate must be obtained by following one of the _tricks_ discussed below. A trick can be used multiple times. Do not suggest candidates that are already established invariants.

                  Answer as a JSON object representing a list of `(trick_name, suggested_invariant)` pairs and **nothing else**.

                  Examples are provided that include additional explanations for clarity. Do not include such explanations in your answer.


                  ## Notes on Why3

                  - The `any T` construct generates an arbitrary object of type `T`. In particular, a loop whose guard is `any bool` can run for an arbitrary number of times.


                  ## Tricks

                  Each trick is identified by a unique name. For each trick, we discuss *when* it is applicable and *what* the corresponding recipe is.

                  ### propose_post

                  If the final assertion fails to prove but appears to hold through the whole program, propose it as an invariant.

                  ### monotone

                  Whenever a variable `x` is only incremented (resp. decremented), propose invariant `x >= c` (resp. `x <= c`) for `c` some numerical constant.

                  ### linear

                  Whenever a linear equality or inequality between variables appears to hold throughout the program (e.g. `x - y >= 0`, `3*x + 2*y = 1`...), consider proposing it as an invariant.

                  ### abduct_post

                  If the final assertion fails to prove, look for a missing assumption that implies it when assuming all established invariants (along with the negation of the loop guard). Propose this assumption as a new invariant candidate.

                  ### abduct_inv

                  If an invariant cannot be proved to be preserved, look for a missing assumption and propose it as a new invariant.

                  ### strengthen_inv

                  If an invariant cannot be proved to be preserved, consider making it stronger (e.g proposing `x < y` as a replacement for `x <> y`).

                  ### guard_inv

                  If proving an invariant `inv` requires assuming a global assumption `assum` that is only made _after_ the loop, consider proposing `assum -> inv` as an invariant instead.

                  ### true_or_continue

                  If a property `P` always holds after the loop but cannot be proved as an invariant because `P` does not hold initially, consider proposing `P || loop_guard` as an invariant instead.

                  ### cond_guard

                  If proving the preservation of an invariant candidate requires proving that a specific branch in the code cannot be taken (or is always taken), consider proposing an invariant that establishes this fact.

                  ### relax_loop_guard

                  Suppose the loop guard is an inequality such as `expr < c` with `expr` an expression and `c` a constant. Then, if quantity `expr` cannot increase more than a constant amount `d` at each iteration, consider proposing `expr < c + d` as an invariant (and similarly for <=, > and >=).
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: clearly_true
                          invariant: z <= 0
                        - trick: propose_post
                          invariant: x <> y
                  justification: |
                    Explanations:
                      - Since `z` is only decremented and starts at `0`, invariant `z <= 0` clearly holds. It is also likely to be useful since it shows that the conditional statement within the loop body always executes.
                      - The post-condition `x <> y` is true initially. It is also preserved by the loop body since the conditional statement is always executed (and so both `x` and `y` are incremented at each iteration). Thus, proposing it as an invariant is reasonable.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: cond_guard
                          invariant: z <= 0
                  justification: |
                    Explanations:
                    - From the shown obligation, Why3 cannot prove that `x <> y` is preserved by the loop body. However, this is true since the conditional statement is always executed, and thus both `x` and `y` are incremented at each iteration. In turn, the conditional statement is always executed since `z` starts at `0` and is only decremented. This suggests adding `z <= 0` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = any int in  (* premise *)
                    assume { x < 5 };  (* premise *)
                    assume { x >= 2 };  (* premise *)
                    assume { y <= 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 2;
                      y <- y - 3;
                    done;
                    assert { y <= 14 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: linear
                          invariant: 3*x - 2*y >= 6
                        - trick: relax_loop_guard
                          invariant: x < 12
                  justification: |
                    Explanations:
                      - Since `y` is decremented by 3 every time `x` in incremented by `2`, the quantity `3*x - 2*y` is constant throughout the program. Since it at least `3*2 - 2*0 = 6` initially, the inequality "3*x - 2*y >= 6" is an invariant.
                      - `x` is only incremented by `2` at each loop iteration. Thus, given the loop guard `x < 10`, we have `x < 12` at the end of any loop iteration. `x < 12` also holds initially because of assumption `x < 5` so we propose `x < 12` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* premise *)
                    let ref x = 0 in
                    let ref g = any int in
                    while x < n do  (* premise *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then  (* premise *)
                      assert { g >= 1 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: abduct_post
                          invariant: n > 0 -> x >= n -> g >= 1
                  justification: |
                    Explanations:
                      - We want to add an invariant that implies the final assertion `g >= 1`, assuming `n > 0` (the guard around the assertion) and `x >= n` (the negation of the loop guard). Suggesting `g >= 1` does not work since `g >= 1` does not hold initially. We propose trying the whole obligation itself as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in
                    let ref x = 0 in
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: true_or_continue
                          invariant: g >= 1 || x < n
                  justification: |
                    Explanations:
                      - The user tried to prove `g >= 1` as an invariant but it does not hold initially. Still, it always hold after an iteration of the loop since the loop body sets `g` to 4. Thus, I am proposing to try invariant `g >= 1 || x < n` instead.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* GOAL *)
                    let ref x = 0 in  (* GOAL *)
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 || x < n }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: guard_inv
                          invariant: n > 0 -> (g >= 1 || x < n)
                  justification: |-
                    Explanations:
                      - The user tried to prove `g >= 1 || x < n` as an invariant but it does not hold initially. Indeed, no assumption about `n` is known initially. However, a useful assumption `n > 0` is made after the loop. Thus, I propose guarding the current candidate with it and suggesting `n > 0 -> (g >= 1 || x < n)` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let main () diverges =  (* GOAL *)
                    let ref x = any int in
                    let ref y = any int in
                    x <- 1;
                    y <- 0;
                    while y < 100000 do  (* premise *)
                      x <- x + y;
                      y <- y + 1
                    done;
                    assert { x >= y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for main (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
            options:
              temperature: 1.5
            num_completions: 4
            structured_output:
              name: InvariantSuggestions
              description: |-
                A sequence of suggestions, each of which consists in a trick name
                along with an invariant proposal.
              schema:
                $defs:
                  InvariantSuggestion:
                    properties:
                      trick:
                        title: Trick
                        type: string
                      invariant:
                        title: Invariant
                        type: string
                    required:
                      - trick
                      - invariant
                    title: InvariantSuggestion
                    type: object
                properties:
                  suggestions:
                    items:
                      $ref: '#/$defs/InvariantSuggestion'
                    title: Suggestions
                    type: array
                required:
                  - suggestions
                title: InvariantSuggestions
                type: object
      - message: llm_response
        level: info
        message_id: 19
        related:
          - 18
        time: 2025-11-05 19:23:45.607780
        space: 4
        metadata:
          response:
            outputs:
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= 0
                      - trick: linear
                        invariant: x >= y*(y-1)/2 + y
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= y
                      - trick: relax_loop_guard
                        invariant: y <= 100000
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: propose_post
                        invariant: x >= y
                      - trick: linear
                        invariant: x >= y*(y - 1)/2
                      - trick: linear
                        invariant: x >= (y - 1)*y/2
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= 0 && y >= 0
                tool_calls: []
            budget:
              values:
                num_requests: 1
                num_completions: 4
                input_tokens: 3273
                output_tokens: 258
                cached_input_tokens: 2944
                price: 0.0002097
            log_items: []
            model_name: gpt-4.1-nano-2025-04-14
            usage_info:
              completion_tokens: 258
              prompt_tokens: 3273
              total_tokens: 3531
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 2944
          usage:
            model: gpt-4.1-nano-2025-04-14
            usage:
              completion_tokens: 258
              prompt_tokens: 3273
              total_tokens: 3531
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 2944
      - message: 'Suggestions: [''x >= 0'', ''x >= y*(y-1)/2 + y'', ''x >= y'', ''y <= 100000'', ''x >=
          y'', ''x >= y*(y - 1)/2'', ''x >= (y - 1)*y/2'', ''x >= 0 && y >= 0'']'
        level: info
        message_id: 20
        time: 2025-11-05 19:23:45.617273
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Disproved: x >= y*(y-1)/2 + y'
        level: info
        message_id: 21
        time: 2025-11-05 19:23:45.864590
        metadata:
          facts_stats:
            num_candidates: 4
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Proved: y <= 100000'
        level: info
        message_id: 22
        time: 2025-11-05 19:23:45.913014
        metadata:
          facts_stats:
            num_candidates: 4
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Disproved: x >= y*(y - 1)/2'
        level: info
        message_id: 23
        time: 2025-11-05 19:23:45.916061
        metadata:
          facts_stats:
            num_candidates: 4
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Disproved: x >= (y - 1)*y/2'
        level: info
        message_id: 24
        time: 2025-11-05 19:23:45.918741
        metadata:
          facts_stats:
            num_candidates: 4
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Proved: x >= 0 && y >= 0'
        level: info
        message_id: 25
        time: 2025-11-05 19:23:45.991672
        metadata:
          facts_stats:
            num_candidates: 4
            num_proved: 2
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: Propagating...
        level: info
        message_id: 26
        time: 2025-11-05 19:23:45.991685
        metadata:
          facts_stats:
            num_candidates: 4
            num_proved: 2
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Redundant: x >= 0'
        level: info
        message_id: 27
        time: 2025-11-05 19:23:46.257454
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 2
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: Propagating...
        level: info
        message_id: 28
        time: 2025-11-05 19:23:46.257467
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 2
            num_disproved: 0
            num_redundant: 1
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Filtered: {''x >= y'': 2}'
        level: info
        message_id: 29
        time: 2025-11-05 19:23:46.515307
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 2
            num_disproved: 0
            num_redundant: 1
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Explore fact: x >= y'
        level: info
        message_id: 30
        time: 2025-11-05 19:23:46.515329
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 2
            num_disproved: 0
            num_redundant: 1
          call_stats:
            prove_calls: 17
            prove_time_in_seconds: 1.000166416168213
            is_redundant_calls: 15
            is_redundant_time_in_seconds: 0.1434023380279541
            search_equivalent_calls: 8
            search_equivalent_time_in_seconds: 0.20057201385498047
      - message: llm_request
        level: info
        message_id: 31
        time: 2025-11-05 19:23:46.521895
        space: 76
        metadata:
          query: SuggestInvariants
          request:
            chat:
              - role: system
                content: |-
                  Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                  We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`. I insist, and this is **VERY IMPORTANT**, you must **NOT** propose invariants involving complex arithmetic such as `2 * x >= y * (y + 1)`.

                  I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest a list of new invariant candidates that may unlock the proof.

                  In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`). The name of the failing proof obligation also provides a hint about the nature of the problem, which is either:

                  - `assertion`: the final assertion is not implied by the invariants
                  - `loop invariant init`: an invariant does not hold initially
                  - `loop invariant preservation`: an invariant cannot be proved to be preserved by the loop body (it may not be preserved or an additional invariant may be needed to complete the proof)

                  Please suggest new invariant candidates. Each invariant candidate must be obtained by following one of the _tricks_ discussed below. A trick can be used multiple times. Do not suggest candidates that are already established invariants.

                  Answer as a JSON object representing a list of `(trick_name, suggested_invariant)` pairs and **nothing else**.

                  Examples are provided that include additional explanations for clarity. Do not include such explanations in your answer.


                  ## Notes on Why3

                  - The `any T` construct generates an arbitrary object of type `T`. In particular, a loop whose guard is `any bool` can run for an arbitrary number of times.


                  ## Tricks

                  Each trick is identified by a unique name. For each trick, we discuss *when* it is applicable and *what* the corresponding recipe is.

                  ### propose_post

                  If the final assertion fails to prove but appears to hold through the whole program, propose it as an invariant.

                  ### monotone

                  Whenever a variable `x` is only incremented (resp. decremented), propose invariant `x >= c` (resp. `x <= c`) for `c` some numerical constant.

                  ### linear

                  Whenever a linear equality or inequality between variables appears to hold throughout the program (e.g. `x - y >= 0`, `3*x + 2*y = 1`...), consider proposing it as an invariant.

                  ### abduct_post

                  If the final assertion fails to prove, look for a missing assumption that implies it when assuming all established invariants (along with the negation of the loop guard). Propose this assumption as a new invariant candidate.

                  ### abduct_inv

                  If an invariant cannot be proved to be preserved, look for a missing assumption and propose it as a new invariant.

                  ### strengthen_inv

                  If an invariant cannot be proved to be preserved, consider making it stronger (e.g proposing `x < y` as a replacement for `x <> y`).

                  ### guard_inv

                  If proving an invariant `inv` requires assuming a global assumption `assum` that is only made _after_ the loop, consider proposing `assum -> inv` as an invariant instead.

                  ### true_or_continue

                  If a property `P` always holds after the loop but cannot be proved as an invariant because `P` does not hold initially, consider proposing `P || loop_guard` as an invariant instead.

                  ### cond_guard

                  If proving the preservation of an invariant candidate requires proving that a specific branch in the code cannot be taken (or is always taken), consider proposing an invariant that establishes this fact.

                  ### relax_loop_guard

                  Suppose the loop guard is an inequality such as `expr < c` with `expr` an expression and `c` a constant. Then, if quantity `expr` cannot increase more than a constant amount `d` at each iteration, consider proposing `expr < c + d` as an invariant (and similarly for <=, > and >=).
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: clearly_true
                          invariant: z <= 0
                        - trick: propose_post
                          invariant: x <> y
                  justification: |
                    Explanations:
                      - Since `z` is only decremented and starts at `0`, invariant `z <= 0` clearly holds. It is also likely to be useful since it shows that the conditional statement within the loop body always executes.
                      - The post-condition `x <> y` is true initially. It is also preserved by the loop body since the conditional statement is always executed (and so both `x` and `y` are incremented at each iteration). Thus, proposing it as an invariant is reasonable.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: cond_guard
                          invariant: z <= 0
                  justification: |
                    Explanations:
                    - From the shown obligation, Why3 cannot prove that `x <> y` is preserved by the loop body. However, this is true since the conditional statement is always executed, and thus both `x` and `y` are incremented at each iteration. In turn, the conditional statement is always executed since `z` starts at `0` and is only decremented. This suggests adding `z <= 0` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = any int in  (* premise *)
                    assume { x < 5 };  (* premise *)
                    assume { x >= 2 };  (* premise *)
                    assume { y <= 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 2;
                      y <- y - 3;
                    done;
                    assert { y <= 14 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: linear
                          invariant: 3*x - 2*y >= 6
                        - trick: relax_loop_guard
                          invariant: x < 12
                  justification: |
                    Explanations:
                      - Since `y` is decremented by 3 every time `x` in incremented by `2`, the quantity `3*x - 2*y` is constant throughout the program. Since it at least `3*2 - 2*0 = 6` initially, the inequality "3*x - 2*y >= 6" is an invariant.
                      - `x` is only incremented by `2` at each loop iteration. Thus, given the loop guard `x < 10`, we have `x < 12` at the end of any loop iteration. `x < 12` also holds initially because of assumption `x < 5` so we propose `x < 12` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* premise *)
                    let ref x = 0 in
                    let ref g = any int in
                    while x < n do  (* premise *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then  (* premise *)
                      assert { g >= 1 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: abduct_post
                          invariant: n > 0 -> x >= n -> g >= 1
                  justification: |
                    Explanations:
                      - We want to add an invariant that implies the final assertion `g >= 1`, assuming `n > 0` (the guard around the assertion) and `x >= n` (the negation of the loop guard). Suggesting `g >= 1` does not work since `g >= 1` does not hold initially. We propose trying the whole obligation itself as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in
                    let ref x = 0 in
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: true_or_continue
                          invariant: g >= 1 || x < n
                  justification: |
                    Explanations:
                      - The user tried to prove `g >= 1` as an invariant but it does not hold initially. Still, it always hold after an iteration of the loop since the loop body sets `g` to 4. Thus, I am proposing to try invariant `g >= 1 || x < n` instead.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* GOAL *)
                    let ref x = 0 in  (* GOAL *)
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 || x < n }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: guard_inv
                          invariant: n > 0 -> (g >= 1 || x < n)
                  justification: |-
                    Explanations:
                      - The user tried to prove `g >= 1 || x < n` as an invariant but it does not hold initially. Indeed, no assumption about `n` is known initially. However, a useful assumption `n > 0` is made after the loop. Thus, I propose guarding the current candidate with it and suggesting `n > 0 -> (g >= 1 || x < n)` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let main () diverges =  (* GOAL *)
                    let ref x = any int in
                    let ref y = any int in
                    x <- 1;  (* premise *)
                    y <- 0;  (* premise *)
                    while y < 100000 do  (* premise *)
                      invariant { y <= 100000 }  (* premise *)
                      invariant { x >= 0 && y >= 0 }  (* premise *)
                      invariant { x >= y }  (* GOAL, premise *)
                      x <- x + y;  (* premise *)
                      y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for main (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
            options:
              temperature: 1.5
            num_completions: 4
            structured_output:
              name: InvariantSuggestions
              description: |-
                A sequence of suggestions, each of which consists in a trick name
                along with an invariant proposal.
              schema:
                $defs:
                  InvariantSuggestion:
                    properties:
                      trick:
                        title: Trick
                        type: string
                      invariant:
                        title: Invariant
                        type: string
                    required:
                      - trick
                      - invariant
                    title: InvariantSuggestion
                    type: object
                properties:
                  suggestions:
                    items:
                      $ref: '#/$defs/InvariantSuggestion'
                    title: Suggestions
                    type: array
                required:
                  - suggestions
                title: InvariantSuggestions
                type: object
      - message: abduct_and_saturate_call_stats
        level: info
        message_id: 32
        time: 2025-11-05 19:23:46.522142
        metadata:
          prove_calls: 17
          prove_time_in_seconds: 1.000166416168213
          is_redundant_calls: 15
          is_redundant_time_in_seconds: 0.1434023380279541
          search_equivalent_calls: 8
          search_equivalent_time_in_seconds: 0.20057201385498047
      - message: 'Explore fact: None'
        level: info
        message_id: 33
        time: 2025-11-05 19:23:46.536136
        metadata:
          facts_stats:
            num_candidates: 1
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: llm_request
        level: info
        message_id: 34
        time: 2025-11-05 19:23:46.542168
        space: 4
        metadata:
          query: SuggestInvariants
          request:
            chat:
              - role: system
                content: |-
                  Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                  We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`. I insist, and this is **VERY IMPORTANT**, you must **NOT** propose invariants involving complex arithmetic such as `2 * x >= y * (y + 1)`.

                  I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest a list of new invariant candidates that may unlock the proof.

                  In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`). The name of the failing proof obligation also provides a hint about the nature of the problem, which is either:

                  - `assertion`: the final assertion is not implied by the invariants
                  - `loop invariant init`: an invariant does not hold initially
                  - `loop invariant preservation`: an invariant cannot be proved to be preserved by the loop body (it may not be preserved or an additional invariant may be needed to complete the proof)

                  Please suggest new invariant candidates. Each invariant candidate must be obtained by following one of the _tricks_ discussed below. A trick can be used multiple times. Do not suggest candidates that are already established invariants.

                  Answer as a JSON object representing a list of `(trick_name, suggested_invariant)` pairs and **nothing else**.

                  Examples are provided that include additional explanations for clarity. Do not include such explanations in your answer.


                  ## Notes on Why3

                  - The `any T` construct generates an arbitrary object of type `T`. In particular, a loop whose guard is `any bool` can run for an arbitrary number of times.


                  ## Tricks

                  Each trick is identified by a unique name. For each trick, we discuss *when* it is applicable and *what* the corresponding recipe is.

                  ### propose_post

                  If the final assertion fails to prove but appears to hold through the whole program, propose it as an invariant.

                  ### monotone

                  Whenever a variable `x` is only incremented (resp. decremented), propose invariant `x >= c` (resp. `x <= c`) for `c` some numerical constant.

                  ### linear

                  Whenever a linear equality or inequality between variables appears to hold throughout the program (e.g. `x - y >= 0`, `3*x + 2*y = 1`...), consider proposing it as an invariant.

                  ### abduct_post

                  If the final assertion fails to prove, look for a missing assumption that implies it when assuming all established invariants (along with the negation of the loop guard). Propose this assumption as a new invariant candidate.

                  ### abduct_inv

                  If an invariant cannot be proved to be preserved, look for a missing assumption and propose it as a new invariant.

                  ### strengthen_inv

                  If an invariant cannot be proved to be preserved, consider making it stronger (e.g proposing `x < y` as a replacement for `x <> y`).

                  ### guard_inv

                  If proving an invariant `inv` requires assuming a global assumption `assum` that is only made _after_ the loop, consider proposing `assum -> inv` as an invariant instead.

                  ### true_or_continue

                  If a property `P` always holds after the loop but cannot be proved as an invariant because `P` does not hold initially, consider proposing `P || loop_guard` as an invariant instead.

                  ### cond_guard

                  If proving the preservation of an invariant candidate requires proving that a specific branch in the code cannot be taken (or is always taken), consider proposing an invariant that establishes this fact.

                  ### relax_loop_guard

                  Suppose the loop guard is an inequality such as `expr < c` with `expr` an expression and `c` a constant. Then, if quantity `expr` cannot increase more than a constant amount `d` at each iteration, consider proposing `expr < c + d` as an invariant (and similarly for <=, > and >=).
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: clearly_true
                          invariant: z <= 0
                        - trick: propose_post
                          invariant: x <> y
                  justification: |
                    Explanations:
                      - Since `z` is only decremented and starts at `0`, invariant `z <= 0` clearly holds. It is also likely to be useful since it shows that the conditional statement within the loop body always executes.
                      - The post-condition `x <> y` is true initially. It is also preserved by the loop body since the conditional statement is always executed (and so both `x` and `y` are incremented at each iteration). Thus, proposing it as an invariant is reasonable.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: cond_guard
                          invariant: z <= 0
                  justification: |
                    Explanations:
                    - From the shown obligation, Why3 cannot prove that `x <> y` is preserved by the loop body. However, this is true since the conditional statement is always executed, and thus both `x` and `y` are incremented at each iteration. In turn, the conditional statement is always executed since `z` starts at `0` and is only decremented. This suggests adding `z <= 0` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = any int in  (* premise *)
                    assume { x < 5 };  (* premise *)
                    assume { x >= 2 };  (* premise *)
                    assume { y <= 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 2;
                      y <- y - 3;
                    done;
                    assert { y <= 14 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: linear
                          invariant: 3*x - 2*y >= 6
                        - trick: relax_loop_guard
                          invariant: x < 12
                  justification: |
                    Explanations:
                      - Since `y` is decremented by 3 every time `x` in incremented by `2`, the quantity `3*x - 2*y` is constant throughout the program. Since it at least `3*2 - 2*0 = 6` initially, the inequality "3*x - 2*y >= 6" is an invariant.
                      - `x` is only incremented by `2` at each loop iteration. Thus, given the loop guard `x < 10`, we have `x < 12` at the end of any loop iteration. `x < 12` also holds initially because of assumption `x < 5` so we propose `x < 12` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* premise *)
                    let ref x = 0 in
                    let ref g = any int in
                    while x < n do  (* premise *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then  (* premise *)
                      assert { g >= 1 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: abduct_post
                          invariant: n > 0 -> x >= n -> g >= 1
                  justification: |
                    Explanations:
                      - We want to add an invariant that implies the final assertion `g >= 1`, assuming `n > 0` (the guard around the assertion) and `x >= n` (the negation of the loop guard). Suggesting `g >= 1` does not work since `g >= 1` does not hold initially. We propose trying the whole obligation itself as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in
                    let ref x = 0 in
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: true_or_continue
                          invariant: g >= 1 || x < n
                  justification: |
                    Explanations:
                      - The user tried to prove `g >= 1` as an invariant but it does not hold initially. Still, it always hold after an iteration of the loop since the loop body sets `g` to 4. Thus, I am proposing to try invariant `g >= 1 || x < n` instead.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* GOAL *)
                    let ref x = 0 in  (* GOAL *)
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 || x < n }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: guard_inv
                          invariant: n > 0 -> (g >= 1 || x < n)
                  justification: |-
                    Explanations:
                      - The user tried to prove `g >= 1 || x < n` as an invariant but it does not hold initially. Indeed, no assumption about `n` is known initially. However, a useful assumption `n > 0` is made after the loop. Thus, I propose guarding the current candidate with it and suggesting `n > 0 -> (g >= 1 || x < n)` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let main () diverges =  (* GOAL *)
                    let ref x = any int in
                    let ref y = any int in
                    x <- 1;
                    y <- 0;
                    while y < 100000 do  (* premise *)
                      x <- x + y;
                      y <- y + 1
                    done;
                    assert { x >= y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for main (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
            options:
              temperature: 1.5
            num_completions: 4
            structured_output:
              name: InvariantSuggestions
              description: |-
                A sequence of suggestions, each of which consists in a trick name
                along with an invariant proposal.
              schema:
                $defs:
                  InvariantSuggestion:
                    properties:
                      trick:
                        title: Trick
                        type: string
                      invariant:
                        title: Invariant
                        type: string
                    required:
                      - trick
                      - invariant
                    title: InvariantSuggestion
                    type: object
                properties:
                  suggestions:
                    items:
                      $ref: '#/$defs/InvariantSuggestion'
                    title: Suggestions
                    type: array
                required:
                  - suggestions
                title: InvariantSuggestions
                type: object
      - message: llm_response
        level: info
        message_id: 35
        related:
          - 34
        time: 2025-11-05 19:23:49.390439
        space: 4
        metadata:
          response:
            outputs:
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x - y*(y-1)/2 >= 1
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: propose_post
                        invariant: x >= y
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= 1
                      - trick: monotone
                        invariant: y <= 100000
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: true_or_continue
                        invariant: x >= y || y < 100000
                      - trick: linear
                        invariant: x >= 0
                tool_calls: []
            budget:
              values:
                num_requests: 1
                num_completions: 4
                input_tokens: 3273
                output_tokens: 197
                cached_input_tokens: 3200
                price: 0.0006643999999999999
            log_items: []
            model_name: gpt-4.1-mini-2025-04-14
            usage_info:
              completion_tokens: 197
              prompt_tokens: 3273
              total_tokens: 3470
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 3200
          usage:
            model: gpt-4.1-mini-2025-04-14
            usage:
              completion_tokens: 197
              prompt_tokens: 3273
              total_tokens: 3470
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 3200
      - message: 'Suggestions: [''x - y*(y-1)/2 >= 1'', ''x >= y'', ''x >= 1'', ''y <= 100000'', ''x >=
          y || y < 100000'', ''x >= 0'']'
        level: info
        message_id: 36
        time: 2025-11-05 19:23:49.402248
        metadata:
          facts_stats:
            num_candidates: 1
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Disproved: x - y*(y-1)/2 >= 1'
        level: info
        message_id: 37
        time: 2025-11-05 19:23:49.409253
        metadata:
          facts_stats:
            num_candidates: 1
            num_proved: 0
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Proved: y <= 100000'
        level: info
        message_id: 38
        time: 2025-11-05 19:23:49.599995
        metadata:
          facts_stats:
            num_candidates: 3
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: Propagating...
        level: info
        message_id: 39
        time: 2025-11-05 19:23:49.744402
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Filtered: {''x >= y'': 1, ''x >= 1'': 1, ''x >= y || y < 100000'': 1, ''x >= 0'': 1}'
        level: info
        message_id: 40
        time: 2025-11-05 19:23:50.064957
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Explore fact: x >= y'
        level: info
        message_id: 41
        time: 2025-11-05 19:23:50.064979
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: llm_request
        level: info
        message_id: 42
        time: 2025-11-05 19:23:50.071334
        space: 112
        metadata:
          query: SuggestInvariants
          request:
            chat:
              - role: system
                content: |-
                  Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                  We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`. I insist, and this is **VERY IMPORTANT**, you must **NOT** propose invariants involving complex arithmetic such as `2 * x >= y * (y + 1)`.

                  I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest a list of new invariant candidates that may unlock the proof.

                  In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`). The name of the failing proof obligation also provides a hint about the nature of the problem, which is either:

                  - `assertion`: the final assertion is not implied by the invariants
                  - `loop invariant init`: an invariant does not hold initially
                  - `loop invariant preservation`: an invariant cannot be proved to be preserved by the loop body (it may not be preserved or an additional invariant may be needed to complete the proof)

                  Please suggest new invariant candidates. Each invariant candidate must be obtained by following one of the _tricks_ discussed below. A trick can be used multiple times. Do not suggest candidates that are already established invariants.

                  Answer as a JSON object representing a list of `(trick_name, suggested_invariant)` pairs and **nothing else**.

                  Examples are provided that include additional explanations for clarity. Do not include such explanations in your answer.


                  ## Notes on Why3

                  - The `any T` construct generates an arbitrary object of type `T`. In particular, a loop whose guard is `any bool` can run for an arbitrary number of times.


                  ## Tricks

                  Each trick is identified by a unique name. For each trick, we discuss *when* it is applicable and *what* the corresponding recipe is.

                  ### propose_post

                  If the final assertion fails to prove but appears to hold through the whole program, propose it as an invariant.

                  ### monotone

                  Whenever a variable `x` is only incremented (resp. decremented), propose invariant `x >= c` (resp. `x <= c`) for `c` some numerical constant.

                  ### linear

                  Whenever a linear equality or inequality between variables appears to hold throughout the program (e.g. `x - y >= 0`, `3*x + 2*y = 1`...), consider proposing it as an invariant.

                  ### abduct_post

                  If the final assertion fails to prove, look for a missing assumption that implies it when assuming all established invariants (along with the negation of the loop guard). Propose this assumption as a new invariant candidate.

                  ### abduct_inv

                  If an invariant cannot be proved to be preserved, look for a missing assumption and propose it as a new invariant.

                  ### strengthen_inv

                  If an invariant cannot be proved to be preserved, consider making it stronger (e.g proposing `x < y` as a replacement for `x <> y`).

                  ### guard_inv

                  If proving an invariant `inv` requires assuming a global assumption `assum` that is only made _after_ the loop, consider proposing `assum -> inv` as an invariant instead.

                  ### true_or_continue

                  If a property `P` always holds after the loop but cannot be proved as an invariant because `P` does not hold initially, consider proposing `P || loop_guard` as an invariant instead.

                  ### cond_guard

                  If proving the preservation of an invariant candidate requires proving that a specific branch in the code cannot be taken (or is always taken), consider proposing an invariant that establishes this fact.

                  ### relax_loop_guard

                  Suppose the loop guard is an inequality such as `expr < c` with `expr` an expression and `c` a constant. Then, if quantity `expr` cannot increase more than a constant amount `d` at each iteration, consider proposing `expr < c + d` as an invariant (and similarly for <=, > and >=).
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: clearly_true
                          invariant: z <= 0
                        - trick: propose_post
                          invariant: x <> y
                  justification: |
                    Explanations:
                      - Since `z` is only decremented and starts at `0`, invariant `z <= 0` clearly holds. It is also likely to be useful since it shows that the conditional statement within the loop body always executes.
                      - The post-condition `x <> y` is true initially. It is also preserved by the loop body since the conditional statement is always executed (and so both `x` and `y` are incremented at each iteration). Thus, proposing it as an invariant is reasonable.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: cond_guard
                          invariant: z <= 0
                  justification: |
                    Explanations:
                    - From the shown obligation, Why3 cannot prove that `x <> y` is preserved by the loop body. However, this is true since the conditional statement is always executed, and thus both `x` and `y` are incremented at each iteration. In turn, the conditional statement is always executed since `z` starts at `0` and is only decremented. This suggests adding `z <= 0` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = any int in  (* premise *)
                    assume { x < 5 };  (* premise *)
                    assume { x >= 2 };  (* premise *)
                    assume { y <= 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 2;
                      y <- y - 3;
                    done;
                    assert { y <= 14 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: linear
                          invariant: 3*x - 2*y >= 6
                        - trick: relax_loop_guard
                          invariant: x < 12
                  justification: |
                    Explanations:
                      - Since `y` is decremented by 3 every time `x` in incremented by `2`, the quantity `3*x - 2*y` is constant throughout the program. Since it at least `3*2 - 2*0 = 6` initially, the inequality "3*x - 2*y >= 6" is an invariant.
                      - `x` is only incremented by `2` at each loop iteration. Thus, given the loop guard `x < 10`, we have `x < 12` at the end of any loop iteration. `x < 12` also holds initially because of assumption `x < 5` so we propose `x < 12` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* premise *)
                    let ref x = 0 in
                    let ref g = any int in
                    while x < n do  (* premise *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then  (* premise *)
                      assert { g >= 1 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: abduct_post
                          invariant: n > 0 -> x >= n -> g >= 1
                  justification: |
                    Explanations:
                      - We want to add an invariant that implies the final assertion `g >= 1`, assuming `n > 0` (the guard around the assertion) and `x >= n` (the negation of the loop guard). Suggesting `g >= 1` does not work since `g >= 1` does not hold initially. We propose trying the whole obligation itself as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in
                    let ref x = 0 in
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: true_or_continue
                          invariant: g >= 1 || x < n
                  justification: |
                    Explanations:
                      - The user tried to prove `g >= 1` as an invariant but it does not hold initially. Still, it always hold after an iteration of the loop since the loop body sets `g` to 4. Thus, I am proposing to try invariant `g >= 1 || x < n` instead.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* GOAL *)
                    let ref x = 0 in  (* GOAL *)
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 || x < n }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: guard_inv
                          invariant: n > 0 -> (g >= 1 || x < n)
                  justification: |-
                    Explanations:
                      - The user tried to prove `g >= 1 || x < n` as an invariant but it does not hold initially. Indeed, no assumption about `n` is known initially. However, a useful assumption `n > 0` is made after the loop. Thus, I propose guarding the current candidate with it and suggesting `n > 0 -> (g >= 1 || x < n)` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let main () diverges =  (* GOAL *)
                    let ref x = any int in
                    let ref y = any int in
                    x <- 1;  (* premise *)
                    y <- 0;  (* premise *)
                    while y < 100000 do  (* premise *)
                      invariant { y <= 100000 }  (* premise *)
                      invariant { x >= y }  (* GOAL, premise *)
                      x <- x + y;  (* premise *)
                      y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for main (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
            options:
              temperature: 1.5
            num_completions: 4
            structured_output:
              name: InvariantSuggestions
              description: |-
                A sequence of suggestions, each of which consists in a trick name
                along with an invariant proposal.
              schema:
                $defs:
                  InvariantSuggestion:
                    properties:
                      trick:
                        title: Trick
                        type: string
                      invariant:
                        title: Invariant
                        type: string
                    required:
                      - trick
                      - invariant
                    title: InvariantSuggestion
                    type: object
                properties:
                  suggestions:
                    items:
                      $ref: '#/$defs/InvariantSuggestion'
                    title: Suggestions
                    type: array
                required:
                  - suggestions
                title: InvariantSuggestions
                type: object
      - message: llm_response
        level: info
        message_id: 43
        related:
          - 42
        time: 2025-11-05 19:23:51.828841
        space: 112
        metadata:
          response:
            outputs:
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= 0
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= 0
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: monotone
                        invariant: x >= 0
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= 0
                      - trick: linear
                        invariant: x >= y*(y-1)/2
                tool_calls: []
            budget:
              values:
                num_requests: 1
                num_completions: 4
                input_tokens: 3309
                output_tokens: 148
                cached_input_tokens: 0
                price: 0.0015603999999999998
            log_items: []
            model_name: gpt-4.1-mini-2025-04-14
            usage_info:
              completion_tokens: 148
              prompt_tokens: 3309
              total_tokens: 3457
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 0
          usage:
            model: gpt-4.1-mini-2025-04-14
            usage:
              completion_tokens: 148
              prompt_tokens: 3309
              total_tokens: 3457
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 0
      - message: 'Suggestions: [''x >= 0'', ''x >= 0'', ''x >= 0'', ''x >= 0'', ''x >= y*(y-1)/2'']'
        level: info
        message_id: 44
        time: 2025-11-05 19:23:51.840463
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Disproved: x >= y*(y-1)/2'
        level: info
        message_id: 45
        time: 2025-11-05 19:23:51.852662
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Filtered: {''x >= 0'': 4}'
        level: info
        message_id: 46
        time: 2025-11-05 19:23:51.852678
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Explore fact: x >= 0'
        level: info
        message_id: 47
        time: 2025-11-05 19:23:51.852696
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: llm_request
        level: info
        message_id: 48
        time: 2025-11-05 19:23:51.863634
        space: 120
        metadata:
          query: SuggestInvariants
          request:
            chat:
              - role: system
                content: |-
                  Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                  We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`. I insist, and this is **VERY IMPORTANT**, you must **NOT** propose invariants involving complex arithmetic such as `2 * x >= y * (y + 1)`.

                  I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest a list of new invariant candidates that may unlock the proof.

                  In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`). The name of the failing proof obligation also provides a hint about the nature of the problem, which is either:

                  - `assertion`: the final assertion is not implied by the invariants
                  - `loop invariant init`: an invariant does not hold initially
                  - `loop invariant preservation`: an invariant cannot be proved to be preserved by the loop body (it may not be preserved or an additional invariant may be needed to complete the proof)

                  Please suggest new invariant candidates. Each invariant candidate must be obtained by following one of the _tricks_ discussed below. A trick can be used multiple times. Do not suggest candidates that are already established invariants.

                  Answer as a JSON object representing a list of `(trick_name, suggested_invariant)` pairs and **nothing else**.

                  Examples are provided that include additional explanations for clarity. Do not include such explanations in your answer.


                  ## Notes on Why3

                  - The `any T` construct generates an arbitrary object of type `T`. In particular, a loop whose guard is `any bool` can run for an arbitrary number of times.


                  ## Tricks

                  Each trick is identified by a unique name. For each trick, we discuss *when* it is applicable and *what* the corresponding recipe is.

                  ### propose_post

                  If the final assertion fails to prove but appears to hold through the whole program, propose it as an invariant.

                  ### monotone

                  Whenever a variable `x` is only incremented (resp. decremented), propose invariant `x >= c` (resp. `x <= c`) for `c` some numerical constant.

                  ### linear

                  Whenever a linear equality or inequality between variables appears to hold throughout the program (e.g. `x - y >= 0`, `3*x + 2*y = 1`...), consider proposing it as an invariant.

                  ### abduct_post

                  If the final assertion fails to prove, look for a missing assumption that implies it when assuming all established invariants (along with the negation of the loop guard). Propose this assumption as a new invariant candidate.

                  ### abduct_inv

                  If an invariant cannot be proved to be preserved, look for a missing assumption and propose it as a new invariant.

                  ### strengthen_inv

                  If an invariant cannot be proved to be preserved, consider making it stronger (e.g proposing `x < y` as a replacement for `x <> y`).

                  ### guard_inv

                  If proving an invariant `inv` requires assuming a global assumption `assum` that is only made _after_ the loop, consider proposing `assum -> inv` as an invariant instead.

                  ### true_or_continue

                  If a property `P` always holds after the loop but cannot be proved as an invariant because `P` does not hold initially, consider proposing `P || loop_guard` as an invariant instead.

                  ### cond_guard

                  If proving the preservation of an invariant candidate requires proving that a specific branch in the code cannot be taken (or is always taken), consider proposing an invariant that establishes this fact.

                  ### relax_loop_guard

                  Suppose the loop guard is an inequality such as `expr < c` with `expr` an expression and `c` a constant. Then, if quantity `expr` cannot increase more than a constant amount `d` at each iteration, consider proposing `expr < c + d` as an invariant (and similarly for <=, > and >=).
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 1;
                      z <- z - 1;
                      if z < 0 then y <- y + 1
                    done;
                    assert { x <> y }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: clearly_true
                          invariant: z <= 0
                        - trick: propose_post
                          invariant: x <> y
                  justification: |
                    Explanations:
                      - Since `z` is only decremented and starts at `0`, invariant `z <= 0` clearly holds. It is also likely to be useful since it shows that the conditional statement within the loop body always executes.
                      - The post-condition `x <> y` is true initially. It is also preserved by the loop body since the conditional statement is always executed (and so both `x` and `y` are incremented at each iteration). Thus, proposing it as an invariant is reasonable.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = 3 in
                    let ref z = 0 in
                    assume { x < 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      invariant { x <> y }  (* GOAL, premise *)
                      x <- x + 1;  (* premise *)
                      z <- z - 1;  (* premise *)
                      if z < 0 then y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: cond_guard
                          invariant: z <= 0
                  justification: |
                    Explanations:
                    - From the shown obligation, Why3 cannot prove that `x <> y` is preserved by the loop body. However, this is true since the conditional statement is always executed, and thus both `x` and `y` are incremented at each iteration. In turn, the conditional statement is always executed since `z` starts at `0` and is only decremented. This suggests adding `z <= 0` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref x = any int in  (* premise *)
                    let ref y = any int in  (* premise *)
                    assume { x < 5 };  (* premise *)
                    assume { x >= 2 };  (* premise *)
                    assume { y <= 0 };  (* premise *)
                    while x < 10 do  (* premise *)
                      x <- x + 2;
                      y <- y - 3;
                    done;
                    assert { y <= 14 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: linear
                          invariant: 3*x - 2*y >= 6
                        - trick: relax_loop_guard
                          invariant: x < 12
                  justification: |
                    Explanations:
                      - Since `y` is decremented by 3 every time `x` in incremented by `2`, the quantity `3*x - 2*y` is constant throughout the program. Since it at least `3*2 - 2*0 = 6` initially, the inequality "3*x - 2*y >= 6" is an invariant.
                      - `x` is only incremented by `2` at each loop iteration. Thus, given the loop guard `x < 10`, we have `x < 12` at the end of any loop iteration. `x < 12` also holds initially because of assumption `x < 5` so we propose `x < 12` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* premise *)
                    let ref x = 0 in
                    let ref g = any int in
                    while x < n do  (* premise *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then  (* premise *)
                      assert { g >= 1 }  (* GOAL *)
                  ```

                  The name of the proof obligation that failed is: `VC for example (assertion)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: abduct_post
                          invariant: n > 0 -> x >= n -> g >= 1
                  justification: |
                    Explanations:
                      - We want to add an invariant that implies the final assertion `g >= 1`, assuming `n > 0` (the guard around the assertion) and `x >= n` (the negation of the loop guard). Suggesting `g >= 1` does not work since `g >= 1` does not hold initially. We propose trying the whole obligation itself as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in
                    let ref x = 0 in
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: true_or_continue
                          invariant: g >= 1 || x < n
                  justification: |
                    Explanations:
                      - The user tried to prove `g >= 1` as an invariant but it does not hold initially. Still, it always hold after an iteration of the loop since the loop body sets `g` to 4. Thus, I am proposing to try invariant `g >= 1 || x < n` instead.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let example () diverges =  (* GOAL *)
                    let ref n = any int in  (* GOAL *)
                    let ref x = 0 in  (* GOAL *)
                    let ref g = any int in  (* GOAL *)
                    while x < n do
                      invariant { g >= 1 || x < n }  (* GOAL *)
                      g <- 4;
                      x <- x + 1;
                    done;
                    if n > 0 then
                      assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for example (loop invariant init)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
              - role: assistant
                answer:
                  mode: null
                  content:
                    structured:
                      suggestions:
                        - trick: guard_inv
                          invariant: n > 0 -> (g >= 1 || x < n)
                  justification: |-
                    Explanations:
                      - The user tried to prove `g >= 1 || x < n` as an invariant but it does not hold initially. Indeed, no assumption about `n` is known initially. However, a useful assumption `n > 0` is made after the loop. Thus, I propose guarding the current candidate with it and suggesting `n > 0 -> (g >= 1 || x < n)` as an invariant.
              - role: user
                content: |-
                  Here is the program that Why3 was tasked to verify.

                  ```mlw
                  use int.Int

                  let main () diverges =  (* GOAL *)
                    let ref x = any int in
                    let ref y = any int in
                    x <- 1;  (* premise *)
                    y <- 0;  (* premise *)
                    while y < 100000 do  (* premise *)
                      invariant { y <= 100000 }  (* premise *)
                      invariant { x >= 0 }  (* GOAL, premise *)
                      x <- x + y;  (* premise *)
                      y <- y + 1  (* premise *)
                    done;
                    assert { true }
                  ```

                  The name of the proof obligation that failed is: `VC for main (loop invariant preservation)`.

                  Can you fix this by suggesting new invariant candidates?

                  Just answer with a JSON object denoting a list of `(trick_name, invariant_candidate)` pairs and nothing else.
            options:
              temperature: 1.5
            num_completions: 4
            structured_output:
              name: InvariantSuggestions
              description: |-
                A sequence of suggestions, each of which consists in a trick name
                along with an invariant proposal.
              schema:
                $defs:
                  InvariantSuggestion:
                    properties:
                      trick:
                        title: Trick
                        type: string
                      invariant:
                        title: Invariant
                        type: string
                    required:
                      - trick
                      - invariant
                    title: InvariantSuggestion
                    type: object
                properties:
                  suggestions:
                    items:
                      $ref: '#/$defs/InvariantSuggestion'
                    title: Suggestions
                    type: array
                required:
                  - suggestions
                title: InvariantSuggestions
                type: object
      - message: llm_response
        level: info
        message_id: 49
        related:
          - 48
        time: 2025-11-05 19:23:54.143806
        space: 120
        metadata:
          response:
            outputs:
              - content:
                  structured:
                    suggestions:
                      - trick: monotone
                        invariant: y >= 0
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= y
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: linear
                        invariant: x >= (y * (y - 1)) / 2
                      - trick: linear
                        invariant: x >= 0
                tool_calls: []
              - content:
                  structured:
                    suggestions:
                      - trick: monotone
                        invariant: y >= 0
                tool_calls: []
            budget:
              values:
                num_requests: 1
                num_completions: 4
                input_tokens: 3310
                output_tokens: 168
                cached_input_tokens: 3072
                price: 0.0006711999999999999
            log_items: []
            model_name: gpt-4.1-mini-2025-04-14
            usage_info:
              completion_tokens: 168
              prompt_tokens: 3310
              total_tokens: 3478
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 3072
          usage:
            model: gpt-4.1-mini-2025-04-14
            usage:
              completion_tokens: 168
              prompt_tokens: 3310
              total_tokens: 3478
              completion_tokens_details:
                accepted_prediction_tokens: 0
                audio_tokens: 0
                reasoning_tokens: 0
                rejected_prediction_tokens: 0
              prompt_tokens_details:
                audio_tokens: 0
                cached_tokens: 3072
      - message: 'Suggestions: [''y >= 0'', ''x >= y'', ''x >= (y * (y - 1)) / 2'', ''x >= 0'', ''y >=
          0'']'
        level: info
        message_id: 50
        time: 2025-11-05 19:23:54.151723
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 1
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Proved: y >= 0'
        level: info
        message_id: 51
        time: 2025-11-05 19:23:54.476404
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 2
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Disproved: x >= (y * (y - 1)) / 2'
        level: info
        message_id: 52
        time: 2025-11-05 19:23:54.480888
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 2
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: Propagating...
        level: info
        message_id: 53
        time: 2025-11-05 19:23:54.480898
        metadata:
          facts_stats:
            num_candidates: 5
            num_proved: 2
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Proved: x >= 1'
        level: info
        message_id: 54
        time: 2025-11-05 19:23:54.737072
        metadata:
          facts_stats:
            num_candidates: 2
            num_proved: 3
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Proved: x >= y || y < 100000'
        level: info
        message_id: 55
        time: 2025-11-05 19:23:54.857407
        metadata:
          facts_stats:
            num_candidates: 2
            num_proved: 4
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Redundant: x >= 0'
        level: info
        message_id: 56
        time: 2025-11-05 19:23:54.869930
        metadata:
          facts_stats:
            num_candidates: 2
            num_proved: 4
            num_disproved: 0
            num_redundant: 0
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: Propagating...
        level: info
        message_id: 57
        time: 2025-11-05 19:23:54.869942
        metadata:
          facts_stats:
            num_candidates: 2
            num_proved: 4
            num_disproved: 0
            num_redundant: 1
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: 'Proved: None'
        level: info
        message_id: 58
        time: 2025-11-05 19:23:54.977618
        metadata:
          facts_stats:
            num_candidates: 0
            num_proved: 5
            num_disproved: 0
            num_redundant: 1
          call_stats:
            prove_calls: 20
            prove_time_in_seconds: 1.064941167831421
            is_redundant_calls: 17
            is_redundant_time_in_seconds: 0.19060754776000977
            search_equivalent_calls: 4
            search_equivalent_time_in_seconds: 0.25864386558532715
      - message: abduct_and_saturate_call_stats
        level: info
        message_id: 59
        time: 2025-11-05 19:23:54.977634
        metadata:
          prove_calls: 20
          prove_time_in_seconds: 1.064941167831421
          is_redundant_calls: 17
          is_redundant_time_in_seconds: 0.19060754776000977
          search_equivalent_calls: 4
          search_equivalent_time_in_seconds: 0.25864386558532715
    browsable_trace:
      nodes:
        1:
          kind: Abduction
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: prove([], nil)
                with_hints: null
              - 1
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                tags:
                  - _prove_goal
                node_id: 2
            - - with_ids: suggest($1{%3}[1])
                with_hints: null
              - 3
              - kind: nested
                strategy: _suggest_invariants
                args:
                  unproved:
                    short: '[Obligation(name=''VC for main (assertion)'', proved=False, relevance_hints=''use
                      int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref
                      y = any int in\n  x <- 1;\n  y <- 0;\n  while y < 100000 do  (* premise *)\n    x
                      <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }  (* GOAL *)'', goal_formula=''x
                      >= y'')]'
                    long: |-
                      [Obligation(name='VC for main (assertion)',
                                  proved=False,
                                  relevance_hints='use int.Int\n'
                                                  '\n'
                                                  'let main () diverges =  (* GOAL *)\n'
                                                  '  let ref x = any int in\n'
                                                  '  let ref y = any int in\n'
                                                  '  x <- 1;\n'
                                                  '  y <- 0;\n'
                                                  '  while y < 100000 do  (* premise *)\n'
                                                  '    x <- x + y;\n'
                                                  '    y <- y + 1\n'
                                                  '  done;\n'
                                                  '  assert { x >= y }  (* GOAL *)',
                                  goal_formula='x >= y')]
                    json_provided: true
                    json:
                      - name: VC for main (assertion)
                        proved: false
                        relevance_hints: |-
                          use int.Int

                          let main () diverges =  (* GOAL *)
                            let ref x = any int in
                            let ref y = any int in
                            x <- 1;
                            y <- 0;
                            while y < 100000 do  (* premise *)
                              x <- x + y;
                              y <- y + 1
                            done;
                            assert { x >= y }  (* GOAL *)
                        goal_formula: x >= y
                tags:
                  - _suggest_invariants
                node_id: 4
            - - with_ids: redundant([], $3{%5}[0])
                with_hints: null
              - 5
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: x >= y
                    long: '''x >= y'''
                    json_provided: true
                    json: x >= y
                tags:
                  - _is_redundant
                node_id: 8
            - - with_ids: prove([], $3{%5}[0])
                with_hints: null
              - 7
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: x >= y
                    long: '''x >= y'''
                    json_provided: true
                    json: x >= y
                tags:
                  - _prove_goal
                node_id: 10
            - - with_ids: redundant([], $3{%5}[1])
                with_hints: null
              - 9
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: x - y >= 0
                    long: '''x - y >= 0'''
                    json_provided: true
                    json: x - y >= 0
                tags:
                  - _is_redundant
                node_id: 12
            - - with_ids: prove([], $3{%5}[1])
                with_hints: null
              - 11
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: x - y >= 0
                    long: '''x - y >= 0'''
                    json_provided: true
                    json: x - y >= 0
                tags:
                  - _prove_goal
                node_id: 14
            - - with_ids: suggest($7{%11}[1])
                with_hints: null
              - 13
              - kind: nested
                strategy: _suggest_invariants
                args:
                  unproved:
                    short: '[Obligation(name=''VC for main (loop invariant preservation)'', proved=False,
                      relevance_hints=''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x
                      = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (*
                      premise *)\n  while y < 100000 do  (* premise *)\n    invariant { x >= y }  (* GOAL,
                      premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                      { true }'', goal_formula=''(x + y) >= (y + 1)'')]'
                    long: |-
                      [Obligation(name='VC for main (loop invariant preservation)',
                                  proved=False,
                                  relevance_hints='use int.Int\n'
                                                  '\n'
                                                  'let main () diverges =  (* GOAL *)\n'
                                                  '  let ref x = any int in\n'
                                                  '  let ref y = any int in\n'
                                                  '  x <- 1;  (* premise *)\n'
                                                  '  y <- 0;  (* premise *)\n'
                                                  '  while y < 100000 do  (* premise *)\n'
                                                  '    invariant { x >= y }  (* GOAL, premise *)\n'
                                                  '    x <- x + y;  (* premise *)\n'
                                                  '    y <- y + 1  (* premise *)\n'
                                                  '  done;\n'
                                                  '  assert { true }',
                                  goal_formula='(x + y) >= (y + 1)')]
                    json_provided: true
                    json:
                      - name: VC for main (loop invariant preservation)
                        proved: false
                        relevance_hints: |-
                          use int.Int

                          let main () diverges =  (* GOAL *)
                            let ref x = any int in
                            let ref y = any int in
                            x <- 1;  (* premise *)
                            y <- 0;  (* premise *)
                            while y < 100000 do  (* premise *)
                              invariant { x >= y }  (* GOAL, premise *)
                              x <- x + y;  (* premise *)
                              y <- y + 1  (* premise *)
                            done;
                            assert { true }
                        goal_formula: (x + y) >= (y + 1)
                tags:
                  - _suggest_invariants
                node_id: 16
            - - with_ids: search_equivalent([$3{%5}[0], $3{%5}[1]], $13{%22}[0])
                with_hints: null
              - 15
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x - y >= 0')
                    long: ('x >= y', 'x - y >= 0')
                    json_provided: true
                    json:
                      - x >= y
                      - x - y >= 0
                  fml:
                    short: x >= y provisions after the loop youth lose squ parlament gift oppon strata
                      nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime
                      personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt=
                    long: |-
                      ('x >= y provisions after the loop youth lose squ parlament gift oppon strata '
                       'nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 '
                       'régime personality,new clutch anzeigen时报 zwölf ondernemer oversees simple '
                       'pick yt=')
                    json_provided: true
                    json: x >= y provisions after the loop youth lose squ parlament gift oppon strata
                      nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime
                      personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt=
                tags:
                  - _search_equivalent
                node_id: 24
            - - with_ids: search_equivalent([$3{%5}[0], $3{%5}[1]], $13{%23}[0])
                with_hints: null
              - 17
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x - y >= 0')
                    long: ('x >= y', 'x - y >= 0')
                    json_provided: true
                    json:
                      - x >= y
                      - x - y >= 0
                  fml:
                    short: x >= y * (y - 1) / 2
                    long: '''x >= y * (y - 1) / 2'''
                    json_provided: true
                    json: x >= y * (y - 1) / 2
                tags:
                  - _search_equivalent
                node_id: 26
            - - with_ids: redundant([], $13{%22}[0])
                with_hints: null
              - 19
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: x >= y provisions after the loop youth lose squ parlament gift oppon strata
                      nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime
                      personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt=
                    long: |-
                      ('x >= y provisions after the loop youth lose squ parlament gift oppon strata '
                       'nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 '
                       'régime personality,new clutch anzeigen时报 zwölf ondernemer oversees simple '
                       'pick yt=')
                    json_provided: true
                    json: x >= y provisions after the loop youth lose squ parlament gift oppon strata
                      nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime
                      personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt=
                tags:
                  - _is_redundant
                node_id: 28
            - - with_ids: prove([], $13{%22}[0])
                with_hints: null
              - 21
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: x >= y provisions after the loop youth lose squ parlament gift oppon strata
                      nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime
                      personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt=
                    long: |-
                      ('x >= y provisions after the loop youth lose squ parlament gift oppon strata '
                       'nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 '
                       'régime personality,new clutch anzeigen时报 zwölf ondernemer oversees simple '
                       'pick yt=')
                    json_provided: true
                    json: x >= y provisions after the loop youth lose squ parlament gift oppon strata
                      nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime
                      personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt=
                tags:
                  - _prove_goal
                node_id: 30
            - - with_ids: redundant([], $13{%23}[0])
                with_hints: null
              - 23
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: x >= y * (y - 1) / 2
                    long: '''x >= y * (y - 1) / 2'''
                    json_provided: true
                    json: x >= y * (y - 1) / 2
                tags:
                  - _is_redundant
                node_id: 32
            - - with_ids: prove([], $13{%23}[0])
                with_hints: null
              - 25
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: x >= y * (y - 1) / 2
                    long: '''x >= y * (y - 1) / 2'''
                    json_provided: true
                    json: x >= y * (y - 1) / 2
                tags:
                  - _prove_goal
                node_id: 34
            - - with_ids: search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%36}[0])
                with_hints: null
              - 27
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x - y >= 0')
                    long: ('x >= y', 'x - y >= 0')
                    json_provided: true
                    json:
                      - x >= y
                      - x - y >= 0
                  fml:
                    short: x >= 0
                    long: '''x >= 0'''
                    json_provided: true
                    json: x >= 0
                tags:
                  - _search_equivalent
                node_id: 40
            - - with_ids: search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%36}[1])
                with_hints: null
              - 29
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x - y >= 0')
                    long: ('x >= y', 'x - y >= 0')
                    json_provided: true
                    json:
                      - x >= y
                      - x - y >= 0
                  fml:
                    short: x >= y*(y-1)/2 + y
                    long: '''x >= y*(y-1)/2 + y'''
                    json_provided: true
                    json: x >= y*(y-1)/2 + y
                tags:
                  - _search_equivalent
                node_id: 42
            - - with_ids: search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%37}[1])
                with_hints: null
              - 31
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x - y >= 0')
                    long: ('x >= y', 'x - y >= 0')
                    json_provided: true
                    json:
                      - x >= y
                      - x - y >= 0
                  fml:
                    short: y <= 100000
                    long: '''y <= 100000'''
                    json_provided: true
                    json: y <= 100000
                tags:
                  - _search_equivalent
                node_id: 44
            - - with_ids: search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%38}[1])
                with_hints: null
              - 33
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x - y >= 0')
                    long: ('x >= y', 'x - y >= 0')
                    json_provided: true
                    json:
                      - x >= y
                      - x - y >= 0
                  fml:
                    short: x >= y*(y - 1)/2
                    long: '''x >= y*(y - 1)/2'''
                    json_provided: true
                    json: x >= y*(y - 1)/2
                tags:
                  - _search_equivalent
                node_id: 46
            - - with_ids: search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%38}[2])
                with_hints: null
              - 35
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x - y >= 0')
                    long: ('x >= y', 'x - y >= 0')
                    json_provided: true
                    json:
                      - x >= y
                      - x - y >= 0
                  fml:
                    short: x >= (y - 1)*y/2
                    long: '''x >= (y - 1)*y/2'''
                    json_provided: true
                    json: x >= (y - 1)*y/2
                tags:
                  - _search_equivalent
                node_id: 48
            - - with_ids: search_equivalent([$3{%5}[0], $3{%5}[1]], $3{%39}[0])
                with_hints: null
              - 37
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x - y >= 0')
                    long: ('x >= y', 'x - y >= 0')
                    json_provided: true
                    json:
                      - x >= y
                      - x - y >= 0
                  fml:
                    short: x >= 0 && y >= 0
                    long: '''x >= 0 && y >= 0'''
                    json_provided: true
                    json: x >= 0 && y >= 0
                tags:
                  - _search_equivalent
                node_id: 50
            - - with_ids: redundant([], $3{%36}[0])
                with_hints: null
              - 39
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: x >= 0
                    long: '''x >= 0'''
                    json_provided: true
                    json: x >= 0
                tags:
                  - _is_redundant
                node_id: 52
            - - with_ids: prove([], $3{%36}[0])
                with_hints: null
              - 41
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: x >= 0
                    long: '''x >= 0'''
                    json_provided: true
                    json: x >= 0
                tags:
                  - _prove_goal
                node_id: 54
            - - with_ids: redundant([], $3{%36}[1])
                with_hints: null
              - 43
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: x >= y*(y-1)/2 + y
                    long: '''x >= y*(y-1)/2 + y'''
                    json_provided: true
                    json: x >= y*(y-1)/2 + y
                tags:
                  - _is_redundant
                node_id: 56
            - - with_ids: prove([], $3{%36}[1])
                with_hints: null
              - 45
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: x >= y*(y-1)/2 + y
                    long: '''x >= y*(y-1)/2 + y'''
                    json_provided: true
                    json: x >= y*(y-1)/2 + y
                tags:
                  - _prove_goal
                node_id: 58
            - - with_ids: redundant([], $3{%37}[1])
                with_hints: null
              - 47
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: y <= 100000
                    long: '''y <= 100000'''
                    json_provided: true
                    json: y <= 100000
                tags:
                  - _is_redundant
                node_id: 60
            - - with_ids: prove([], $3{%37}[1])
                with_hints: null
              - 49
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: y <= 100000
                    long: '''y <= 100000'''
                    json_provided: true
                    json: y <= 100000
                tags:
                  - _prove_goal
                node_id: 62
            - - with_ids: redundant([$3{%37}[1]], $3{%38}[1])
                with_hints: null
              - 51
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000',)
                    long: ('y <= 100000',)
                    json_provided: true
                    json:
                      - y <= 100000
                  fml:
                    short: x >= y*(y - 1)/2
                    long: '''x >= y*(y - 1)/2'''
                    json_provided: true
                    json: x >= y*(y - 1)/2
                tags:
                  - _is_redundant
                node_id: 64
            - - with_ids: prove([[$3{%37}[1], $49{%63}[1]]], $3{%38}[1])
                with_hints: null
              - 53
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []),)
                    long: (('y <= 100000', []),)
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                  goal:
                    short: x >= y*(y - 1)/2
                    long: '''x >= y*(y - 1)/2'''
                    json_provided: true
                    json: x >= y*(y - 1)/2
                tags:
                  - _prove_goal
                node_id: 66
            - - with_ids: redundant([$3{%37}[1]], $3{%38}[2])
                with_hints: null
              - 55
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000',)
                    long: ('y <= 100000',)
                    json_provided: true
                    json:
                      - y <= 100000
                  fml:
                    short: x >= (y - 1)*y/2
                    long: '''x >= (y - 1)*y/2'''
                    json_provided: true
                    json: x >= (y - 1)*y/2
                tags:
                  - _is_redundant
                node_id: 68
            - - with_ids: prove([[$3{%37}[1], $49{%63}[1]]], $3{%38}[2])
                with_hints: null
              - 57
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []),)
                    long: (('y <= 100000', []),)
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                  goal:
                    short: x >= (y - 1)*y/2
                    long: '''x >= (y - 1)*y/2'''
                    json_provided: true
                    json: x >= (y - 1)*y/2
                tags:
                  - _prove_goal
                node_id: 70
            - - with_ids: redundant([$3{%37}[1]], $3{%39}[0])
                with_hints: null
              - 59
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000',)
                    long: ('y <= 100000',)
                    json_provided: true
                    json:
                      - y <= 100000
                  fml:
                    short: x >= 0 && y >= 0
                    long: '''x >= 0 && y >= 0'''
                    json_provided: true
                    json: x >= 0 && y >= 0
                tags:
                  - _is_redundant
                node_id: 72
            - - with_ids: prove([[$3{%37}[1], $49{%63}[1]]], $3{%39}[0])
                with_hints: null
              - 61
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []),)
                    long: (('y <= 100000', []),)
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                  goal:
                    short: x >= 0 && y >= 0
                    long: '''x >= 0 && y >= 0'''
                    json_provided: true
                    json: x >= 0 && y >= 0
                tags:
                  - _prove_goal
                node_id: 74
            - - with_ids: prove([[$3{%37}[1], $49{%63}[1]], [$3{%39}[0], $61{%75}[1]]], nil)
                with_hints: null
              - 63
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []), ('x >= 0 && y >= 0', ['y <= 100000']))
                    long: (('y <= 100000', []), ('x >= 0 && y >= 0', ['y <= 100000']))
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                      - - x >= 0 && y >= 0
                        - - y <= 100000
                  goal:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                tags:
                  - _prove_goal
                node_id: 76
            - - with_ids: redundant([$3{%37}[1], $3{%39}[0]], $3{%5}[0])
                with_hints: null
              - 65
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000', 'x >= 0 && y >= 0')
                    long: ('y <= 100000', 'x >= 0 && y >= 0')
                    json_provided: true
                    json:
                      - y <= 100000
                      - x >= 0 && y >= 0
                  fml:
                    short: x >= y
                    long: '''x >= y'''
                    json_provided: true
                    json: x >= y
                tags:
                  - _is_redundant
                node_id: 78
            - - with_ids: prove([[$3{%37}[1], $49{%63}[1]], [$3{%39}[0], $61{%75}[1]]], $3{%5}[0])
                with_hints: null
              - 67
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []), ('x >= 0 && y >= 0', ['y <= 100000']))
                    long: (('y <= 100000', []), ('x >= 0 && y >= 0', ['y <= 100000']))
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                      - - x >= 0 && y >= 0
                        - - y <= 100000
                  goal:
                    short: x >= y
                    long: '''x >= y'''
                    json_provided: true
                    json: x >= y
                tags:
                  - _prove_goal
                node_id: 80
            - - with_ids: redundant([$3{%37}[1], $3{%39}[0]], $3{%5}[1])
                with_hints: null
              - 69
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000', 'x >= 0 && y >= 0')
                    long: ('y <= 100000', 'x >= 0 && y >= 0')
                    json_provided: true
                    json:
                      - y <= 100000
                      - x >= 0 && y >= 0
                  fml:
                    short: x - y >= 0
                    long: '''x - y >= 0'''
                    json_provided: true
                    json: x - y >= 0
                tags:
                  - _is_redundant
                node_id: 82
            - - with_ids: prove([[$3{%37}[1], $49{%63}[1]], [$3{%39}[0], $61{%75}[1]]], $3{%5}[1])
                with_hints: null
              - 71
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []), ('x >= 0 && y >= 0', ['y <= 100000']))
                    long: (('y <= 100000', []), ('x >= 0 && y >= 0', ['y <= 100000']))
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                      - - x >= 0 && y >= 0
                        - - y <= 100000
                  goal:
                    short: x - y >= 0
                    long: '''x - y >= 0'''
                    json_provided: true
                    json: x - y >= 0
                tags:
                  - _prove_goal
                node_id: 84
            - - with_ids: redundant([$3{%37}[1], $3{%39}[0]], $3{%36}[0])
                with_hints: null
              - 73
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000', 'x >= 0 && y >= 0')
                    long: ('y <= 100000', 'x >= 0 && y >= 0')
                    json_provided: true
                    json:
                      - y <= 100000
                      - x >= 0 && y >= 0
                  fml:
                    short: x >= 0
                    long: '''x >= 0'''
                    json_provided: true
                    json: x >= 0
                tags:
                  - _is_redundant
                node_id: 86
            - - with_ids: suggest($67{%81}[1])
                with_hints: null
              - 75
              - kind: nested
                strategy: _suggest_invariants
                args:
                  unproved:
                    short: '[Obligation(name=''VC for main (loop invariant preservation)'', proved=False,
                      relevance_hints=''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x
                      = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (*
                      premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (*
                      premise *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    invariant { x
                      >= y }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (*
                      premise *)\n  done;\n  assert { true }'', goal_formula=''(x + y) >= (y + 1)'')]'
                    long: |-
                      [Obligation(name='VC for main (loop invariant preservation)',
                                  proved=False,
                                  relevance_hints='use int.Int\n'
                                                  '\n'
                                                  'let main () diverges =  (* GOAL *)\n'
                                                  '  let ref x = any int in\n'
                                                  '  let ref y = any int in\n'
                                                  '  x <- 1;  (* premise *)\n'
                                                  '  y <- 0;  (* premise *)\n'
                                                  '  while y < 100000 do  (* premise *)\n'
                                                  '    invariant { y <= 100000 }  (* premise *)\n'
                                                  '    invariant { x >= 0 && y >= 0 }  (* premise '
                                                  '*)\n'
                                                  '    invariant { x >= y }  (* GOAL, premise *)\n'
                                                  '    x <- x + y;  (* premise *)\n'
                                                  '    y <- y + 1  (* premise *)\n'
                                                  '  done;\n'
                                                  '  assert { true }',
                                  goal_formula='(x + y) >= (y + 1)')]
                    json_provided: true
                    json:
                      - name: VC for main (loop invariant preservation)
                        proved: false
                        relevance_hints: |-
                          use int.Int

                          let main () diverges =  (* GOAL *)
                            let ref x = any int in
                            let ref y = any int in
                            x <- 1;  (* premise *)
                            y <- 0;  (* premise *)
                            while y < 100000 do  (* premise *)
                              invariant { y <= 100000 }  (* premise *)
                              invariant { x >= 0 && y >= 0 }  (* premise *)
                              invariant { x >= y }  (* GOAL, premise *)
                              x <- x + y;  (* premise *)
                              y <- y + 1  (* premise *)
                            done;
                            assert { true }
                        goal_formula: (x + y) >= (y + 1)
                tags:
                  - _suggest_invariants
                node_id: 88
            - - with_ids: redundant([], $3{%89}[0])
                with_hints: null
              - 77
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: x - y*(y-1)/2 >= 1
                    long: '''x - y*(y-1)/2 >= 1'''
                    json_provided: true
                    json: x - y*(y-1)/2 >= 1
                tags:
                  - _is_redundant
                node_id: 93
            - - with_ids: prove([], $3{%89}[0])
                with_hints: null
              - 79
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: x - y*(y-1)/2 >= 1
                    long: '''x - y*(y-1)/2 >= 1'''
                    json_provided: true
                    json: x - y*(y-1)/2 >= 1
                tags:
                  - _prove_goal
                node_id: 95
            - - with_ids: redundant([], $3{%90}[0])
                with_hints: null
              - 81
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: x >= y
                    long: '''x >= y'''
                    json_provided: true
                    json: x >= y
                tags:
                  - _is_redundant
                node_id: 97
            - - with_ids: prove([], $3{%90}[0])
                with_hints: null
              - 83
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: x >= y
                    long: '''x >= y'''
                    json_provided: true
                    json: x >= y
                tags:
                  - _prove_goal
                node_id: 99
            - - with_ids: redundant([], $3{%91}[0])
                with_hints: null
              - 85
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: x >= 1
                    long: '''x >= 1'''
                    json_provided: true
                    json: x >= 1
                tags:
                  - _is_redundant
                node_id: 101
            - - with_ids: prove([], $3{%91}[0])
                with_hints: null
              - 87
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: x >= 1
                    long: '''x >= 1'''
                    json_provided: true
                    json: x >= 1
                tags:
                  - _prove_goal
                node_id: 103
            - - with_ids: redundant([], $3{%91}[1])
                with_hints: null
              - 89
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  fml:
                    short: y <= 100000
                    long: '''y <= 100000'''
                    json_provided: true
                    json: y <= 100000
                tags:
                  - _is_redundant
                node_id: 105
            - - with_ids: prove([], $3{%91}[1])
                with_hints: null
              - 91
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: ()
                    long: ()
                    json_provided: true
                    json: []
                  goal:
                    short: y <= 100000
                    long: '''y <= 100000'''
                    json_provided: true
                    json: y <= 100000
                tags:
                  - _prove_goal
                node_id: 107
            - - with_ids: redundant([$3{%91}[1]], $3{%92}[0])
                with_hints: null
              - 93
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000',)
                    long: ('y <= 100000',)
                    json_provided: true
                    json:
                      - y <= 100000
                  fml:
                    short: x >= y || y < 100000
                    long: '''x >= y || y < 100000'''
                    json_provided: true
                    json: x >= y || y < 100000
                tags:
                  - _is_redundant
                node_id: 109
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]]], $3{%92}[0])
                with_hints: null
              - 95
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []),)
                    long: (('y <= 100000', []),)
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                  goal:
                    short: x >= y || y < 100000
                    long: '''x >= y || y < 100000'''
                    json_provided: true
                    json: x >= y || y < 100000
                tags:
                  - _prove_goal
                node_id: 111
            - - with_ids: redundant([$3{%91}[1]], $3{%92}[1])
                with_hints: null
              - 97
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000',)
                    long: ('y <= 100000',)
                    json_provided: true
                    json:
                      - y <= 100000
                  fml:
                    short: x >= 0
                    long: '''x >= 0'''
                    json_provided: true
                    json: x >= 0
                tags:
                  - _is_redundant
                node_id: 113
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]]], $3{%92}[1])
                with_hints: null
              - 99
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []),)
                    long: (('y <= 100000', []),)
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                  goal:
                    short: x >= 0
                    long: '''x >= 0'''
                    json_provided: true
                    json: x >= 0
                tags:
                  - _prove_goal
                node_id: 115
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]]], nil)
                with_hints: null
              - 101
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []),)
                    long: (('y <= 100000', []),)
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                  goal:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                tags:
                  - _prove_goal
                node_id: 117
            - - with_ids: redundant([$3{%91}[1]], $3{%90}[0])
                with_hints: null
              - 103
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000',)
                    long: ('y <= 100000',)
                    json_provided: true
                    json:
                      - y <= 100000
                  fml:
                    short: x >= y
                    long: '''x >= y'''
                    json_provided: true
                    json: x >= y
                tags:
                  - _is_redundant
                node_id: 119
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]]], $3{%90}[0])
                with_hints: null
              - 105
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []),)
                    long: (('y <= 100000', []),)
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                  goal:
                    short: x >= y
                    long: '''x >= y'''
                    json_provided: true
                    json: x >= y
                tags:
                  - _prove_goal
                node_id: 121
            - - with_ids: redundant([$3{%91}[1]], $3{%91}[0])
                with_hints: null
              - 107
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000',)
                    long: ('y <= 100000',)
                    json_provided: true
                    json:
                      - y <= 100000
                  fml:
                    short: x >= 1
                    long: '''x >= 1'''
                    json_provided: true
                    json: x >= 1
                tags:
                  - _is_redundant
                node_id: 123
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]]], $3{%91}[0])
                with_hints: null
              - 109
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []),)
                    long: (('y <= 100000', []),)
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                  goal:
                    short: x >= 1
                    long: '''x >= 1'''
                    json_provided: true
                    json: x >= 1
                tags:
                  - _prove_goal
                node_id: 125
            - - with_ids: suggest($105{%122}[1])
                with_hints: null
              - 111
              - kind: nested
                strategy: _suggest_invariants
                args:
                  unproved:
                    short: '[Obligation(name=''VC for main (loop invariant preservation)'', proved=False,
                      relevance_hints=''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x
                      = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (*
                      premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (*
                      premise *)\n    invariant { x >= y }  (* GOAL, premise *)\n    x <- x + y;  (* premise
                      *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', goal_formula=''(x
                      + y) >= (y + 1)'')]'
                    long: |-
                      [Obligation(name='VC for main (loop invariant preservation)',
                                  proved=False,
                                  relevance_hints='use int.Int\n'
                                                  '\n'
                                                  'let main () diverges =  (* GOAL *)\n'
                                                  '  let ref x = any int in\n'
                                                  '  let ref y = any int in\n'
                                                  '  x <- 1;  (* premise *)\n'
                                                  '  y <- 0;  (* premise *)\n'
                                                  '  while y < 100000 do  (* premise *)\n'
                                                  '    invariant { y <= 100000 }  (* premise *)\n'
                                                  '    invariant { x >= y }  (* GOAL, premise *)\n'
                                                  '    x <- x + y;  (* premise *)\n'
                                                  '    y <- y + 1  (* premise *)\n'
                                                  '  done;\n'
                                                  '  assert { true }',
                                  goal_formula='(x + y) >= (y + 1)')]
                    json_provided: true
                    json:
                      - name: VC for main (loop invariant preservation)
                        proved: false
                        relevance_hints: |-
                          use int.Int

                          let main () diverges =  (* GOAL *)
                            let ref x = any int in
                            let ref y = any int in
                            x <- 1;  (* premise *)
                            y <- 0;  (* premise *)
                            while y < 100000 do  (* premise *)
                              invariant { y <= 100000 }  (* premise *)
                              invariant { x >= y }  (* GOAL, premise *)
                              x <- x + y;  (* premise *)
                              y <- y + 1  (* premise *)
                            done;
                            assert { true }
                        goal_formula: (x + y) >= (y + 1)
                tags:
                  - _suggest_invariants
                node_id: 127
            - - with_ids: search_equivalent([$3{%90}[0], $3{%91}[0], $3{%92}[0], $3{%92}[1], $3{%91}[1]],
                  $111{%130}[1])
                with_hints: null
              - 113
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x >= 1', 'x >= y || y < 100000', 'x >= 0', 'y <= 100000')
                    long: ('x >= y', 'x >= 1', 'x >= y || y < 100000', 'x >= 0', 'y <= 100000')
                    json_provided: true
                    json:
                      - x >= y
                      - x >= 1
                      - x >= y || y < 100000
                      - x >= 0
                      - y <= 100000
                  fml:
                    short: x >= y*(y-1)/2
                    long: '''x >= y*(y-1)/2'''
                    json_provided: true
                    json: x >= y*(y-1)/2
                tags:
                  - _search_equivalent
                node_id: 131
            - - with_ids: redundant([$3{%91}[1]], $111{%130}[1])
                with_hints: null
              - 115
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000',)
                    long: ('y <= 100000',)
                    json_provided: true
                    json:
                      - y <= 100000
                  fml:
                    short: x >= y*(y-1)/2
                    long: '''x >= y*(y-1)/2'''
                    json_provided: true
                    json: x >= y*(y-1)/2
                tags:
                  - _is_redundant
                node_id: 133
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]]], $111{%130}[1])
                with_hints: null
              - 117
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []),)
                    long: (('y <= 100000', []),)
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                  goal:
                    short: x >= y*(y-1)/2
                    long: '''x >= y*(y-1)/2'''
                    json_provided: true
                    json: x >= y*(y-1)/2
                tags:
                  - _prove_goal
                node_id: 135
            - - with_ids: suggest($99{%116}[1])
                with_hints: null
              - 119
              - kind: nested
                strategy: _suggest_invariants
                args:
                  unproved:
                    short: '[Obligation(name=''VC for main (loop invariant preservation)'', proved=False,
                      relevance_hints=''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x
                      = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (*
                      premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (*
                      premise *)\n    invariant { x >= 0 }  (* GOAL, premise *)\n    x <- x + y;  (* premise
                      *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', goal_formula=''(x
                      + y) >= 0'')]'
                    long: |-
                      [Obligation(name='VC for main (loop invariant preservation)',
                                  proved=False,
                                  relevance_hints='use int.Int\n'
                                                  '\n'
                                                  'let main () diverges =  (* GOAL *)\n'
                                                  '  let ref x = any int in\n'
                                                  '  let ref y = any int in\n'
                                                  '  x <- 1;  (* premise *)\n'
                                                  '  y <- 0;  (* premise *)\n'
                                                  '  while y < 100000 do  (* premise *)\n'
                                                  '    invariant { y <= 100000 }  (* premise *)\n'
                                                  '    invariant { x >= 0 }  (* GOAL, premise *)\n'
                                                  '    x <- x + y;  (* premise *)\n'
                                                  '    y <- y + 1  (* premise *)\n'
                                                  '  done;\n'
                                                  '  assert { true }',
                                  goal_formula='(x + y) >= 0')]
                    json_provided: true
                    json:
                      - name: VC for main (loop invariant preservation)
                        proved: false
                        relevance_hints: |-
                          use int.Int

                          let main () diverges =  (* GOAL *)
                            let ref x = any int in
                            let ref y = any int in
                            x <- 1;  (* premise *)
                            y <- 0;  (* premise *)
                            while y < 100000 do  (* premise *)
                              invariant { y <= 100000 }  (* premise *)
                              invariant { x >= 0 }  (* GOAL, premise *)
                              x <- x + y;  (* premise *)
                              y <- y + 1  (* premise *)
                            done;
                            assert { true }
                        goal_formula: (x + y) >= 0
                tags:
                  - _suggest_invariants
                node_id: 137
            - - with_ids: search_equivalent([$3{%90}[0], $3{%91}[0], $3{%92}[0], $3{%92}[1], $3{%91}[1]],
                  $119{%138}[0])
                with_hints: null
              - 121
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x >= 1', 'x >= y || y < 100000', 'x >= 0', 'y <= 100000')
                    long: ('x >= y', 'x >= 1', 'x >= y || y < 100000', 'x >= 0', 'y <= 100000')
                    json_provided: true
                    json:
                      - x >= y
                      - x >= 1
                      - x >= y || y < 100000
                      - x >= 0
                      - y <= 100000
                  fml:
                    short: y >= 0
                    long: '''y >= 0'''
                    json_provided: true
                    json: y >= 0
                tags:
                  - _search_equivalent
                node_id: 141
            - - with_ids: search_equivalent([$3{%90}[0], $3{%91}[0], $3{%92}[0], $3{%92}[1], $3{%91}[1]],
                  $119{%140}[0])
                with_hints: null
              - 123
              - kind: nested
                strategy: _search_equivalent
                args:
                  facts:
                    short: ('x >= y', 'x >= 1', 'x >= y || y < 100000', 'x >= 0', 'y <= 100000')
                    long: ('x >= y', 'x >= 1', 'x >= y || y < 100000', 'x >= 0', 'y <= 100000')
                    json_provided: true
                    json:
                      - x >= y
                      - x >= 1
                      - x >= y || y < 100000
                      - x >= 0
                      - y <= 100000
                  fml:
                    short: x >= (y * (y - 1)) / 2
                    long: '''x >= (y * (y - 1)) / 2'''
                    json_provided: true
                    json: x >= (y * (y - 1)) / 2
                tags:
                  - _search_equivalent
                node_id: 143
            - - with_ids: redundant([$3{%91}[1]], $119{%138}[0])
                with_hints: null
              - 125
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000',)
                    long: ('y <= 100000',)
                    json_provided: true
                    json:
                      - y <= 100000
                  fml:
                    short: y >= 0
                    long: '''y >= 0'''
                    json_provided: true
                    json: y >= 0
                tags:
                  - _is_redundant
                node_id: 145
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]]], $119{%138}[0])
                with_hints: null
              - 127
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []),)
                    long: (('y <= 100000', []),)
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                  goal:
                    short: y >= 0
                    long: '''y >= 0'''
                    json_provided: true
                    json: y >= 0
                tags:
                  - _prove_goal
                node_id: 147
            - - with_ids: redundant([$3{%91}[1], $119{%138}[0]], $119{%140}[0])
                with_hints: null
              - 129
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000', 'y >= 0')
                    long: ('y <= 100000', 'y >= 0')
                    json_provided: true
                    json:
                      - y <= 100000
                      - y >= 0
                  fml:
                    short: x >= (y * (y - 1)) / 2
                    long: '''x >= (y * (y - 1)) / 2'''
                    json_provided: true
                    json: x >= (y * (y - 1)) / 2
                tags:
                  - _is_redundant
                node_id: 149
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]]], $119{%140}[0])
                with_hints: null
              - 131
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []), ('y >= 0', ['y <= 100000']))
                    long: (('y <= 100000', []), ('y >= 0', ['y <= 100000']))
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                      - - y >= 0
                        - - y <= 100000
                  goal:
                    short: x >= (y * (y - 1)) / 2
                    long: '''x >= (y * (y - 1)) / 2'''
                    json_provided: true
                    json: x >= (y * (y - 1)) / 2
                tags:
                  - _prove_goal
                node_id: 151
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]]], nil)
                with_hints: null
              - 133
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []), ('y >= 0', ['y <= 100000']))
                    long: (('y <= 100000', []), ('y >= 0', ['y <= 100000']))
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                      - - y >= 0
                        - - y <= 100000
                  goal:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                tags:
                  - _prove_goal
                node_id: 153
            - - with_ids: redundant([$3{%91}[1], $119{%138}[0]], $3{%90}[0])
                with_hints: null
              - 135
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000', 'y >= 0')
                    long: ('y <= 100000', 'y >= 0')
                    json_provided: true
                    json:
                      - y <= 100000
                      - y >= 0
                  fml:
                    short: x >= y
                    long: '''x >= y'''
                    json_provided: true
                    json: x >= y
                tags:
                  - _is_redundant
                node_id: 155
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]]], $3{%90}[0])
                with_hints: null
              - 137
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []), ('y >= 0', ['y <= 100000']))
                    long: (('y <= 100000', []), ('y >= 0', ['y <= 100000']))
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                      - - y >= 0
                        - - y <= 100000
                  goal:
                    short: x >= y
                    long: '''x >= y'''
                    json_provided: true
                    json: x >= y
                tags:
                  - _prove_goal
                node_id: 157
            - - with_ids: redundant([$3{%91}[1], $119{%138}[0]], $3{%91}[0])
                with_hints: null
              - 139
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000', 'y >= 0')
                    long: ('y <= 100000', 'y >= 0')
                    json_provided: true
                    json:
                      - y <= 100000
                      - y >= 0
                  fml:
                    short: x >= 1
                    long: '''x >= 1'''
                    json_provided: true
                    json: x >= 1
                tags:
                  - _is_redundant
                node_id: 159
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]]], $3{%91}[0])
                with_hints: null
              - 141
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []), ('y >= 0', ['y <= 100000']))
                    long: (('y <= 100000', []), ('y >= 0', ['y <= 100000']))
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                      - - y >= 0
                        - - y <= 100000
                  goal:
                    short: x >= 1
                    long: '''x >= 1'''
                    json_provided: true
                    json: x >= 1
                tags:
                  - _prove_goal
                node_id: 161
            - - with_ids: redundant([$3{%91}[1], $119{%138}[0], $3{%91}[0]], $3{%92}[0])
                with_hints: null
              - 143
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000', 'y >= 0', 'x >= 1')
                    long: ('y <= 100000', 'y >= 0', 'x >= 1')
                    json_provided: true
                    json:
                      - y <= 100000
                      - y >= 0
                      - x >= 1
                  fml:
                    short: x >= y || y < 100000
                    long: '''x >= y || y < 100000'''
                    json_provided: true
                    json: x >= y || y < 100000
                tags:
                  - _is_redundant
                node_id: 163
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]], [$3{%91}[0],
                  $141{%162}[1]]], $3{%92}[0])
                with_hints: null
              - 145
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []), ('y >= 0', ['y <= 100000']), ('x >= 1', ['y <= 100000',
                      'y >= 0']))
                    long: |-
                      (('y <= 100000', []),
                       ('y >= 0', ['y <= 100000']),
                       ('x >= 1', ['y <= 100000', 'y >= 0']))
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                      - - y >= 0
                        - - y <= 100000
                      - - x >= 1
                        - - y <= 100000
                          - y >= 0
                  goal:
                    short: x >= y || y < 100000
                    long: '''x >= y || y < 100000'''
                    json_provided: true
                    json: x >= y || y < 100000
                tags:
                  - _prove_goal
                node_id: 165
            - - with_ids: redundant([$3{%91}[1], $119{%138}[0], $3{%91}[0], $3{%92}[0]], $3{%92}[1])
                with_hints: null
              - 147
              - kind: nested
                strategy: _is_redundant
                args:
                  proved:
                    short: ('y <= 100000', 'y >= 0', 'x >= 1', 'x >= y || y < 100000')
                    long: ('y <= 100000', 'y >= 0', 'x >= 1', 'x >= y || y < 100000')
                    json_provided: true
                    json:
                      - y <= 100000
                      - y >= 0
                      - x >= 1
                      - x >= y || y < 100000
                  fml:
                    short: x >= 0
                    long: '''x >= 0'''
                    json_provided: true
                    json: x >= 0
                tags:
                  - _is_redundant
                node_id: 167
            - - with_ids: prove([[$3{%91}[1], $91{%108}[1]], [$119{%138}[0], $127{%148}[1]], [$3{%91}[0],
                  $141{%162}[1]], [$3{%92}[0], $145{%166}[1]]], nil)
                with_hints: null
              - 149
              - kind: nested
                strategy: _prove_goal
                args:
                  prog:
                    short: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    long: |-
                      ('use int.Int\n'
                       '\n'
                       'let main () diverges =\n'
                       '  let ref x = any int in\n'
                       '  let ref y = any int in\n'
                       '  x <- 1;\n'
                       '  y <- 0;\n'
                       '  while y < 100000 do\n'
                       '    x <- x + y;\n'
                       '    y <- y + 1\n'
                       '  done;\n'
                       '  assert { x >= y }')
                    json_provided: true
                    json: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                  proved:
                    short: (('y <= 100000', []), ('y >= 0', ['y <= 100000']), ('x >= 1', ['y <= 100000',
                      'y >= 0']), ('x >= y || y < 100000', ['y <= 100000', 'y >= 0', 'x >= 1']))
                    long: |-
                      (('y <= 100000', []),
                       ('y >= 0', ['y <= 100000']),
                       ('x >= 1', ['y <= 100000', 'y >= 0']),
                       ('x >= y || y < 100000', ['y <= 100000', 'y >= 0', 'x >= 1']))
                    json_provided: true
                    json:
                      - - y <= 100000
                        - []
                      - - y >= 0
                        - - y <= 100000
                      - - x >= 1
                        - - y <= 100000
                          - y >= 0
                      - - x >= y || y < 100000
                        - - y <= 100000
                          - y >= 0
                          - x >= 1
                  goal:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                tags:
                  - _prove_goal
                node_id: 169
          actions:
            - ref:
                with_ids: $149{%170}[1]
                with_hints: null
              hints: null
              related_success_nodes:
                - 170
                - 91
                - 3
                - 108
                - 138
                - 116
                - 92
                - 148
                - 162
                - 166
              related_answers: []
              value:
                short: '[''y <= 100000'', ''y >= 0'', ''x >= 1'', ''x >= y || y < 100000'']'
                long: '[''y <= 100000'', ''y >= 0'', ''x >= 1'', ''x >= y || y < 100000'']'
                json_provided: false
                json: null
              destination: 171
          origin: root
        2:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 2
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                tags:
                  - __Computation__
                answers:
                  - id: 1
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (assertion)'',
                        ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y
                        <- 0;\n  while y < 100000 do  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { x >= y }  (* GOAL *)'', ''goal_formula'': ''x >= y''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (assertion)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }  (* GOAL *)',
                                          'goal_formula': 'x >= y'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (assertion)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;
                                while y < 100000 do  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }  (* GOAL *)
                            goal_formula: x >= y
          actions:
            - ref:
                with_ids: $2{@1}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 1
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (assertion)'', ''proved'':
                  False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                  ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;\n  while y < 100000
                  do  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }  (*
                  GOAL *)'', ''goal_formula'': ''x >= y''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (assertion)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }  (* GOAL *)',
                                    'goal_formula': 'x >= y'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (assertion)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;
                          while y < 100000 do  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }  (* GOAL *)
                      goal_formula: x >= y
              destination: 3
          origin:
            - nested
            - 1
            - 0
        3:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (assertion)', proved=False, relevance_hints='use
              int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any
              int in\n  x <- 1;\n  y <- 0;\n  while y < 100000 do  (* premise *)\n    x <- x + y;\n    y
              <- y + 1\n  done;\n  assert { x >= y }  (* GOAL *)', goal_formula='x >= y')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (assertion)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;\n'
                                           '  y <- 0;\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    x <- x + y;\n'
                                           '    y <- y + 1\n'
                                           '  done;\n'
                                           '  assert { x >= y }  (* GOAL *)',
                           goal_formula='x >= y')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (assertion)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;
                      while y < 100000 do  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }  (* GOAL *)
                  goal_formula: x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 2
            - 0
        4:
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: SuggestInvariants
          tags:
            - SuggestInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - 4
              - kind: query
                name: SuggestInvariants
                args:
                  unproved:
                    name: VC for main (assertion)
                    proved: false
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do  (* premise *)
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }  (* GOAL *)
                    goal_formula: x >= y
                tags:
                  - SuggestInvariants
                answers:
                  - id: 2
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= y'), InvariantSuggestion(trick='negation', invariant='x - y >= 0')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= y'),
                                                          InvariantSuggestion(trick='negation',
                                                                              invariant='x - y >= 0')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= y
                          - trick: negation
                            invariant: x - y >= 0
                  - id: 3
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= y')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= y')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= y
                  - id: 4
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= y'), InvariantSuggestion(trick='monotone', invariant='x >= y')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= y'),
                                                          InvariantSuggestion(trick='monotone',
                                                                              invariant='x >= y')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= y
                          - trick: monotone
                            invariant: x >= y
                  - id: 22
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= 0'), InvariantSuggestion(trick='linear', invariant='x >= y*(y-1)/2 + y')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= 0'),
                                                          InvariantSuggestion(trick='linear',
                                                                              invariant='x >= '
                                                                                        'y*(y-1)/2 + y')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= 0
                          - trick: linear
                            invariant: x >= y*(y-1)/2 + y
                  - id: 23
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= y'), InvariantSuggestion(trick='relax_loop_guard', invariant='y <= 100000')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= y'),
                                                          InvariantSuggestion(trick='relax_loop_guard',
                                                                              invariant='y <= 100000')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= y
                          - trick: relax_loop_guard
                            invariant: y <= 100000
                  - id: 24
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='propose_post',
                        invariant='x >= y'), InvariantSuggestion(trick='linear', invariant='x >= y*(y
                        - 1)/2'), InvariantSuggestion(trick='linear', invariant='x >= (y - 1)*y/2')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='propose_post',
                                                                              invariant='x >= y'),
                                                          InvariantSuggestion(trick='linear',
                                                                              invariant='x >= y*(y - '
                                                                                        '1)/2'),
                                                          InvariantSuggestion(trick='linear',
                                                                              invariant='x >= (y - '
                                                                                        '1)*y/2')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: propose_post
                            invariant: x >= y
                          - trick: linear
                            invariant: x >= y*(y - 1)/2
                          - trick: linear
                            invariant: x >= (y - 1)*y/2
                  - id: 25
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= 0 && y >= 0')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= 0 && y '
                                                                                        '>= 0')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= 0 && y >= 0
                  - id: 50
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        - y*(y-1)/2 >= 1')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x - y*(y-1)/2 '
                                                                                        '>= 1')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x - y*(y-1)/2 >= 1
                  - id: 51
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='propose_post',
                        invariant='x >= y')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='propose_post',
                                                                              invariant='x >= y')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: propose_post
                            invariant: x >= y
                  - id: 52
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= 1'), InvariantSuggestion(trick='monotone', invariant='y <= 100000')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= 1'),
                                                          InvariantSuggestion(trick='monotone',
                                                                              invariant='y <= 100000')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= 1
                          - trick: monotone
                            invariant: y <= 100000
                  - id: 53
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='true_or_continue',
                        invariant='x >= y || y < 100000'), InvariantSuggestion(trick='linear', invariant='x
                        >= 0')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='true_or_continue',
                                                                              invariant='x >= y || y < '
                                                                                        '100000'),
                                                          InvariantSuggestion(trick='linear',
                                                                              invariant='x >= 0')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: true_or_continue
                            invariant: x >= y || y < 100000
                          - trick: linear
                            invariant: x >= 0
          actions:
            - ref:
                with_ids: $4{@2}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 2
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= y'), InvariantSuggestion(trick='negation', invariant='x - y >= 0')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= y'),
                                                    InvariantSuggestion(trick='negation',
                                                                        invariant='x - y >= 0')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= y
                    - trick: negation
                      invariant: x - y >= 0
              destination: 5
            - ref:
                with_ids: $4{@3}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 3
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= y')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= y')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= y
              destination: 6
            - ref:
                with_ids: $4{@4}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 4
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= y'), InvariantSuggestion(trick='monotone', invariant='x >= y')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= y'),
                                                    InvariantSuggestion(trick='monotone',
                                                                        invariant='x >= y')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= y
                    - trick: monotone
                      invariant: x >= y
              destination: 7
            - ref:
                with_ids: $4{@22}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 22
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= 0'), InvariantSuggestion(trick='linear', invariant='x >= y*(y-1)/2 + y')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= 0'),
                                                    InvariantSuggestion(trick='linear',
                                                                        invariant='x >= '
                                                                                  'y*(y-1)/2 + y')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= 0
                    - trick: linear
                      invariant: x >= y*(y-1)/2 + y
              destination: 36
            - ref:
                with_ids: $4{@23}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 23
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= y'), InvariantSuggestion(trick='relax_loop_guard', invariant='y <= 100000')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= y'),
                                                    InvariantSuggestion(trick='relax_loop_guard',
                                                                        invariant='y <= 100000')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= y
                    - trick: relax_loop_guard
                      invariant: y <= 100000
              destination: 37
            - ref:
                with_ids: $4{@24}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 24
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='propose_post', invariant='x
                  >= y'), InvariantSuggestion(trick='linear', invariant='x >= y*(y - 1)/2'), InvariantSuggestion(trick='linear',
                  invariant='x >= (y - 1)*y/2')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='propose_post',
                                                                        invariant='x >= y'),
                                                    InvariantSuggestion(trick='linear',
                                                                        invariant='x >= y*(y - '
                                                                                  '1)/2'),
                                                    InvariantSuggestion(trick='linear',
                                                                        invariant='x >= (y - '
                                                                                  '1)*y/2')])
                json_provided: true
                json:
                  suggestions:
                    - trick: propose_post
                      invariant: x >= y
                    - trick: linear
                      invariant: x >= y*(y - 1)/2
                    - trick: linear
                      invariant: x >= (y - 1)*y/2
              destination: 38
            - ref:
                with_ids: $4{@25}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 25
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= 0 && y >= 0')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= 0 && y '
                                                                                  '>= 0')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= 0 && y >= 0
              destination: 39
            - ref:
                with_ids: $4{@50}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 50
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  - y*(y-1)/2 >= 1')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x - y*(y-1)/2 '
                                                                                  '>= 1')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x - y*(y-1)/2 >= 1
              destination: 89
            - ref:
                with_ids: $4{@51}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 51
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='propose_post', invariant='x
                  >= y')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='propose_post',
                                                                        invariant='x >= y')])
                json_provided: true
                json:
                  suggestions:
                    - trick: propose_post
                      invariant: x >= y
              destination: 90
            - ref:
                with_ids: $4{@52}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 52
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= 1'), InvariantSuggestion(trick='monotone', invariant='y <= 100000')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= 1'),
                                                    InvariantSuggestion(trick='monotone',
                                                                        invariant='y <= 100000')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= 1
                    - trick: monotone
                      invariant: y <= 100000
              destination: 91
            - ref:
                with_ids: $4{@53}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 53
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='true_or_continue',
                  invariant='x >= y || y < 100000'), InvariantSuggestion(trick='linear', invariant='x
                  >= 0')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='true_or_continue',
                                                                        invariant='x >= y || y < '
                                                                                  '100000'),
                                                    InvariantSuggestion(trick='linear',
                                                                        invariant='x >= 0')])
                json_provided: true
                json:
                  suggestions:
                    - trick: true_or_continue
                      invariant: x >= y || y < 100000
                    - trick: linear
                      invariant: x >= 0
              destination: 92
          origin:
            - nested
            - 1
            - 1
        5:
          kind: Success
          success_value:
            short: '[''x >= y'', ''x - y >= 0'']'
            long: '[''x >= y'', ''x - y >= 0'']'
            json_provided: true
            json:
              - x >= y
              - x - y >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 0
        6:
          kind: Success
          success_value:
            short: '[''x >= y'']'
            long: '[''x >= y'']'
            json_provided: true
            json:
              - x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 1
        7:
          kind: Success
          success_value:
            short: '[''x >= y'', ''x >= y'']'
            long: '[''x >= y'', ''x >= y'']'
            json_provided: true
            json:
              - x >= y
              - x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 2
        8:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 6
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: x >= y
                tags:
                  - __Computation__
                answers:
                  - id: 5
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $6{@5}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 5
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 9
          origin:
            - nested
            - 1
            - 2
        9:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 8
            - 0
        10:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 8
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 6
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { x
                        >= y }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }'', ''goal_formula'': ''1 >= 0''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { x >= y }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <- y +
                        1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(x + y) >=
                        (y + 1)''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { x >= y }  (* premise *)\n    x <-
                        x + y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'', ''goal_formula'':
                        ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { x >= y }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { x >= y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= (y + 1)'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { x >= y }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { x >= y }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= (y + 1)
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { x >= y }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $8{@6}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 6
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { x >= y }  (* GOAL *)\n    x
                  <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''1 >= 0''},
                  {''name'': ''VC for main (loop invariant preservation)'', ''proved'': False, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { x >= y }  (* GOAL, premise *)\n    x <- x
                  + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                  ''(x + y) >= (y + 1)''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { x >= y }  (* premise *)\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { x >= y }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { x >= y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= (y + 1)'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { x >= y }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { x >= y }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= (y + 1)
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { x >= y }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 11
          origin:
            - nested
            - 1
            - 3
        11:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
              y < 100000 do  (* premise *)\n    invariant { x >= y }  (* GOAL, premise *)\n    x <- x
              + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }', goal_formula='(x
              + y) >= (y + 1)')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { x >= y }  (* GOAL, premise *)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1  (* premise *)\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='(x + y) >= (y + 1)')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { x >= y }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1)
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 10
            - 0
        12:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 10
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: x - y >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 7
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $10{@7}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 7
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 13
          origin:
            - nested
            - 1
            - 4
        13:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 12
            - 0
        14:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 12
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x - y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x - y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 8
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { x
                        - y >= 0 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }'', ''goal_formula'': ''(1 - 0) >= 0''}, {''name'': ''VC for main (loop invariant
                        preservation)'', ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { x - y >= 0 }  (* GOAL, premise *)\n    x <- x + y;  (*
                        premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                        ''((x + y) - (y + 1)) >= 0''}, {''name'': ''VC for main (assertion)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { x - y
                        >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { x - y >= 0 }  (* GOAL '
                                                             '*)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(1 - 0) >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { x - y >= 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '((x + y) - (y + 1)) >= 0'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { x - y >= 0 }  (* premise '
                                                             '*)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { x - y >= 0 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: (1 - 0) >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { x - y >= 0 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: ((x + y) - (y + 1)) >= 0
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { x - y >= 0 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $12{@8}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 8
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { x - y >= 0 }  (* GOAL *)\n    x
                  <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''(1 - 0)
                  >= 0''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'': False,
                  ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref
                  x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise
                  *)\n  while y < 100000 do  (* premise *)\n    invariant { x - y >= 0 }  (* GOAL, premise
                  *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                  { true }'', ''goal_formula'': ''((x + y) - (y + 1)) >= 0''}, {''name'': ''VC for main
                  (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                  =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                  *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant {
                  x - y >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { x - y >= 0 }  (* GOAL '
                                                       '*)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(1 - 0) >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { x - y >= 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '((x + y) - (y + 1)) >= 0'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { x - y >= 0 }  (* premise '
                                                       '*)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { x - y >= 0 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: (1 - 0) >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { x - y >= 0 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: ((x + y) - (y + 1)) >= 0
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { x - y >= 0 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 15
          origin:
            - nested
            - 1
            - 5
        15:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
              y < 100000 do  (* premise *)\n    invariant { x - y >= 0 }  (* GOAL, premise *)\n    x <-
              x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }', goal_formula='((x
              + y) - (y + 1)) >= 0')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { x - y >= 0 }  (* GOAL, premise '
                                           '*)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1  (* premise *)\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='((x + y) - (y + 1)) >= 0')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { x - y >= 0 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: ((x + y) - (y + 1)) >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 14
            - 0
        16:
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: SuggestInvariants
          tags:
            - SuggestInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - 14
              - kind: query
                name: SuggestInvariants
                args:
                  unproved:
                    name: VC for main (loop invariant preservation)
                    proved: false
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;  (* premise *)
                        y <- 0;  (* premise *)
                        while y < 100000 do  (* premise *)
                          invariant { x >= y }  (* GOAL, premise *)
                          x <- x + y;  (* premise *)
                          y <- y + 1  (* premise *)
                        done;
                        assert { true }
                    goal_formula: (x + y) >= (y + 1)
                tags:
                  - SuggestInvariants
                answers:
                  - id: 9
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard',
                        invariant='x >= y'), InvariantSuggestion(trick='linear', invariant='x >= y')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard',
                                                                              invariant='x >= y'),
                                                          InvariantSuggestion(trick='linear',
                                                                              invariant='x >= y')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: cond_guard
                            invariant: x >= y
                          - trick: linear
                            invariant: x >= y
                  - id: 10
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='strengthen_inv',
                        invariant='x >= y')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='strengthen_inv',
                                                                              invariant='x >= y')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: strengthen_inv
                            invariant: x >= y
                  - id: 11
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard',
                        invariant='x >= y')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard',
                                                                              invariant='x >= y')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: cond_guard
                            invariant: x >= y
                  - id: 12
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='relax_loop_guard',
                        invariant='x >= y'), InvariantSuggestion(trick='propose_post', invariant='x >=
                        y')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='relax_loop_guard',
                                                                              invariant='x >= y'),
                                                          InvariantSuggestion(trick='propose_post',
                                                                              invariant='x >= y')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: relax_loop_guard
                            invariant: x >= y
                          - trick: propose_post
                            invariant: x >= y
                  - id: 13
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='range', invariant='x
                        >= y')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='range',
                                                                              invariant='x >= y')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: range
                            invariant: x >= y
                  - id: 14
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard',
                        invariant='x >= y provisions after the loop youth lose squ parlament gift oppon
                        strata nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence
                        새로운 régime personality,new clutch anzeigen时报 zwölf ondernemer oversees simple
                        pick yt=')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard',
                                                                              invariant='x >= y '
                                                                                        'provisions '
                                                                                        'after the '
                                                                                        'loop youth '
                                                                                        'lose squ '
                                                                                        'parlament '
                                                                                        'gift oppon '
                                                                                        'strata '
                                                                                        'nőabcdef '
                                                                                        'mentions Δ '
                                                                                        'ost সে novel '
                                                                                        'dumple '
                                                                                        'aktivitet '
                                                                                        'fest vétér '
                                                                                        'Providence '
                                                                                        '새로운 régime '
                                                                                        'personality,new '
                                                                                        'clutch '
                                                                                        'anzeigen时报 '
                                                                                        'zwölf '
                                                                                        'ondernemer '
                                                                                        'oversees '
                                                                                        'simple pick '
                                                                                        'yt=')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: cond_guard
                            invariant: x >= y provisions after the loop youth lose squ parlament gift
                              oppon strata nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér
                              Providence 새로운 régime personality,new clutch anzeigen时报 zwölf ondernemer
                              oversees simple pick yt=
                  - id: 15
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= y * (y - 1) / 2')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= y * (y - '
                                                                                        '1) / 2')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= y * (y - 1) / 2
          actions:
            - ref:
                with_ids: $14{@9}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 9
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard', invariant='x
                  >= y'), InvariantSuggestion(trick='linear', invariant='x >= y')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard',
                                                                        invariant='x >= y'),
                                                    InvariantSuggestion(trick='linear',
                                                                        invariant='x >= y')])
                json_provided: true
                json:
                  suggestions:
                    - trick: cond_guard
                      invariant: x >= y
                    - trick: linear
                      invariant: x >= y
              destination: 17
            - ref:
                with_ids: $14{@10}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 10
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='strengthen_inv', invariant='x
                  >= y')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='strengthen_inv',
                                                                        invariant='x >= y')])
                json_provided: true
                json:
                  suggestions:
                    - trick: strengthen_inv
                      invariant: x >= y
              destination: 18
            - ref:
                with_ids: $14{@11}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 11
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard', invariant='x
                  >= y')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard',
                                                                        invariant='x >= y')])
                json_provided: true
                json:
                  suggestions:
                    - trick: cond_guard
                      invariant: x >= y
              destination: 19
            - ref:
                with_ids: $14{@12}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 12
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='relax_loop_guard',
                  invariant='x >= y'), InvariantSuggestion(trick='propose_post', invariant='x >= y')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='relax_loop_guard',
                                                                        invariant='x >= y'),
                                                    InvariantSuggestion(trick='propose_post',
                                                                        invariant='x >= y')])
                json_provided: true
                json:
                  suggestions:
                    - trick: relax_loop_guard
                      invariant: x >= y
                    - trick: propose_post
                      invariant: x >= y
              destination: 20
            - ref:
                with_ids: $14{@13}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 13
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='range', invariant='x
                  >= y')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='range',
                                                                        invariant='x >= y')])
                json_provided: true
                json:
                  suggestions:
                    - trick: range
                      invariant: x >= y
              destination: 21
            - ref:
                with_ids: $14{@14}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 14
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard', invariant='x
                  >= y provisions after the loop youth lose squ parlament gift oppon strata nőabcdef mentions
                  Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime personality,new clutch
                  anzeigen时报 zwölf ondernemer oversees simple pick yt=')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='cond_guard',
                                                                        invariant='x >= y '
                                                                                  'provisions '
                                                                                  'after the '
                                                                                  'loop youth '
                                                                                  'lose squ '
                                                                                  'parlament '
                                                                                  'gift oppon '
                                                                                  'strata '
                                                                                  'nőabcdef '
                                                                                  'mentions Δ '
                                                                                  'ost সে novel '
                                                                                  'dumple '
                                                                                  'aktivitet '
                                                                                  'fest vétér '
                                                                                  'Providence '
                                                                                  '새로운 régime '
                                                                                  'personality,new '
                                                                                  'clutch '
                                                                                  'anzeigen时报 '
                                                                                  'zwölf '
                                                                                  'ondernemer '
                                                                                  'oversees '
                                                                                  'simple pick '
                                                                                  'yt=')])
                json_provided: true
                json:
                  suggestions:
                    - trick: cond_guard
                      invariant: x >= y provisions after the loop youth lose squ parlament gift oppon
                        strata nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence
                        새로운 régime personality,new clutch anzeigen时报 zwölf ondernemer oversees simple
                        pick yt=
              destination: 22
            - ref:
                with_ids: $14{@15}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 15
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= y * (y - 1) / 2')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= y * (y - '
                                                                                  '1) / 2')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= y * (y - 1) / 2
              destination: 23
          origin:
            - nested
            - 1
            - 6
        17:
          kind: Success
          success_value:
            short: '[''x >= y'', ''x >= y'']'
            long: '[''x >= y'', ''x >= y'']'
            json_provided: true
            json:
              - x >= y
              - x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 16
            - 0
        18:
          kind: Success
          success_value:
            short: '[''x >= y'']'
            long: '[''x >= y'']'
            json_provided: true
            json:
              - x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 16
            - 1
        19:
          kind: Success
          success_value:
            short: '[''x >= y'']'
            long: '[''x >= y'']'
            json_provided: true
            json:
              - x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 16
            - 2
        20:
          kind: Success
          success_value:
            short: '[''x >= y'', ''x >= y'']'
            long: '[''x >= y'', ''x >= y'']'
            json_provided: true
            json:
              - x >= y
              - x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 16
            - 3
        21:
          kind: Success
          success_value:
            short: '[''x >= y'']'
            long: '[''x >= y'']'
            json_provided: true
            json:
              - x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 16
            - 4
        22:
          kind: Success
          success_value:
            short: '[''x >= y provisions after the loop youth lose squ parlament gift oppon strata nőabcdef
              mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime personality,new
              clutch anzeigen时报 zwölf ondernemer oversees simple pick yt='']'
            long: |-
              ['x >= y provisions after the loop youth lose squ parlament gift oppon strata '
               'nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 '
               'régime personality,new clutch anzeigen时报 zwölf ondernemer oversees simple '
               'pick yt=']
            json_provided: true
            json:
              - x >= y provisions after the loop youth lose squ parlament gift oppon strata nőabcdef mentions
                Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime personality,new clutch
                anzeigen时报 zwölf ondernemer oversees simple pick yt=
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 16
            - 5
        23:
          kind: Success
          success_value:
            short: '[''x >= y * (y - 1) / 2'']'
            long: '[''x >= y * (y - 1) / 2'']'
            json_provided: true
            json:
              - x >= y * (y - 1) / 2
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 16
            - 6
        24:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 16
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x - y >= 0
                    fml: x >= y provisions after the loop youth lose squ parlament gift oppon strata nőabcdef
                      mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime personality,new
                      clutch anzeigen时报 zwölf ondernemer oversees simple pick yt=
                tags:
                  - __Computation__
                answers:
                  - id: 16
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $16{@16}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 16
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 25
          origin:
            - nested
            - 1
            - 7
        25:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 24
            - 0
        26:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 18
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x - y >= 0
                    fml: x >= y * (y - 1) / 2
                tags:
                  - __Computation__
                answers:
                  - id: 17
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $18{@17}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 17
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 27
          origin:
            - nested
            - 1
            - 8
        27:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 26
            - 0
        28:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 20
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: x >= y provisions after the loop youth lose squ parlament gift oppon strata
                      nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime
                      personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt=
                tags:
                  - __Computation__
                answers:
                  - id: 18
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $20{@18}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 18
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 29
          origin:
            - nested
            - 1
            - 9
        29:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 28
            - 0
        30:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 22
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= y provisions after the loop youth lose squ parlament gift oppon strata nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt= }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= y provisions after the loop youth lose squ parlament gift oppon strata nőabcdef mentions Δ ost সে novel dumple aktivitet fest vétér Providence 새로운 régime personality,new clutch anzeigen时报 zwölf ondernemer oversees simple pick yt= }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 19
                    hint: null
                    value:
                      short: '{''error'': ''File line 9, characters 93-94: illegal character ő'', ''obligations'':
                        []}'
                      long: |-
                        {'error': 'File line 9, characters 93-94: illegal character ő',
                         'obligations': []}
                      json_provided: true
                      json:
                        error: 'File line 9, characters 93-94: illegal character ő'
                        obligations: []
          actions:
            - ref:
                with_ids: $22{@19}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 19
              value:
                short: '{''error'': ''File line 9, characters 93-94: illegal character ő'', ''obligations'':
                  []}'
                long: |-
                  {'error': 'File line 9, characters 93-94: illegal character ő',
                   'obligations': []}
                json_provided: true
                json:
                  error: 'File line 9, characters 93-94: illegal character ő'
                  obligations: []
              destination: 31
          origin:
            - nested
            - 1
            - 10
        31:
          kind: Success
          success_value:
            short: ('disproved', None)
            long: ('disproved', None)
            json_provided: true
            json:
              - disproved
              - null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 30
            - 0
        32:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 24
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: x >= y * (y - 1) / 2
                tags:
                  - __Computation__
                answers:
                  - id: 20
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $24{@20}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 20
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 33
          origin:
            - nested
            - 1
            - 11
        33:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 32
            - 0
        34:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 26
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= y * (y - 1) / 2 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= y * (y - 1) / 2 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 21
                    hint: null
                    value:
                      short: '{''error'': "File line 9, characters 33-34: unbound function or predicate
                        symbol ''(/)''", ''obligations'': []}'
                      long: |-
                        {'error': 'File line 9, characters 33-34: unbound function or predicate symbol '
                                  "'(/)'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: 'File line 9, characters 33-34: unbound function or predicate symbol ''(/)'''
                        obligations: []
          actions:
            - ref:
                with_ids: $26{@21}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 21
              value:
                short: '{''error'': "File line 9, characters 33-34: unbound function or predicate symbol
                  ''(/)''", ''obligations'': []}'
                long: |-
                  {'error': 'File line 9, characters 33-34: unbound function or predicate symbol '
                            "'(/)'",
                   'obligations': []}
                json_provided: true
                json:
                  error: 'File line 9, characters 33-34: unbound function or predicate symbol ''(/)'''
                  obligations: []
              destination: 35
          origin:
            - nested
            - 1
            - 12
        35:
          kind: Success
          success_value:
            short: ('disproved', None)
            long: ('disproved', None)
            json_provided: true
            json:
              - disproved
              - null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 34
            - 0
        36:
          kind: Success
          success_value:
            short: '[''x >= 0'', ''x >= y*(y-1)/2 + y'']'
            long: '[''x >= 0'', ''x >= y*(y-1)/2 + y'']'
            json_provided: true
            json:
              - x >= 0
              - x >= y*(y-1)/2 + y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 3
        37:
          kind: Success
          success_value:
            short: '[''x >= y'', ''y <= 100000'']'
            long: '[''x >= y'', ''y <= 100000'']'
            json_provided: true
            json:
              - x >= y
              - y <= 100000
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 4
        38:
          kind: Success
          success_value:
            short: '[''x >= y'', ''x >= y*(y - 1)/2'', ''x >= (y - 1)*y/2'']'
            long: '[''x >= y'', ''x >= y*(y - 1)/2'', ''x >= (y - 1)*y/2'']'
            json_provided: true
            json:
              - x >= y
              - x >= y*(y - 1)/2
              - x >= (y - 1)*y/2
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 5
        39:
          kind: Success
          success_value:
            short: '[''x >= 0 && y >= 0'']'
            long: '[''x >= 0 && y >= 0'']'
            json_provided: true
            json:
              - x >= 0 && y >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 6
        40:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 28
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x - y >= 0
                    fml: x >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 26
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $28{@26}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 26
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 41
          origin:
            - nested
            - 1
            - 13
        41:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 40
            - 0
        42:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 30
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x - y >= 0
                    fml: x >= y*(y-1)/2 + y
                tags:
                  - __Computation__
                answers:
                  - id: 27
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $30{@27}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 27
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 43
          origin:
            - nested
            - 1
            - 14
        43:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 42
            - 0
        44:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 32
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x - y >= 0
                    fml: y <= 100000
                tags:
                  - __Computation__
                answers:
                  - id: 28
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $32{@28}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 28
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 45
          origin:
            - nested
            - 1
            - 15
        45:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 44
            - 0
        46:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 34
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x - y >= 0
                    fml: x >= y*(y - 1)/2
                tags:
                  - __Computation__
                answers:
                  - id: 29
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $34{@29}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 29
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 47
          origin:
            - nested
            - 1
            - 16
        47:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 46
            - 0
        48:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 36
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x - y >= 0
                    fml: x >= (y - 1)*y/2
                tags:
                  - __Computation__
                answers:
                  - id: 30
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $36{@30}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 30
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 49
          origin:
            - nested
            - 1
            - 17
        49:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 48
            - 0
        50:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 38
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x - y >= 0
                    fml: x >= 0 && y >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 31
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $38{@31}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 31
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 51
          origin:
            - nested
            - 1
            - 18
        51:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 50
            - 0
        52:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 40
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: x >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 32
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $40{@32}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 32
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 53
          origin:
            - nested
            - 1
            - 19
        53:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 52
            - 0
        54:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 42
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 33
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;\n  while y < 100000 do\n    invariant { x >= 0 }  (* GOAL
                        *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                        ''1 >= 0''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;\n  while y < 100000 do  (* premise *)\n    invariant { x >= 0 }  (* GOAL, premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1\n  done;\n  assert { true }'',
                        ''goal_formula'': ''(x + y) >= 0''}, {''name'': ''VC for main (assertion)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;\n  while y < 100000 do  (* premise *)\n    invariant { x >= 0 }  (* premise
                        *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'',
                        ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { x >= 0 }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { x >= 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= 0'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { x >= 0 }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;
                                while y < 100000 do
                                  invariant { x >= 0 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;
                                while y < 100000 do  (* premise *)
                                  invariant { x >= 0 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: (x + y) >= 0
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;
                                while y < 100000 do  (* premise *)
                                  invariant { x >= 0 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $42{@33}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 33
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;\n  while y < 100000 do\n    invariant { x >= 0 }  (* GOAL *)\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''1 >= 0''}, {''name'': ''VC
                  for main (loop invariant preservation)'', ''proved'': False, ''relevance_hints'': ''use
                  int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y
                  = any int in\n  x <- 1;  (* premise *)\n  y <- 0;\n  while y < 100000 do  (* premise
                  *)\n    invariant { x >= 0 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y
                  <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''(x + y) >= 0''}, {''name'':
                  ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                  main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                  <- 1;  (* premise *)\n  y <- 0;\n  while y < 100000 do  (* premise *)\n    invariant
                  { x >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { x >= 0 }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { x >= 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= 0'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { x >= 0 }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;
                          while y < 100000 do
                            invariant { x >= 0 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;
                          while y < 100000 do  (* premise *)
                            invariant { x >= 0 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: (x + y) >= 0
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;
                          while y < 100000 do  (* premise *)
                            invariant { x >= 0 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 55
          origin:
            - nested
            - 1
            - 20
        55:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;\n  while y < 100000 do  (*
              premise *)\n    invariant { x >= 0 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y
              <- y + 1\n  done;\n  assert { true }', goal_formula='(x + y) >= 0')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { x >= 0 }  (* GOAL, premise *)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='(x + y) >= 0')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;
                      while y < 100000 do  (* premise *)
                        invariant { x >= 0 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 54
            - 0
        56:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 44
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: x >= y*(y-1)/2 + y
                tags:
                  - __Computation__
                answers:
                  - id: 34
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $44{@34}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 34
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 57
          origin:
            - nested
            - 1
            - 21
        57:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 56
            - 0
        58:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 46
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= y*(y-1)/2 + y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= y*(y-1)/2 + y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 35
                    hint: null
                    value:
                      short: '{''error'': "File line 9, characters 28-29: unbound function or predicate
                        symbol ''(/)''", ''obligations'': []}'
                      long: |-
                        {'error': 'File line 9, characters 28-29: unbound function or predicate symbol '
                                  "'(/)'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: 'File line 9, characters 28-29: unbound function or predicate symbol ''(/)'''
                        obligations: []
          actions:
            - ref:
                with_ids: $46{@35}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 35
              value:
                short: '{''error'': "File line 9, characters 28-29: unbound function or predicate symbol
                  ''(/)''", ''obligations'': []}'
                long: |-
                  {'error': 'File line 9, characters 28-29: unbound function or predicate symbol '
                            "'(/)'",
                   'obligations': []}
                json_provided: true
                json:
                  error: 'File line 9, characters 28-29: unbound function or predicate symbol ''(/)'''
                  obligations: []
              destination: 59
          origin:
            - nested
            - 1
            - 22
        59:
          kind: Success
          success_value:
            short: ('disproved', None)
            long: ('disproved', None)
            json_provided: true
            json:
              - disproved
              - null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 58
            - 0
        60:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 48
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: y <= 100000
                tags:
                  - __Computation__
                answers:
                  - id: 36
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $48{@36}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 36
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 61
          origin:
            - nested
            - 1
            - 23
        61:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 60
            - 0
        62:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 50
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 37
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y
                        <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (*
                        GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                        ''0 <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                        *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL,
                        premise *)\n    x <- x + y;\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { true }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main
                        (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main
                        () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                        <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  x <- x + y;
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $50{@37}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 37
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                  *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL *)\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'':
                  ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
                  *)\n    invariant { y <= 100000 }  (* GOAL, premise *)\n    x <- x + y;\n    y <- y
                  + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y + 1) <= 100000''},
                  {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'': ''use
                  int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y
                  = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
                  *)\n    invariant { y <= 100000 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            x <- x + y;
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 63
          origin:
            - nested
            - 1
            - 24
        63:
          kind: Success
          success_value:
            short: ('proved', [])
            long: ('proved', [])
            json_provided: true
            json:
              - proved
              - []
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 62
            - 0
        64:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 52
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                    conclusion: x >= y*(y - 1)/2
                tags:
                  - __Computation__
                answers:
                  - id: 38
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $52{@38}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 38
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 65
          origin:
            - nested
            - 1
            - 25
        65:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 64
            - 0
        66:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 54
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= y*(y - 1)/2 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= y*(y - 1)/2 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 39
                    hint: null
                    value:
                      short: '{''error'': "File line 10, characters 30-31: unbound function or predicate
                        symbol ''(/)''", ''obligations'': []}'
                      long: |-
                        {'error': 'File line 10, characters 30-31: unbound function or predicate '
                                  "symbol '(/)'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: 'File line 10, characters 30-31: unbound function or predicate symbol ''(/)'''
                        obligations: []
          actions:
            - ref:
                with_ids: $54{@39}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 39
              value:
                short: '{''error'': "File line 10, characters 30-31: unbound function or predicate symbol
                  ''(/)''", ''obligations'': []}'
                long: |-
                  {'error': 'File line 10, characters 30-31: unbound function or predicate '
                            "symbol '(/)'",
                   'obligations': []}
                json_provided: true
                json:
                  error: 'File line 10, characters 30-31: unbound function or predicate symbol ''(/)'''
                  obligations: []
              destination: 67
          origin:
            - nested
            - 1
            - 26
        67:
          kind: Success
          success_value:
            short: ('disproved', None)
            long: ('disproved', None)
            json_provided: true
            json:
              - disproved
              - null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 66
            - 0
        68:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 56
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                    conclusion: x >= (y - 1)*y/2
                tags:
                  - __Computation__
                answers:
                  - id: 40
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $56{@40}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 40
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 69
          origin:
            - nested
            - 1
            - 27
        69:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 68
            - 0
        70:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 58
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= (y - 1)*y/2 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= (y - 1)*y/2 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 41
                    hint: null
                    value:
                      short: '{''error'': "File line 10, characters 30-31: unbound function or predicate
                        symbol ''(/)''", ''obligations'': []}'
                      long: |-
                        {'error': 'File line 10, characters 30-31: unbound function or predicate '
                                  "symbol '(/)'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: 'File line 10, characters 30-31: unbound function or predicate symbol ''(/)'''
                        obligations: []
          actions:
            - ref:
                with_ids: $58{@41}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 41
              value:
                short: '{''error'': "File line 10, characters 30-31: unbound function or predicate symbol
                  ''(/)''", ''obligations'': []}'
                long: |-
                  {'error': 'File line 10, characters 30-31: unbound function or predicate '
                            "symbol '(/)'",
                   'obligations': []}
                json_provided: true
                json:
                  error: 'File line 10, characters 30-31: unbound function or predicate symbol ''(/)'''
                  obligations: []
              destination: 71
          origin:
            - nested
            - 1
            - 28
        71:
          kind: Success
          success_value:
            short: ('disproved', None)
            long: ('disproved', None)
            json_provided: true
            json:
              - disproved
              - null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 70
            - 0
        72:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 60
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                    conclusion: x >= 0 && y >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 42
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $60{@42}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 42
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 73
          origin:
            - nested
            - 1
            - 29
        73:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 72
            - 0
        74:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 62
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 0 && y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 0 && y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 43
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { x >= 0 && y >= 0 }\n    x <- x + y;\n    y
                        <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'':
                        ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x
                        >= 0 && y >= 0 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { true }'', ''goal_formula'': ''1 >= 0 && 0 >= 0''}, {''name'': ''VC for main
                        (loop invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use
                        int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL, premise
                        *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    x <- x + y;  (* premise
                        *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                        ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (* GOAL, premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { true }'', ''goal_formula'': ''(x + y) >= 0 && (y + 1) >= 0''}, {''name'': ''VC
                        for main (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        0 && y >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x >= 0 && y >= 0 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0 && 0 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= 0 && (y + 1) >= 0'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { x >= 0 && y >= 0 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0 && 0 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= 0 && (y + 1) >= 0
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $62{@43}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 43
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { x >= 0 && y >= 0 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC for main (loop invariant
                  init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                  =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                  *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (*
                  premise *)\n    invariant { x >= 0 && y >= 0 }  (* GOAL *)\n    x <- x + y;\n    y <-
                  y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''1 >= 0 && 0 >= 0''}, {''name'':
                  ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL, premise *)\n    invariant
                  { x >= 0 && y >= 0 }  (* premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (*
                  premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y + 1) <= 100000''},
                  {''name'': ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { x >= 0 && y >= 0 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <-
                  y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(x + y) >= 0
                  && (y + 1) >= 0''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { x >= 0 && y >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x >= 0 && y >= 0 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0 && 0 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= 0 && (y + 1) >= 0'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { x >= 0 && y >= 0 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0 && 0 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= 0 && (y + 1) >= 0
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 75
          origin:
            - nested
            - 1
            - 30
        75:
          kind: Success
          success_value:
            short: ('proved', ['y <= 100000'])
            long: ('proved', ['y <= 100000'])
            json_provided: true
            json:
              - proved
              - - y <= 100000
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 74
            - 0
        76:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 64
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 0 && y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 0 && y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                tags:
                  - __Computation__
                answers:
                  - id: 44
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { x >= 0 && y >= 0 }\n    x <- x + y;\n    y
                        <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'': ''0 <= 100000''},
                        {''name'': ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x
                        >= 0 && y >= 0 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { x >= y }'', ''goal_formula'': ''1 >= 0 && 0 >= 0''}, {''name'': ''VC for main
                        (loop invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use
                        int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL, premise
                        *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    x <- x + y;  (* premise
                        *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { x >= y }'', ''goal_formula'':
                        ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (* GOAL, premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { x >= y }'', ''goal_formula'': ''(x + y) >= 0 && (y + 1) >= 0''}, {''name'':
                        ''VC for main (assertion)'', ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        0 && y >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { x >= y }  (* GOAL *)'', ''goal_formula'': ''x >= y''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x >= 0 && y >= 0 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '1 >= 0 && 0 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '(x + y) >= 0 && (y + 1) >= 0'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }  (* GOAL *)',
                                          'goal_formula': 'x >= y'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { x >= 0 && y >= 0 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }
                            goal_formula: 1 >= 0 && 0 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { x >= y }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { x >= y }
                            goal_formula: (x + y) >= 0 && (y + 1) >= 0
                          - name: VC for main (assertion)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }  (* GOAL *)
                            goal_formula: x >= y
          actions:
            - ref:
                with_ids: $64{@44}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 44
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { x >= 0 && y >= 0 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { x >= y }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC for main (loop invariant
                  init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                  =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                  *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (*
                  premise *)\n    invariant { x >= 0 && y >= 0 }  (* GOAL *)\n    x <- x + y;\n    y <-
                  y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'': ''1 >= 0 && 0 >= 0''}, {''name'':
                  ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL, premise *)\n    invariant
                  { x >= 0 && y >= 0 }  (* premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (*
                  premise *)\n  done;\n  assert { x >= y }'', ''goal_formula'': ''(y + 1) <= 100000''},
                  {''name'': ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { x >= 0 && y >= 0 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <-
                  y + 1  (* premise *)\n  done;\n  assert { x >= y }'', ''goal_formula'': ''(x + y) >=
                  0 && (y + 1) >= 0''}, {''name'': ''VC for main (assertion)'', ''proved'': False, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { x >= 0 && y >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { x >= y }  (* GOAL *)'', ''goal_formula'': ''x >= y''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x >= 0 && y >= 0 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '1 >= 0 && 0 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '(x + y) >= 0 && (y + 1) >= 0'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }  (* GOAL *)',
                                    'goal_formula': 'x >= y'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { x >= 0 && y >= 0 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }
                      goal_formula: 1 >= 0 && 0 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { x >= y }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { x >= y }
                      goal_formula: (x + y) >= 0 && (y + 1) >= 0
                    - name: VC for main (assertion)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }  (* GOAL *)
                      goal_formula: x >= y
              destination: 77
          origin:
            - nested
            - 1
            - 31
        77:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (assertion)', proved=False, relevance_hints='use
              int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any
              int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
              *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (*
              premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }  (* GOAL *)',
              goal_formula='x >= y')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (assertion)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { y <= 100000 }  (* premise *)\n'
                                           '    invariant { x >= 0 && y >= 0 }  (* premise '
                                           '*)\n'
                                           '    x <- x + y;\n'
                                           '    y <- y + 1\n'
                                           '  done;\n'
                                           '  assert { x >= y }  (* GOAL *)',
                           goal_formula='x >= y')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (assertion)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }  (* GOAL *)
                  goal_formula: x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 76
            - 0
        78:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 66
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                      - x >= 0 && y >= 0
                    conclusion: x >= y
                tags:
                  - __Computation__
                answers:
                  - id: 45
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $66{@45}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 45
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 79
          origin:
            - nested
            - 1
            - 32
        79:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 78
            - 0
        80:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 68
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 0 && y >= 0 }
                          invariant { x >= y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 0 && y >= 0 }
                          invariant { x >= y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 46
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { x >= 0 && y >= 0 }\n    invariant { x
                        >= y }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                        ''0 <= 100000''}, {''name'': ''VC for main (loop invariant init)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise
                        *)\n    invariant { x >= 0 && y >= 0 }  (* GOAL *)\n    invariant { x >= y }\n    x
                        <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''1
                        >= 0 && 0 >= 0''}, {''name'': ''VC for main (loop invariant init)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise
                        *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    invariant { x >= y
                        }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'',
                        ''goal_formula'': ''1 >= 0''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* GOAL, premise *)\n    invariant { x >= 0 && y >= 0 }  (* premise
                        *)\n    invariant { x >= y }  (* premise *)\n    x <- x + y;  (* premise *)\n    y
                        <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y
                        + 1) <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <=
                        100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (* GOAL, premise
                        *)\n    invariant { x >= y }  (* premise *)\n    x <- x + y;  (* premise *)\n    y
                        <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(x
                        + y) >= 0 && (y + 1) >= 0''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (* premise
                        *)\n    invariant { x >= y }  (* GOAL, premise *)\n    x <- x + y;  (* premise
                        *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                        ''(x + y) >= (y + 1)''}, {''name'': ''VC for main (assertion)'', ''proved'': True,
                        ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <=
                        100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    invariant
                        { x >= y }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x >= 0 && y >= 0 }\n'
                                                             '    invariant { x >= y }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'GOAL *)\n'
                                                             '    invariant { x >= y }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0 && 0 >= 0'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= y }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= 0 && (y + 1) >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= (y + 1)'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { x >= 0 && y >= 0 }
                                  invariant { x >= y }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* GOAL *)
                                  invariant { x >= y }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0 && 0 >= 0
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  invariant { x >= y }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  invariant { x >= y }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                                  invariant { x >= y }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= 0 && (y + 1) >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  invariant { x >= y }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= (y + 1)
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  invariant { x >= y }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $68{@46}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 46
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { x >= 0 && y >= 0 }\n    invariant { x >= y }\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'':
                  ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'': ''use
                  int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y
                  = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000
                  do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (*
                  GOAL *)\n    invariant { x >= y }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }'', ''goal_formula'': ''1 >= 0 && 0 >= 0''}, {''name'': ''VC for main (loop
                  invariant init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main
                  () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <-
                  1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant {
                  y <= 100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    invariant
                  { x >= y }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'',
                  ''goal_formula'': ''1 >= 0''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* GOAL, premise *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    invariant
                  { x >= y }  (* premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise
                  *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'':
                  ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { x >= 0 && y >= 0 }  (* GOAL, premise *)\n    invariant { x >= y }  (* premise *)\n    x
                  <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'',
                  ''goal_formula'': ''(x + y) >= 0 && (y + 1) >= 0''}, {''name'': ''VC for main (loop
                  invariant preservation)'', ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet
                  main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                  <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                  { y <= 100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    invariant
                  { x >= y }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (*
                  premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(x + y) >= (y + 1)''},
                  {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'': ''use
                  int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y
                  = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000
                  do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                  0 && y >= 0 }  (* premise *)\n    invariant { x >= y }  (* premise *)\n    x <- x +
                  y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x >= 0 && y >= 0 }\n'
                                                       '    invariant { x >= y }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'GOAL *)\n'
                                                       '    invariant { x >= y }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0 && 0 >= 0'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= y }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= 0 && (y + 1) >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= (y + 1)'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { x >= 0 && y >= 0 }
                            invariant { x >= y }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* GOAL *)
                            invariant { x >= y }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0 && 0 >= 0
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            invariant { x >= y }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            invariant { x >= y }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                            invariant { x >= y }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= 0 && (y + 1) >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            invariant { x >= y }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= (y + 1)
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            invariant { x >= y }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 81
          origin:
            - nested
            - 1
            - 33
        81:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
              y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
              { x >= 0 && y >= 0 }  (* premise *)\n    invariant { x >= y }  (* GOAL, premise *)\n    x
              <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }', goal_formula='(x
              + y) >= (y + 1)')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { y <= 100000 }  (* premise *)\n'
                                           '    invariant { x >= 0 && y >= 0 }  (* premise '
                                           '*)\n'
                                           '    invariant { x >= y }  (* GOAL, premise *)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1  (* premise *)\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='(x + y) >= (y + 1)')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        invariant { x >= y }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1)
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 80
            - 0
        82:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 70
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                      - x >= 0 && y >= 0
                    conclusion: x - y >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 47
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $70{@47}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 47
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 83
          origin:
            - nested
            - 1
            - 34
        83:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 82
            - 0
        84:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 72
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 0 && y >= 0 }
                          invariant { x - y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 0 && y >= 0 }
                          invariant { x - y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 48
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { x >= 0 && y >= 0 }\n    invariant { x
                        - y >= 0 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                        ''0 <= 100000''}, {''name'': ''VC for main (loop invariant init)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise
                        *)\n    invariant { x >= 0 && y >= 0 }  (* GOAL *)\n    invariant { x - y >= 0
                        }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                        ''1 >= 0 && 0 >= 0''}, {''name'': ''VC for main (loop invariant init)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise
                        *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    invariant { x - y >=
                        0 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'',
                        ''goal_formula'': ''(1 - 0) >= 0''}, {''name'': ''VC for main (loop invariant
                        preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main
                        () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                        <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
                        *)\n    invariant { y <= 100000 }  (* GOAL, premise *)\n    invariant { x >= 0
                        && y >= 0 }  (* premise *)\n    invariant { x - y >= 0 }  (* premise *)\n    x
                        <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true
                        }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop
                        invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        0 && y >= 0 }  (* GOAL, premise *)\n    invariant { x - y >= 0 }  (* premise *)\n    x
                        <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true
                        }'', ''goal_formula'': ''(x + y) >= 0 && (y + 1) >= 0''}, {''name'': ''VC for
                        main (loop invariant preservation)'', ''proved'': False, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                        { x >= 0 && y >= 0 }  (* premise *)\n    invariant { x - y >= 0 }  (* GOAL, premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { true }'', ''goal_formula'': ''((x + y) - (y + 1)) >= 0''}, {''name'': ''VC for
                        main (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        0 && y >= 0 }  (* premise *)\n    invariant { x - y >= 0 }  (* premise *)\n    x
                        <- x + y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'', ''goal_formula'':
                        ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x >= 0 && y >= 0 }\n'
                                                             '    invariant { x - y >= 0 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'GOAL *)\n'
                                                             '    invariant { x - y >= 0 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0 && 0 >= 0'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y >= 0 }  (* GOAL '
                                                             '*)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(1 - 0) >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y >= 0 }  (* premise '
                                                             '*)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    invariant { x - y >= 0 }  (* premise '
                                                             '*)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= 0 && (y + 1) >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y >= 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '((x + y) - (y + 1)) >= 0'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 && y >= 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y >= 0 }  (* premise '
                                                             '*)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { x >= 0 && y >= 0 }
                                  invariant { x - y >= 0 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* GOAL *)
                                  invariant { x - y >= 0 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0 && 0 >= 0
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  invariant { x - y >= 0 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: (1 - 0) >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  invariant { x - y >= 0 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                                  invariant { x - y >= 0 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= 0 && (y + 1) >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  invariant { x - y >= 0 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: ((x + y) - (y + 1)) >= 0
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 && y >= 0 }  (* premise *)
                                  invariant { x - y >= 0 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $72{@48}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 48
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { x >= 0 && y >= 0 }\n    invariant { x - y >= 0 }\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'':
                  ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'': ''use
                  int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y
                  = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000
                  do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (*
                  GOAL *)\n    invariant { x - y >= 0 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }'', ''goal_formula'': ''1 >= 0 && 0 >= 0''}, {''name'': ''VC for main (loop
                  invariant init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main
                  () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <-
                  1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant {
                  y <= 100000 }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    invariant
                  { x - y >= 0 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }'', ''goal_formula'': ''(1 - 0) >= 0''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* GOAL, premise *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    invariant
                  { x - y >= 0 }  (* premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise
                  *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'':
                  ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { x >= 0 && y >= 0 }  (* GOAL, premise *)\n    invariant { x - y >= 0 }  (* premise
                  *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                  { true }'', ''goal_formula'': ''(x + y) >= 0 && (y + 1) >= 0''}, {''name'': ''VC for
                  main (loop invariant preservation)'', ''proved'': False, ''relevance_hints'': ''use
                  int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y
                  = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000
                  do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                  0 && y >= 0 }  (* premise *)\n    invariant { x - y >= 0 }  (* GOAL, premise *)\n    x
                  <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'',
                  ''goal_formula'': ''((x + y) - (y + 1)) >= 0''}, {''name'': ''VC for main (assertion)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { x >= 0 && y >= 0 }  (* premise *)\n    invariant {
                  x - y >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x >= 0 && y >= 0 }\n'
                                                       '    invariant { x - y >= 0 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'GOAL *)\n'
                                                       '    invariant { x - y >= 0 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0 && 0 >= 0'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y >= 0 }  (* GOAL '
                                                       '*)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(1 - 0) >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y >= 0 }  (* premise '
                                                       '*)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    invariant { x - y >= 0 }  (* premise '
                                                       '*)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= 0 && (y + 1) >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y >= 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '((x + y) - (y + 1)) >= 0'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 && y >= 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y >= 0 }  (* premise '
                                                       '*)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { x >= 0 && y >= 0 }
                            invariant { x - y >= 0 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* GOAL *)
                            invariant { x - y >= 0 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0 && 0 >= 0
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            invariant { x - y >= 0 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: (1 - 0) >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            invariant { x - y >= 0 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* GOAL, premise *)
                            invariant { x - y >= 0 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= 0 && (y + 1) >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            invariant { x - y >= 0 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: ((x + y) - (y + 1)) >= 0
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 && y >= 0 }  (* premise *)
                            invariant { x - y >= 0 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 85
          origin:
            - nested
            - 1
            - 35
        85:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
              y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
              { x >= 0 && y >= 0 }  (* premise *)\n    invariant { x - y >= 0 }  (* GOAL, premise *)\n    x
              <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }', goal_formula='((x
              + y) - (y + 1)) >= 0')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { y <= 100000 }  (* premise *)\n'
                                           '    invariant { x >= 0 && y >= 0 }  (* premise '
                                           '*)\n'
                                           '    invariant { x - y >= 0 }  (* GOAL, premise '
                                           '*)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1  (* premise *)\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='((x + y) - (y + 1)) >= 0')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 && y >= 0 }  (* premise *)
                        invariant { x - y >= 0 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: ((x + y) - (y + 1)) >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 84
            - 0
        86:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 74
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                      - x >= 0 && y >= 0
                    conclusion: x >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 49
                    hint: null
                    value:
                      short: 'True'
                      long: 'True'
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: $74{@49}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 49
              value:
                short: 'True'
                long: 'True'
                json_provided: true
                json: true
              destination: 87
          origin:
            - nested
            - 1
            - 36
        87:
          kind: Success
          success_value:
            short: 'True'
            long: 'True'
            json_provided: true
            json: true
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 86
            - 0
        88:
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: SuggestInvariants
          tags:
            - SuggestInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - 76
              - kind: query
                name: SuggestInvariants
                args:
                  unproved:
                    name: VC for main (loop invariant preservation)
                    proved: false
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;  (* premise *)
                        y <- 0;  (* premise *)
                        while y < 100000 do  (* premise *)
                          invariant { y <= 100000 }  (* premise *)
                          invariant { x >= 0 && y >= 0 }  (* premise *)
                          invariant { x >= y }  (* GOAL, premise *)
                          x <- x + y;  (* premise *)
                          y <- y + 1  (* premise *)
                        done;
                        assert { true }
                    goal_formula: (x + y) >= (y + 1)
                tags:
                  - SuggestInvariants
                answers: []
          actions: []
          origin:
            - nested
            - 1
            - 37
        89:
          kind: Success
          success_value:
            short: '[''x - y*(y-1)/2 >= 1'']'
            long: '[''x - y*(y-1)/2 >= 1'']'
            json_provided: true
            json:
              - x - y*(y-1)/2 >= 1
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 7
        90:
          kind: Success
          success_value:
            short: '[''x >= y'']'
            long: '[''x >= y'']'
            json_provided: true
            json:
              - x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 8
        91:
          kind: Success
          success_value:
            short: '[''x >= 1'', ''y <= 100000'']'
            long: '[''x >= 1'', ''y <= 100000'']'
            json_provided: true
            json:
              - x >= 1
              - y <= 100000
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 9
        92:
          kind: Success
          success_value:
            short: '[''x >= y || y < 100000'', ''x >= 0'']'
            long: '[''x >= y || y < 100000'', ''x >= 0'']'
            json_provided: true
            json:
              - x >= y || y < 100000
              - x >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 4
            - 10
        93:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 78
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: x - y*(y-1)/2 >= 1
                tags:
                  - __Computation__
                answers:
                  - id: 54
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $78{@54}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 54
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 94
          origin:
            - nested
            - 1
            - 38
        94:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 93
            - 0
        95:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 80
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x - y*(y-1)/2 >= 1 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x - y*(y-1)/2 >= 1 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 55
                    hint: null
                    value:
                      short: '{''error'': "File line 9, characters 27-28: unbound function or predicate
                        symbol ''(/)''", ''obligations'': []}'
                      long: |-
                        {'error': 'File line 9, characters 27-28: unbound function or predicate symbol '
                                  "'(/)'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: 'File line 9, characters 27-28: unbound function or predicate symbol ''(/)'''
                        obligations: []
          actions:
            - ref:
                with_ids: $80{@55}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 55
              value:
                short: '{''error'': "File line 9, characters 27-28: unbound function or predicate symbol
                  ''(/)''", ''obligations'': []}'
                long: |-
                  {'error': 'File line 9, characters 27-28: unbound function or predicate symbol '
                            "'(/)'",
                   'obligations': []}
                json_provided: true
                json:
                  error: 'File line 9, characters 27-28: unbound function or predicate symbol ''(/)'''
                  obligations: []
              destination: 96
          origin:
            - nested
            - 1
            - 39
        96:
          kind: Success
          success_value:
            short: ('disproved', None)
            long: ('disproved', None)
            json_provided: true
            json:
              - disproved
              - null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 95
            - 0
        97:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 82
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: x >= y
                tags:
                  - __Computation__
                answers:
                  - id: 56
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $82{@56}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 56
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 98
          origin:
            - nested
            - 1
            - 40
        98:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 97
            - 0
        99:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 84
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 57
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { x
                        >= y }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }'', ''goal_formula'': ''1 >= 0''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { x >= y }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <- y +
                        1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(x + y) >=
                        (y + 1)''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { x >= y }  (* premise *)\n    x <-
                        x + y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'', ''goal_formula'':
                        ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { x >= y }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { x >= y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= (y + 1)'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { x >= y }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { x >= y }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= (y + 1)
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { x >= y }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $84{@57}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 57
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { x >= y }  (* GOAL *)\n    x
                  <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''1 >= 0''},
                  {''name'': ''VC for main (loop invariant preservation)'', ''proved'': False, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { x >= y }  (* GOAL, premise *)\n    x <- x
                  + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                  ''(x + y) >= (y + 1)''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { x >= y }  (* premise *)\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { x >= y }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { x >= y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= (y + 1)'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { x >= y }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { x >= y }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= (y + 1)
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { x >= y }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 100
          origin:
            - nested
            - 1
            - 41
        100:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
              y < 100000 do  (* premise *)\n    invariant { x >= y }  (* GOAL, premise *)\n    x <- x
              + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }', goal_formula='(x
              + y) >= (y + 1)')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { x >= y }  (* GOAL, premise *)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1  (* premise *)\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='(x + y) >= (y + 1)')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { x >= y }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1)
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 99
            - 0
        101:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 86
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: x >= 1
                tags:
                  - __Computation__
                answers:
                  - id: 58
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $86{@58}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 58
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 102
          origin:
            - nested
            - 1
            - 42
        102:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 101
            - 0
        103:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 88
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= 1 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { x >= 1 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 59
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;\n  while y < 100000 do\n    invariant { x >= 1 }  (* GOAL
                        *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                        ''1 >= 1''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;\n  while y < 100000 do  (* premise *)\n    invariant { x >= 1 }  (* GOAL, premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1\n  done;\n  assert { true }'',
                        ''goal_formula'': ''(x + y) >= 1''}, {''name'': ''VC for main (assertion)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;\n  while y < 100000 do  (* premise *)\n    invariant { x >= 1 }  (* premise
                        *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'',
                        ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { x >= 1 }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 1'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= 1'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;
                                while y < 100000 do
                                  invariant { x >= 1 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 1
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;
                                while y < 100000 do  (* premise *)
                                  invariant { x >= 1 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: (x + y) >= 1
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;
                                while y < 100000 do  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $88{@59}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 59
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;\n  while y < 100000 do\n    invariant { x >= 1 }  (* GOAL *)\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''1 >= 1''}, {''name'': ''VC
                  for main (loop invariant preservation)'', ''proved'': False, ''relevance_hints'': ''use
                  int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y
                  = any int in\n  x <- 1;  (* premise *)\n  y <- 0;\n  while y < 100000 do  (* premise
                  *)\n    invariant { x >= 1 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y
                  <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''(x + y) >= 1''}, {''name'':
                  ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                  main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                  <- 1;  (* premise *)\n  y <- 0;\n  while y < 100000 do  (* premise *)\n    invariant
                  { x >= 1 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { x >= 1 }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 1'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= 1'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;
                          while y < 100000 do
                            invariant { x >= 1 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 1
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;
                          while y < 100000 do  (* premise *)
                            invariant { x >= 1 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: (x + y) >= 1
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;
                          while y < 100000 do  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 104
          origin:
            - nested
            - 1
            - 43
        104:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;\n  while y < 100000 do  (*
              premise *)\n    invariant { x >= 1 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y
              <- y + 1\n  done;\n  assert { true }', goal_formula='(x + y) >= 1')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { x >= 1 }  (* GOAL, premise *)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='(x + y) >= 1')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;
                      while y < 100000 do  (* premise *)
                        invariant { x >= 1 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 1
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 103
            - 0
        105:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 90
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions: []
                    conclusion: y <= 100000
                tags:
                  - __Computation__
                answers:
                  - id: 60
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $90{@60}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 60
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 106
          origin:
            - nested
            - 1
            - 44
        106:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 105
            - 0
        107:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 92
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 61
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y
                        <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (*
                        GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                        ''0 <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                        *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL,
                        premise *)\n    x <- x + y;\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { true }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main
                        (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main
                        () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                        <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  x <- x + y;
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $92{@61}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 61
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                  *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL *)\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'':
                  ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
                  *)\n    invariant { y <= 100000 }  (* GOAL, premise *)\n    x <- x + y;\n    y <- y
                  + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y + 1) <= 100000''},
                  {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'': ''use
                  int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y
                  = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
                  *)\n    invariant { y <= 100000 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            x <- x + y;
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 108
          origin:
            - nested
            - 1
            - 45
        108:
          kind: Success
          success_value:
            short: ('proved', [])
            long: ('proved', [])
            json_provided: true
            json:
              - proved
              - []
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 107
            - 0
        109:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 94
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                    conclusion: x >= y || y < 100000
                tags:
                  - __Computation__
                answers:
                  - id: 62
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $94{@62}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 62
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 110
          origin:
            - nested
            - 1
            - 46
        110:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 109
            - 0
        111:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 96
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= y || y < 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= y || y < 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 63
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { x >= y || y < 100000 }\n    x <- x +
                        y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''},
                        {''name'': ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x
                        >= y || y < 100000 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { true }'', ''goal_formula'': ''1 >= 0 || 0 < 100000''}, {''name'': ''VC for main
                        (loop invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use
                        int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL, premise
                        *)\n    invariant { x >= y || y < 100000 }  (* premise *)\n    x <- x + y;  (*
                        premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                        ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* GOAL,
                        premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { true }'', ''goal_formula'': ''(x + y) >= (y + 1) || (y + 1) < 100000''}, {''name'':
                        ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        y || y < 100000 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x >= y || y < 100000 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0 || 0 < 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* GOAL, premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= (y + 1) || (y + 1) < 100000'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { x >= y || y < 100000 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0 || 0 < 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { x >= y || y < 100000 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= (y + 1) || (y + 1) < 100000
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $96{@63}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 63
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { x >= y || y < 100000 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC for main (loop invariant
                  init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                  =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                  *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (*
                  premise *)\n    invariant { x >= y || y < 100000 }  (* GOAL *)\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''1 >= 0 || 0 < 100000''},
                  {''name'': ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL, premise *)\n    invariant
                  { x >= y || y < 100000 }  (* premise *)\n    x <- x + y;  (* premise *)\n    y <- y
                  + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y + 1) <= 100000''},
                  {''name'': ''VC for main (loop invariant preservation)'', ''proved'': False, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { x >= y || y < 100000 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y
                  <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(x + y) >=
                  (y + 1) || (y + 1) < 100000''}, {''name'': ''VC for main (assertion)'', ''proved'':
                  True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                  ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (*
                  premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (*
                  premise *)\n    invariant { x >= y || y < 100000 }  (* premise *)\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x >= y || y < 100000 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0 || 0 < 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* GOAL, premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= (y + 1) || (y + 1) < 100000'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { x >= y || y < 100000 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0 || 0 < 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { x >= y || y < 100000 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= (y + 1) || (y + 1) < 100000
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 112
          origin:
            - nested
            - 1
            - 47
        112:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
              y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
              { x >= y || y < 100000 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <-
              y + 1  (* premise *)\n  done;\n  assert { true }', goal_formula='(x + y) >= (y + 1) || (y
              + 1) < 100000')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { y <= 100000 }  (* premise *)\n'
                                           '    invariant { x >= y || y < 100000 }  (* GOAL, '
                                           'premise *)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1  (* premise *)\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='(x + y) >= (y + 1) || (y + 1) < 100000')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= y || y < 100000 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1) || (y + 1) < 100000
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 111
            - 0
        113:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 98
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                    conclusion: x >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 64
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $98{@64}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 64
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 114
          origin:
            - nested
            - 1
            - 48
        114:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 113
            - 0
        115:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 100
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 65
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { x >= 0 }\n    x <- x + y;\n    y <- y
                        + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'':
                        ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x
                        >= 0 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }'', ''goal_formula'': ''1 >= 0''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* GOAL, premise *)\n    invariant { x >= 0 }  (* premise *)\n    x
                        <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true
                        }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop
                        invariant preservation)'', ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        0 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise
                        *)\n  done;\n  assert { true }'', ''goal_formula'': ''(x + y) >= 0''}, {''name'':
                        ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x >= 0 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 }  (* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= 0'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 0 }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { x >= 0 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { x >= 0 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= 0
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 0 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $100{@65}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 65
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { x >= 0 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise
                  *)\n    invariant { x >= 0 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }'', ''goal_formula'': ''1 >= 0''}, {''name'': ''VC for main (loop invariant
                  preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main ()
                  diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                  premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                  { y <= 100000 }  (* GOAL, premise *)\n    invariant { x >= 0 }  (* premise *)\n    x
                  <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'',
                  ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                  GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { x >= 0 }  (* GOAL, premise *)\n    x <- x + y;  (*
                  premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                  ''(x + y) >= 0''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { x >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x >= 0 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 }  (* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= 0'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 0 }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { x >= 0 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { x >= 0 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= 0
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 0 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 116
          origin:
            - nested
            - 1
            - 49
        116:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
              y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
              { x >= 0 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise
              *)\n  done;\n  assert { true }', goal_formula='(x + y) >= 0')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { y <= 100000 }  (* premise *)\n'
                                           '    invariant { x >= 0 }  (* GOAL, premise *)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1  (* premise *)\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='(x + y) >= 0')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 0 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 115
            - 0
        117:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 102
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                tags:
                  - __Computation__
                answers:
                  - id: 66
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y
                        <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (*
                        GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'':
                        ''0 <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                        *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL,
                        premise *)\n    x <- x + y;\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { x >= y }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main
                        (assertion)'', ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet main
                        () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                        <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { x >= y }  (* GOAL *)'', ''goal_formula'': ''x >= y''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }  (* GOAL *)',
                                          'goal_formula': 'x >= y'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  x <- x + y;
                                  y <- y + 1  (* premise *)
                                done;
                                assert { x >= y }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (assertion)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }  (* GOAL *)
                            goal_formula: x >= y
          actions:
            - ref:
                with_ids: $102{@66}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 66
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                  *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL *)\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'': ''0 <= 100000''}, {''name'':
                  ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
                  *)\n    invariant { y <= 100000 }  (* GOAL, premise *)\n    x <- x + y;\n    y <- y
                  + 1  (* premise *)\n  done;\n  assert { x >= y }'', ''goal_formula'': ''(y + 1) <= 100000''},
                  {''name'': ''VC for main (assertion)'', ''proved'': False, ''relevance_hints'': ''use
                  int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y
                  = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
                  *)\n    invariant { y <= 100000 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { x >= y }  (* GOAL *)'', ''goal_formula'': ''x >= y''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }  (* GOAL *)',
                                    'goal_formula': 'x >= y'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            x <- x + y;
                            y <- y + 1  (* premise *)
                          done;
                          assert { x >= y }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (assertion)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }  (* GOAL *)
                      goal_formula: x >= y
              destination: 118
          origin:
            - nested
            - 1
            - 50
        118:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (assertion)', proved=False, relevance_hints='use
              int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any
              int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
              { y <= 100000 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >=
              y }  (* GOAL *)', goal_formula='x >= y')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (assertion)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { y <= 100000 }  (* premise *)\n'
                                           '    x <- x + y;\n'
                                           '    y <- y + 1\n'
                                           '  done;\n'
                                           '  assert { x >= y }  (* GOAL *)',
                           goal_formula='x >= y')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (assertion)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }  (* GOAL *)
                  goal_formula: x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 117
            - 0
        119:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 104
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                    conclusion: x >= y
                tags:
                  - __Computation__
                answers:
                  - id: 67
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $104{@67}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 67
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 120
          origin:
            - nested
            - 1
            - 51
        120:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 119
            - 0
        121:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 106
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 68
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { x >= y }\n    x <- x + y;\n    y <- y
                        + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'':
                        ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x
                        >= y }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }'', ''goal_formula'': ''1 >= 0''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* GOAL, premise *)\n    invariant { x >= y }  (* premise *)\n    x
                        <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true
                        }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop
                        invariant preservation)'', ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        y }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise
                        *)\n  done;\n  assert { true }'', ''goal_formula'': ''(x + y) >= (y + 1)''}, {''name'':
                        ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        y }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x >= y }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= y }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= (y + 1)'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { x >= y }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= y }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { x >= y }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= y }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= (y + 1)
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= y }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $106{@68}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 68
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { x >= y }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise
                  *)\n    invariant { x >= y }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }'', ''goal_formula'': ''1 >= 0''}, {''name'': ''VC for main (loop invariant
                  preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main ()
                  diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                  premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                  { y <= 100000 }  (* GOAL, premise *)\n    invariant { x >= y }  (* premise *)\n    x
                  <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'',
                  ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                  GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { x >= y }  (* GOAL, premise *)\n    x <- x + y;  (*
                  premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                  ''(x + y) >= (y + 1)''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { x >= y }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x >= y }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= y }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= (y + 1)'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { x >= y }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= y }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { x >= y }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= y }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= (y + 1)
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= y }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 122
          origin:
            - nested
            - 1
            - 52
        122:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
              y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
              { x >= y }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise
              *)\n  done;\n  assert { true }', goal_formula='(x + y) >= (y + 1)')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { y <= 100000 }  (* premise *)\n'
                                           '    invariant { x >= y }  (* GOAL, premise *)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1  (* premise *)\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='(x + y) >= (y + 1)')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= y }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1)
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 121
            - 0
        123:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 108
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                    conclusion: x >= 1
                tags:
                  - __Computation__
                answers:
                  - id: 69
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $108{@69}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 69
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 124
          origin:
            - nested
            - 1
            - 53
        124:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 123
            - 0
        125:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 110
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 1 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= 1 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 70
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { x >= 1 }\n    x <- x + y;\n    y <- y
                        + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'':
                        ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x
                        >= 1 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }'', ''goal_formula'': ''1 >= 1''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* GOAL, premise *)\n    invariant { x >= 1 }  (* premise *)\n    x
                        <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true
                        }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop
                        invariant preservation)'', ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        1 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise
                        *)\n  done;\n  assert { true }'', ''goal_formula'': ''(x + y) >= 1''}, {''name'':
                        ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { x >=
                        1 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x >= 1 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 1 }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 1'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 1 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= 1'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { x >= 1 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 1 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 1
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 1 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= 1
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $110{@70}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 70
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { x >= 1 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise
                  *)\n    invariant { x >= 1 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }'', ''goal_formula'': ''1 >= 1''}, {''name'': ''VC for main (loop invariant
                  preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main ()
                  diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                  premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                  { y <= 100000 }  (* GOAL, premise *)\n    invariant { x >= 1 }  (* premise *)\n    x
                  <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'',
                  ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                  GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { x >= 1 }  (* GOAL, premise *)\n    x <- x + y;  (*
                  premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                  ''(x + y) >= 1''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { x >= 1 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                  }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x >= 1 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 1 }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 1'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 1 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= 1'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { x >= 1 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 1 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 1
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { x >= 1 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 1 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= 1
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 126
          origin:
            - nested
            - 1
            - 54
        126:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
              y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
              { x >= 1 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise
              *)\n  done;\n  assert { true }', goal_formula='(x + y) >= 1')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { y <= 100000 }  (* premise *)\n'
                                           '    invariant { x >= 1 }  (* GOAL, premise *)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1  (* premise *)\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='(x + y) >= 1')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { x >= 1 }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= 1
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 125
            - 0
        127:
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: SuggestInvariants
          tags:
            - SuggestInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - 112
              - kind: query
                name: SuggestInvariants
                args:
                  unproved:
                    name: VC for main (loop invariant preservation)
                    proved: false
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;  (* premise *)
                        y <- 0;  (* premise *)
                        while y < 100000 do  (* premise *)
                          invariant { y <= 100000 }  (* premise *)
                          invariant { x >= y }  (* GOAL, premise *)
                          x <- x + y;  (* premise *)
                          y <- y + 1  (* premise *)
                        done;
                        assert { true }
                    goal_formula: (x + y) >= (y + 1)
                tags:
                  - SuggestInvariants
                answers:
                  - id: 71
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= 0')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= 0')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= 0
                  - id: 72
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='monotone', invariant='x
                        >= 0')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='monotone',
                                                                              invariant='x >= 0')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: monotone
                            invariant: x >= 0
                  - id: 73
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= 0'), InvariantSuggestion(trick='linear', invariant='x >= y*(y-1)/2')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= 0'),
                                                          InvariantSuggestion(trick='linear',
                                                                              invariant='x >= '
                                                                                        'y*(y-1)/2')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= 0
                          - trick: linear
                            invariant: x >= y*(y-1)/2
          actions:
            - ref:
                with_ids: $112{@71}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 71
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= 0')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= 0')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= 0
              destination: 128
            - ref:
                with_ids: $112{@72}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 72
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='monotone', invariant='x
                  >= 0')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='monotone',
                                                                        invariant='x >= 0')])
                json_provided: true
                json:
                  suggestions:
                    - trick: monotone
                      invariant: x >= 0
              destination: 129
            - ref:
                with_ids: $112{@73}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 73
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= 0'), InvariantSuggestion(trick='linear', invariant='x >= y*(y-1)/2')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= 0'),
                                                    InvariantSuggestion(trick='linear',
                                                                        invariant='x >= '
                                                                                  'y*(y-1)/2')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= 0
                    - trick: linear
                      invariant: x >= y*(y-1)/2
              destination: 130
          origin:
            - nested
            - 1
            - 55
        128:
          kind: Success
          success_value:
            short: '[''x >= 0'']'
            long: '[''x >= 0'']'
            json_provided: true
            json:
              - x >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 127
            - 0
        129:
          kind: Success
          success_value:
            short: '[''x >= 0'']'
            long: '[''x >= 0'']'
            json_provided: true
            json:
              - x >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 127
            - 1
        130:
          kind: Success
          success_value:
            short: '[''x >= 0'', ''x >= y*(y-1)/2'']'
            long: '[''x >= 0'', ''x >= y*(y-1)/2'']'
            json_provided: true
            json:
              - x >= 0
              - x >= y*(y-1)/2
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 127
            - 2
        131:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 114
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x >= 1
                      - x >= y || y < 100000
                      - x >= 0
                      - y <= 100000
                    fml: x >= y*(y-1)/2
                tags:
                  - __Computation__
                answers:
                  - id: 74
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $114{@74}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 74
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 132
          origin:
            - nested
            - 1
            - 56
        132:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 131
            - 0
        133:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 116
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                    conclusion: x >= y*(y-1)/2
                tags:
                  - __Computation__
                answers:
                  - id: 75
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $116{@75}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 75
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 134
          origin:
            - nested
            - 1
            - 57
        134:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 133
            - 0
        135:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 118
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= y*(y-1)/2 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { x >= y*(y-1)/2 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 76
                    hint: null
                    value:
                      short: '{''error'': "File line 10, characters 28-29: unbound function or predicate
                        symbol ''(/)''", ''obligations'': []}'
                      long: |-
                        {'error': 'File line 10, characters 28-29: unbound function or predicate '
                                  "symbol '(/)'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: 'File line 10, characters 28-29: unbound function or predicate symbol ''(/)'''
                        obligations: []
          actions:
            - ref:
                with_ids: $118{@76}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 76
              value:
                short: '{''error'': "File line 10, characters 28-29: unbound function or predicate symbol
                  ''(/)''", ''obligations'': []}'
                long: |-
                  {'error': 'File line 10, characters 28-29: unbound function or predicate '
                            "symbol '(/)'",
                   'obligations': []}
                json_provided: true
                json:
                  error: 'File line 10, characters 28-29: unbound function or predicate symbol ''(/)'''
                  obligations: []
              destination: 136
          origin:
            - nested
            - 1
            - 58
        136:
          kind: Success
          success_value:
            short: ('disproved', None)
            long: ('disproved', None)
            json_provided: true
            json:
              - disproved
              - null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 135
            - 0
        137:
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: SuggestInvariants
          tags:
            - SuggestInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - 120
              - kind: query
                name: SuggestInvariants
                args:
                  unproved:
                    name: VC for main (loop invariant preservation)
                    proved: false
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;  (* premise *)
                        y <- 0;  (* premise *)
                        while y < 100000 do  (* premise *)
                          invariant { y <= 100000 }  (* premise *)
                          invariant { x >= 0 }  (* GOAL, premise *)
                          x <- x + y;  (* premise *)
                          y <- y + 1  (* premise *)
                        done;
                        assert { true }
                    goal_formula: (x + y) >= 0
                tags:
                  - SuggestInvariants
                answers:
                  - id: 77
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='monotone', invariant='y
                        >= 0')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='monotone',
                                                                              invariant='y >= 0')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: monotone
                            invariant: y >= 0
                  - id: 78
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= y')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= y')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= y
                  - id: 79
                    hint: null
                    value:
                      short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                        >= (y * (y - 1)) / 2'), InvariantSuggestion(trick='linear', invariant='x >= 0')])
                      long: |-
                        InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                              invariant='x >= (y * (y '
                                                                                        '- 1)) / 2'),
                                                          InvariantSuggestion(trick='linear',
                                                                              invariant='x >= 0')])
                      json_provided: true
                      json:
                        suggestions:
                          - trick: linear
                            invariant: x >= (y * (y - 1)) / 2
                          - trick: linear
                            invariant: x >= 0
          actions:
            - ref:
                with_ids: $120{@77}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 77
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='monotone', invariant='y
                  >= 0')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='monotone',
                                                                        invariant='y >= 0')])
                json_provided: true
                json:
                  suggestions:
                    - trick: monotone
                      invariant: y >= 0
              destination: 138
            - ref:
                with_ids: $120{@78}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 78
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= y')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= y')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= y
              destination: 139
            - ref:
                with_ids: $120{@79}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 79
              value:
                short: InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear', invariant='x
                  >= (y * (y - 1)) / 2'), InvariantSuggestion(trick='linear', invariant='x >= 0')])
                long: |-
                  InvariantSuggestions(suggestions=[InvariantSuggestion(trick='linear',
                                                                        invariant='x >= (y * (y '
                                                                                  '- 1)) / 2'),
                                                    InvariantSuggestion(trick='linear',
                                                                        invariant='x >= 0')])
                json_provided: true
                json:
                  suggestions:
                    - trick: linear
                      invariant: x >= (y * (y - 1)) / 2
                    - trick: linear
                      invariant: x >= 0
              destination: 140
          origin:
            - nested
            - 1
            - 59
        138:
          kind: Success
          success_value:
            short: '[''y >= 0'']'
            long: '[''y >= 0'']'
            json_provided: true
            json:
              - y >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 137
            - 0
        139:
          kind: Success
          success_value:
            short: '[''x >= y'']'
            long: '[''x >= y'']'
            json_provided: true
            json:
              - x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 137
            - 1
        140:
          kind: Success
          success_value:
            short: '[''x >= (y * (y - 1)) / 2'', ''x >= 0'']'
            long: '[''x >= (y * (y - 1)) / 2'', ''x >= 0'']'
            json_provided: true
            json:
              - x >= (y * (y - 1)) / 2
              - x >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 137
            - 2
        141:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 122
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x >= 1
                      - x >= y || y < 100000
                      - x >= 0
                      - y <= 100000
                    fml: y >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 80
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $122{@80}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 80
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 142
          origin:
            - nested
            - 1
            - 60
        142:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 141
            - 0
        143:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 124
              - kind: query
                name: __Computation__
                args:
                  fun: search_equivalent
                  args:
                    facts:
                      - x >= y
                      - x >= 1
                      - x >= y || y < 100000
                      - x >= 0
                      - y <= 100000
                    fml: x >= (y * (y - 1)) / 2
                tags:
                  - __Computation__
                answers:
                  - id: 81
                    hint: null
                    value:
                      short: None
                      long: None
                      json_provided: true
                      json: null
          actions:
            - ref:
                with_ids: $124{@81}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 81
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 144
          origin:
            - nested
            - 1
            - 61
        144:
          kind: Success
          success_value:
            short: None
            long: None
            json_provided: true
            json: null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 143
            - 0
        145:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 126
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                    conclusion: y >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 82
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $126{@82}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 82
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 146
          origin:
            - nested
            - 1
            - 62
        146:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 145
            - 0
        147:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 128
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 83
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y
                        <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (*
                        GOAL *)\n    invariant { y >= 0 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC for main (loop
                        invariant init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant
                        { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* GOAL *)\n    x <-
                        x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 >=
                        0''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'': True,
                        ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                        *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL,
                        premise *)\n    invariant { y >= 0 }  (* premise *)\n    x <- x + y;\n    y <-
                        y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y + 1)
                        <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                        *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise
                        *)\n    invariant { y >= 0 }  (* GOAL, premise *)\n    x <- x + y;\n    y <- y
                        + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y + 1)
                        >= 0''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >=
                        0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { y >= 0 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) >= 0'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { y >= 0 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL, premise *)
                                  x <- x + y;
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) >= 0
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $128{@83}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 83
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                  *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL *)\n    invariant
                  { y >= 0 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                  ''0 <= 100000''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True,
                  ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref
                  x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while
                  y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0
                  }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                  ''0 >= 0''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'': True,
                  ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref
                  x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while
                  y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL, premise *)\n    invariant
                  { y >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1  (* premise *)\n  done;\n  assert
                  { true }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop
                  invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                  main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                  <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                  { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* GOAL, premise *)\n    x
                  <- x + y;\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                  ''(y + 1) >= 0''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
                  *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* premise
                  *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'', ''goal_formula'':
                  ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { y >= 0 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) >= 0'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { y >= 0 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { y >= 0 }  (* premise *)
                            x <- x + y;
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL, premise *)
                            x <- x + y;
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) >= 0
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 148
          origin:
            - nested
            - 1
            - 63
        148:
          kind: Success
          success_value:
            short: ('proved', ['y <= 100000'])
            long: ('proved', ['y <= 100000'])
            json_provided: true
            json:
              - proved
              - - y <= 100000
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 147
            - 0
        149:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 130
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                      - y >= 0
                    conclusion: x >= (y * (y - 1)) / 2
                tags:
                  - __Computation__
                answers:
                  - id: 84
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $130{@84}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 84
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 150
          origin:
            - nested
            - 1
            - 64
        150:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 149
            - 0
        151:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 132
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          invariant { x >= (y * (y - 1)) / 2 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          invariant { x >= (y * (y - 1)) / 2 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 85
                    hint: null
                    value:
                      short: '{''error'': "File line 11, characters 35-36: unbound function or predicate
                        symbol ''(/)''", ''obligations'': []}'
                      long: |-
                        {'error': 'File line 11, characters 35-36: unbound function or predicate '
                                  "symbol '(/)'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: 'File line 11, characters 35-36: unbound function or predicate symbol ''(/)'''
                        obligations: []
          actions:
            - ref:
                with_ids: $132{@85}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 85
              value:
                short: '{''error'': "File line 11, characters 35-36: unbound function or predicate symbol
                  ''(/)''", ''obligations'': []}'
                long: |-
                  {'error': 'File line 11, characters 35-36: unbound function or predicate '
                            "symbol '(/)'",
                   'obligations': []}
                json_provided: true
                json:
                  error: 'File line 11, characters 35-36: unbound function or predicate symbol ''(/)'''
                  obligations: []
              destination: 152
          origin:
            - nested
            - 1
            - 65
        152:
          kind: Success
          success_value:
            short: ('disproved', None)
            long: ('disproved', None)
            json_provided: true
            json:
              - disproved
              - null
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 151
            - 0
        153:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 134
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                tags:
                  - __Computation__
                answers:
                  - id: 86
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y
                        <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (*
                        GOAL *)\n    invariant { y >= 0 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { x >= y }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC for main (loop
                        invariant init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant
                        { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* GOAL *)\n    x <-
                        x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'': ''0
                        >= 0''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                        *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL,
                        premise *)\n    invariant { y >= 0 }  (* premise *)\n    x <- x + y;\n    y <-
                        y + 1  (* premise *)\n  done;\n  assert { x >= y }'', ''goal_formula'': ''(y +
                        1) <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                        *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise
                        *)\n    invariant { y >= 0 }  (* GOAL, premise *)\n    x <- x + y;\n    y <- y
                        + 1  (* premise *)\n  done;\n  assert { x >= y }'', ''goal_formula'': ''(y + 1)
                        >= 0''}, {''name'': ''VC for main (assertion)'', ''proved'': False, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >=
                        0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >=
                        y }  (* GOAL *)'', ''goal_formula'': ''x >= y''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { y >= 0 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '0 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '(y + 1) >= 0'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }  (* GOAL *)',
                                          'goal_formula': 'x >= y'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { y >= 0 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }
                            goal_formula: 0 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1  (* premise *)
                                done;
                                assert { x >= y }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL, premise *)
                                  x <- x + y;
                                  y <- y + 1  (* premise *)
                                done;
                                assert { x >= y }
                            goal_formula: (y + 1) >= 0
                          - name: VC for main (assertion)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }  (* GOAL *)
                            goal_formula: x >= y
          actions:
            - ref:
                with_ids: $134{@86}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 86
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise
                  *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL *)\n    invariant
                  { y >= 0 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'':
                  ''0 <= 100000''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True,
                  ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref
                  x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while
                  y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0
                  }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'':
                  ''0 >= 0''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'': True,
                  ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref
                  x = any int in\n  let ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while
                  y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL, premise *)\n    invariant
                  { y >= 0 }  (* premise *)\n    x <- x + y;\n    y <- y + 1  (* premise *)\n  done;\n  assert
                  { x >= y }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop
                  invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                  main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                  <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                  { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* GOAL, premise *)\n    x
                  <- x + y;\n    y <- y + 1  (* premise *)\n  done;\n  assert { x >= y }'', ''goal_formula'':
                  ''(y + 1) >= 0''}, {''name'': ''VC for main (assertion)'', ''proved'': False, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
                  *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* premise
                  *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }  (* GOAL *)'', ''goal_formula'':
                  ''x >= y''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { y >= 0 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '0 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '(y + 1) >= 0'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }  (* GOAL *)',
                                    'goal_formula': 'x >= y'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { y >= 0 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }
                      goal_formula: 0 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { y >= 0 }  (* premise *)
                            x <- x + y;
                            y <- y + 1  (* premise *)
                          done;
                          assert { x >= y }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL, premise *)
                            x <- x + y;
                            y <- y + 1  (* premise *)
                          done;
                          assert { x >= y }
                      goal_formula: (y + 1) >= 0
                    - name: VC for main (assertion)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }  (* GOAL *)
                      goal_formula: x >= y
              destination: 154
          origin:
            - nested
            - 1
            - 66
        154:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (assertion)', proved=False, relevance_hints='use
              int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any
              int in\n  x <- 1;\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
              { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    x <- x + y;\n    y
              <- y + 1\n  done;\n  assert { x >= y }  (* GOAL *)', goal_formula='x >= y')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (assertion)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { y <= 100000 }  (* premise *)\n'
                                           '    invariant { y >= 0 }  (* premise *)\n'
                                           '    x <- x + y;\n'
                                           '    y <- y + 1\n'
                                           '  done;\n'
                                           '  assert { x >= y }  (* GOAL *)',
                           goal_formula='x >= y')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (assertion)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        x <- x + y;
                        y <- y + 1
                      done;
                      assert { x >= y }  (* GOAL *)
                  goal_formula: x >= y
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 153
            - 0
        155:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 136
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                      - y >= 0
                    conclusion: x >= y
                tags:
                  - __Computation__
                answers:
                  - id: 87
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $136{@87}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 87
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 156
          origin:
            - nested
            - 1
            - 67
        156:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 155
            - 0
        157:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 138
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          invariant { x >= y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          invariant { x >= y }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 88
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { y >= 0 }\n    invariant { x >= y }\n    x
                        <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0
                        <= 100000''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True,
                        ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise
                        *)\n    invariant { y >= 0 }  (* GOAL *)\n    invariant { x >= y }\n    x <- x
                        + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 >= 0''},
                        {''name'': ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y
                        >= 0 }  (* premise *)\n    invariant { x >= y }  (* GOAL *)\n    x <- x + y;\n    y
                        <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''1 >= 0''}, {''name'':
                        ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL, premise
                        *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= y }  (* premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { true }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main
                        (loop invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use
                        int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                        { y >= 0 }  (* GOAL, premise *)\n    invariant { x >= y }  (* premise *)\n    x
                        <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true
                        }'', ''goal_formula'': ''(y + 1) >= 0''}, {''name'': ''VC for main (loop invariant
                        preservation)'', ''proved'': False, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >=
                        0 }  (* premise *)\n    invariant { x >= y }  (* GOAL, premise *)\n    x <- x
                        + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'',
                        ''goal_formula'': ''(x + y) >= (y + 1)''}, {''name'': ''VC for main (assertion)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                        { x >= y }  (* premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                        { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { y >= 0 }\n'
                                                             '    invariant { x >= y }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL *)\n'
                                                             '    invariant { x >= y }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 >= 0'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= y }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= (y + 1)'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { y >= 0 }
                                  invariant { x >= y }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL *)
                                  invariant { x >= y }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 >= 0
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= y }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= y }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL, premise *)
                                  invariant { x >= y }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= y }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= (y + 1)
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= y }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $138{@88}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 88
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { y >= 0 }\n    invariant { x >= y }\n    x <- x + y;\n    y <- y
                  + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC
                  for main (loop invariant init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                  main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                  <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant
                  { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* GOAL *)\n    invariant
                  { x >= y }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                  ''0 >= 0''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (*
                  premise *)\n    invariant { x >= y }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }'', ''goal_formula'': ''1 >= 0''}, {''name'': ''VC for main (loop invariant
                  preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main ()
                  diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                  premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                  { y <= 100000 }  (* GOAL, premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                  { x >= y }  (* premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise
                  *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'':
                  ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { y >= 0 }  (* GOAL, premise *)\n    invariant { x >= y }  (* premise *)\n    x <- x
                  + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                  ''(y + 1) >= 0''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                  False, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                  ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (*
                  premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (*
                  premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= y }  (* GOAL,
                  premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                  { true }'', ''goal_formula'': ''(x + y) >= (y + 1)''}, {''name'': ''VC for main (assertion)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= y }  (*
                  premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'',
                  ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { y >= 0 }\n'
                                                       '    invariant { x >= y }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL *)\n'
                                                       '    invariant { x >= y }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 >= 0'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= y }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= (y + 1)'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { y >= 0 }
                            invariant { x >= y }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL *)
                            invariant { x >= y }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 >= 0
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= y }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= y }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL, premise *)
                            invariant { x >= y }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= y }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= (y + 1)
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= y }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 158
          origin:
            - nested
            - 1
            - 68
        158:
          kind: Success
          success_value:
            short: ('feedback', [Obligation(name='VC for main (loop invariant preservation)', proved=False,
              relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int
              in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
              y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
              { y >= 0 }  (* premise *)\n    invariant { x >= y }  (* GOAL, premise *)\n    x <- x + y;  (*
              premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }', goal_formula='(x
              + y) >= (y + 1)')])
            long: |-
              ('feedback',
               [Obligation(name='VC for main (loop invariant preservation)',
                           proved=False,
                           relevance_hints='use int.Int\n'
                                           '\n'
                                           'let main () diverges =  (* GOAL *)\n'
                                           '  let ref x = any int in\n'
                                           '  let ref y = any int in\n'
                                           '  x <- 1;  (* premise *)\n'
                                           '  y <- 0;  (* premise *)\n'
                                           '  while y < 100000 do  (* premise *)\n'
                                           '    invariant { y <= 100000 }  (* premise *)\n'
                                           '    invariant { y >= 0 }  (* premise *)\n'
                                           '    invariant { x >= y }  (* GOAL, premise *)\n'
                                           '    x <- x + y;  (* premise *)\n'
                                           '    y <- y + 1  (* premise *)\n'
                                           '  done;\n'
                                           '  assert { true }',
                           goal_formula='(x + y) >= (y + 1)')])
            json_provided: true
            json:
              - feedback
              - - name: VC for main (loop invariant preservation)
                  proved: false
                  relevance_hints: |-
                    use int.Int

                    let main () diverges =  (* GOAL *)
                      let ref x = any int in
                      let ref y = any int in
                      x <- 1;  (* premise *)
                      y <- 0;  (* premise *)
                      while y < 100000 do  (* premise *)
                        invariant { y <= 100000 }  (* premise *)
                        invariant { y >= 0 }  (* premise *)
                        invariant { x >= y }  (* GOAL, premise *)
                        x <- x + y;  (* premise *)
                        y <- y + 1  (* premise *)
                      done;
                      assert { true }
                  goal_formula: (x + y) >= (y + 1)
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 157
            - 0
        159:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 140
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                      - y >= 0
                    conclusion: x >= 1
                tags:
                  - __Computation__
                answers:
                  - id: 89
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $140{@89}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 89
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 160
          origin:
            - nested
            - 1
            - 69
        160:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 159
            - 0
        161:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 142
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          invariant { x >= 1 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          invariant { x >= 1 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 90
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { y >= 0 }\n    invariant { x >= 1 }\n    x
                        <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0
                        <= 100000''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True,
                        ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise
                        *)\n    invariant { y >= 0 }  (* GOAL *)\n    invariant { x >= 1 }\n    x <- x
                        + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 >= 0''},
                        {''name'': ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y
                        >= 0 }  (* premise *)\n    invariant { x >= 1 }  (* GOAL *)\n    x <- x + y;\n    y
                        <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''1 >= 1''}, {''name'':
                        ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* GOAL, premise
                        *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= 1 }  (* premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { true }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main
                        (loop invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use
                        int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                        { y >= 0 }  (* GOAL, premise *)\n    invariant { x >= 1 }  (* premise *)\n    x
                        <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true
                        }'', ''goal_formula'': ''(y + 1) >= 0''}, {''name'': ''VC for main (loop invariant
                        preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main
                        () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                        <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise
                        *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (*
                        premise *)\n    invariant { x >= 1 }  (* GOAL, premise *)\n    x <- x + y;  (*
                        premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                        ''(x + y) >= 1''}, {''name'': ''VC for main (assertion)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                        { y >= 0 }  (* premise *)\n    invariant { x >= 1 }  (* premise *)\n    x <- x
                        + y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'', ''goal_formula'':
                        ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { y >= 0 }\n'
                                                             '    invariant { x >= 1 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL *)\n'
                                                             '    invariant { x >= 1 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 >= 0'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 1'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= 1'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { y >= 0 }
                                  invariant { x >= 1 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL *)
                                  invariant { x >= 1 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 >= 0
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 1
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL, premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= 1
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $142{@90}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 90
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { y >= 0 }\n    invariant { x >= 1 }\n    x <- x + y;\n    y <- y
                  + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC
                  for main (loop invariant init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                  main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x
                  <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant
                  { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* GOAL *)\n    invariant
                  { x >= 1 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                  ''0 >= 0''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (*
                  premise *)\n    invariant { x >= 1 }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert
                  { true }'', ''goal_formula'': ''1 >= 1''}, {''name'': ''VC for main (loop invariant
                  preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main ()
                  diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                  premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                  { y <= 100000 }  (* GOAL, premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                  { x >= 1 }  (* premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise
                  *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'':
                  ''VC for main (loop invariant preservation)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { y >= 0 }  (* GOAL, premise *)\n    invariant { x >= 1 }  (* premise *)\n    x <- x
                  + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                  ''(y + 1) >= 0''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                  True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                  ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (*
                  premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (*
                  premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= 1 }  (* GOAL,
                  premise *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                  { true }'', ''goal_formula'': ''(x + y) >= 1''}, {''name'': ''VC for main (assertion)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= 1 }  (*
                  premise *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'',
                  ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { y >= 0 }\n'
                                                       '    invariant { x >= 1 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL *)\n'
                                                       '    invariant { x >= 1 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 >= 0'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 1'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= 1'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { y >= 0 }
                            invariant { x >= 1 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL *)
                            invariant { x >= 1 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 >= 0
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 1
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL, premise *)
                            invariant { x >= 1 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= 1
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 162
          origin:
            - nested
            - 1
            - 70
        162:
          kind: Success
          success_value:
            short: ('proved', ['y <= 100000', 'y >= 0'])
            long: ('proved', ['y <= 100000', 'y >= 0'])
            json_provided: true
            json:
              - proved
              - - y <= 100000
                - y >= 0
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 161
            - 0
        163:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 144
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                      - y >= 0
                      - x >= 1
                    conclusion: x >= y || y < 100000
                tags:
                  - __Computation__
                answers:
                  - id: 91
                    hint: null
                    value:
                      short: 'False'
                      long: 'False'
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: $144{@91}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 91
              value:
                short: 'False'
                long: 'False'
                json_provided: true
                json: false
              destination: 164
          origin:
            - nested
            - 1
            - 71
        164:
          kind: Success
          success_value:
            short: 'False'
            long: 'False'
            json_provided: true
            json: false
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 163
            - 0
        165:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 146
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          invariant { x >= 1 }
                          invariant { x >= y || y < 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          invariant { x >= 1 }
                          invariant { x >= y || y < 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { true }
                tags:
                  - __Computation__
                answers:
                  - id: 92
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { y >= 0 }\n    invariant { x >= 1 }\n    invariant
                        { x >= y || y < 100000 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert {
                        true }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* GOAL *)\n    invariant
                        { x >= 1 }\n    invariant { x >= y || y < 100000 }\n    x <- x + y;\n    y <-
                        y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''0 >= 0''}, {''name'':
                        ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y
                        >= 0 }  (* premise *)\n    invariant { x >= 1 }  (* GOAL *)\n    invariant { x
                        >= y || y < 100000 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true
                        }'', ''goal_formula'': ''1 >= 1''}, {''name'': ''VC for main (loop invariant init)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000
                        }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >=
                        1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* GOAL *)\n    x
                        <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'': ''1
                        >= 0 || 0 < 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* GOAL, premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                        { x >= 1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { true }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main
                        (loop invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use
                        int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                        { y >= 0 }  (* GOAL, premise *)\n    invariant { x >= 1 }  (* premise *)\n    invariant
                        { x >= y || y < 100000 }  (* premise *)\n    x <- x + y;  (* premise *)\n    y
                        <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(y
                        + 1) >= 0''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <=
                        100000 }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                        { x >= 1 }  (* GOAL, premise *)\n    invariant { x >= y || y < 100000 }  (* premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { true }'', ''goal_formula'': ''(x + y) >= 1''}, {''name'': ''VC for main (loop
                        invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >=
                        0 }  (* premise *)\n    invariant { x >= 1 }  (* premise *)\n    invariant { x
                        >= y || y < 100000 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y
                        <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'': ''(x
                        + y) >= (y + 1) || (y + 1) < 100000''}, {''name'': ''VC for main (assertion)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                        { x >= 1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* premise
                        *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }  (* GOAL *)'',
                        ''goal_formula'': ''true''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { y >= 0 }\n'
                                                             '    invariant { x >= 1 }\n'
                                                             '    invariant { x >= y || y < 100000 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL *)\n'
                                                             '    invariant { x >= 1 }\n'
                                                             '    invariant { x >= y || y < 100000 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '0 >= 0'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* GOAL *)\n'
                                                             '    invariant { x >= y || y < 100000 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 1'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '1 >= 0 || 0 < 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(y + 1) >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= 1'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* GOAL, premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { true }',
                                          'goal_formula': '(x + y) >= (y + 1) || (y + 1) < 100000'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { true }  (* GOAL *)',
                                          'goal_formula': 'true'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { y >= 0 }
                                  invariant { x >= 1 }
                                  invariant { x >= y || y < 100000 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL *)
                                  invariant { x >= 1 }
                                  invariant { x >= y || y < 100000 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 0 >= 0
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* GOAL *)
                                  invariant { x >= y || y < 100000 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 1
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }
                            goal_formula: 1 >= 0 || 0 < 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL, premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (y + 1) >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* GOAL, premise *)
                                  invariant { x >= y || y < 100000 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= 1
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { true }
                            goal_formula: (x + y) >= (y + 1) || (y + 1) < 100000
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { true }  (* GOAL *)
                            goal_formula: 'true'
          actions:
            - ref:
                with_ids: $146{@92}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 92
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { y >= 0 }\n    invariant { x >= 1 }\n    invariant { x >= y || y
                  < 100000 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                  ''0 <= 100000''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True,
                  ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref
                  x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise
                  *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { y >= 0 }  (* GOAL *)\n    invariant { x >= 1 }\n    invariant { x >= y || y < 100000
                  }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                  ''0 >= 0''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (*
                  premise *)\n    invariant { x >= 1 }  (* GOAL *)\n    invariant { x >= y || y < 100000
                  }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                  ''1 >= 1''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (*
                  premise *)\n    invariant { x >= 1 }  (* premise *)\n    invariant { x >= y || y < 100000
                  }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { true }'', ''goal_formula'':
                  ''1 >= 0 || 0 < 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* GOAL, premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >=
                  1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* premise *)\n    x <-
                  x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'',
                  ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { y >= 0 }  (* GOAL, premise *)\n    invariant { x >=
                  1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* premise *)\n    x <-
                  x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'',
                  ''goal_formula'': ''(y + 1) >= 0''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= 1 }  (*
                  GOAL, premise *)\n    invariant { x >= y || y < 100000 }  (* premise *)\n    x <- x
                  + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                  ''(x + y) >= 1''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                  True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                  ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (*
                  premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (*
                  premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= 1 }  (* premise
                  *)\n    invariant { x >= y || y < 100000 }  (* GOAL, premise *)\n    x <- x + y;  (*
                  premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { true }'', ''goal_formula'':
                  ''(x + y) >= (y + 1) || (y + 1) < 100000''}, {''name'': ''VC for main (assertion)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= 1 }  (*
                  premise *)\n    invariant { x >= y || y < 100000 }  (* premise *)\n    x <- x + y;\n    y
                  <- y + 1\n  done;\n  assert { true }  (* GOAL *)'', ''goal_formula'': ''true''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { y >= 0 }\n'
                                                       '    invariant { x >= 1 }\n'
                                                       '    invariant { x >= y || y < 100000 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL *)\n'
                                                       '    invariant { x >= 1 }\n'
                                                       '    invariant { x >= y || y < 100000 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '0 >= 0'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* GOAL *)\n'
                                                       '    invariant { x >= y || y < 100000 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 1'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '1 >= 0 || 0 < 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(y + 1) >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= 1'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* GOAL, premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { true }',
                                    'goal_formula': '(x + y) >= (y + 1) || (y + 1) < 100000'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { true }  (* GOAL *)',
                                    'goal_formula': 'true'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { y >= 0 }
                            invariant { x >= 1 }
                            invariant { x >= y || y < 100000 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL *)
                            invariant { x >= 1 }
                            invariant { x >= y || y < 100000 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 0 >= 0
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* GOAL *)
                            invariant { x >= y || y < 100000 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 1
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }
                      goal_formula: 1 >= 0 || 0 < 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL, premise *)
                            invariant { x >= 1 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (y + 1) >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* GOAL, premise *)
                            invariant { x >= y || y < 100000 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= 1
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { true }
                      goal_formula: (x + y) >= (y + 1) || (y + 1) < 100000
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { true }  (* GOAL *)
                      goal_formula: 'true'
              destination: 166
          origin:
            - nested
            - 1
            - 72
        166:
          kind: Success
          success_value:
            short: ('proved', ['y <= 100000', 'y >= 0', 'x >= 1'])
            long: ('proved', ['y <= 100000', 'y >= 0', 'x >= 1'])
            json_provided: true
            json:
              - proved
              - - y <= 100000
                - y >= 0
                - x >= 1
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 165
            - 0
        167:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 148
              - kind: query
                name: __Computation__
                args:
                  fun: is_valid_implication
                  args:
                    assumptions:
                      - y <= 100000
                      - y >= 0
                      - x >= 1
                      - x >= y || y < 100000
                    conclusion: x >= 0
                tags:
                  - __Computation__
                answers:
                  - id: 93
                    hint: null
                    value:
                      short: 'True'
                      long: 'True'
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: $148{@93}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 93
              value:
                short: 'True'
                long: 'True'
                json_provided: true
                json: true
              destination: 168
          origin:
            - nested
            - 1
            - 73
        168:
          kind: Success
          success_value:
            short: 'True'
            long: 'True'
            json_provided: true
            json: true
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 167
            - 0
        169:
          kind: Compute
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          tags: []
          properties:
            - - with_ids: query
                with_hints: null
              - 150
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          invariant { x >= 1 }
                          invariant { x >= y || y < 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        x <- 1;
                        y <- 0;
                        while y < 100000 do
                          invariant { y <= 100000 }
                          invariant { y >= 0 }
                          invariant { x >= 1 }
                          invariant { x >= y || y < 100000 }
                          x <- x + y;
                          y <- y + 1
                        done;
                        assert { x >= y }
                tags:
                  - __Computation__
                answers:
                  - id: 94
                    hint: null
                    value:
                      short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* GOAL *)\n    invariant { y >= 0 }\n    invariant { x >= 1 }\n    invariant
                        { x >= y || y < 100000 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert {
                        x >= y }'', ''goal_formula'': ''0 <= 100000''}, {''name'': ''VC for main (loop
                        invariant init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant
                        { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* GOAL *)\n    invariant
                        { x >= 1 }\n    invariant { x >= y || y < 100000 }\n    x <- x + y;\n    y <-
                        y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'': ''0 >= 0''}, {''name'':
                        ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                        ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y
                        >= 0 }  (* premise *)\n    invariant { x >= 1 }  (* GOAL *)\n    invariant { x
                        >= y || y < 100000 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >=
                        y }'', ''goal_formula'': ''1 >= 1''}, {''name'': ''VC for main (loop invariant
                        init)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                        =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (*
                        premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y
                        <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                        { x >= 1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* GOAL *)\n    x
                        <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'': ''1
                        >= 0 || 0 < 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* GOAL, premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                        { x >= 1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { x >= y }'', ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main
                        (loop invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use
                        int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                        ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while
                        y < 100000 do  (* premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                        { y >= 0 }  (* GOAL, premise *)\n    invariant { x >= 1 }  (* premise *)\n    invariant
                        { x >= y || y < 100000 }  (* premise *)\n    x <- x + y;  (* premise *)\n    y
                        <- y + 1  (* premise *)\n  done;\n  assert { x >= y }'', ''goal_formula'': ''(y
                        + 1) >= 0''}, {''name'': ''VC for main (loop invariant preservation)'', ''proved'':
                        True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let
                        ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <-
                        0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <=
                        100000 }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                        { x >= 1 }  (* GOAL, premise *)\n    invariant { x >= y || y < 100000 }  (* premise
                        *)\n    x <- x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert
                        { x >= y }'', ''goal_formula'': ''(x + y) >= 1''}, {''name'': ''VC for main (loop
                        invariant preservation)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet
                        main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int
                        in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (*
                        premise *)\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >=
                        0 }  (* premise *)\n    invariant { x >= 1 }  (* premise *)\n    invariant { x
                        >= y || y < 100000 }  (* GOAL, premise *)\n    x <- x + y;  (* premise *)\n    y
                        <- y + 1  (* premise *)\n  done;\n  assert { x >= y }'', ''goal_formula'': ''(x
                        + y) >= (y + 1) || (y + 1) < 100000''}, {''name'': ''VC for main (assertion)'',
                        ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (*
                        GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                        *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant
                        { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                        { x >= 1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* premise
                        *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }  (* GOAL *)'',
                        ''goal_formula'': ''x >= y''}]}'
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { y >= 0 }\n'
                                                             '    invariant { x >= 1 }\n'
                                                             '    invariant { x >= y || y < 100000 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '0 <= 100000'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL *)\n'
                                                             '    invariant { x >= 1 }\n'
                                                             '    invariant { x >= y || y < 100000 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '0 >= 0'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* GOAL *)\n'
                                                             '    invariant { x >= y || y < 100000 }\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '1 >= 1'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* GOAL *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '1 >= 0 || 0 < 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '(y + 1) <= 100000'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '(y + 1) >= 0'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '(x + y) >= 1'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* GOAL, premise *)\n'
                                                             '    x <- x + y;  (* premise *)\n'
                                                             '    y <- y + 1  (* premise *)\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }',
                                          'goal_formula': '(x + y) >= (y + 1) || (y + 1) < 100000'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in\n'
                                                             '  x <- 1;  (* premise *)\n'
                                                             '  y <- 0;  (* premise *)\n'
                                                             '  while y < 100000 do  (* premise *)\n'
                                                             '    invariant { y <= 100000 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { y >= 0 }  (* premise *)\n'
                                                             '    invariant { x >= 1 }  (* premise *)\n'
                                                             '    invariant { x >= y || y < 100000 }  '
                                                             '(* premise *)\n'
                                                             '    x <- x + y;\n'
                                                             '    y <- y + 1\n'
                                                             '  done;\n'
                                                             '  assert { x >= y }  (* GOAL *)',
                                          'goal_formula': 'x >= y'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* GOAL *)
                                  invariant { y >= 0 }
                                  invariant { x >= 1 }
                                  invariant { x >= y || y < 100000 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }
                            goal_formula: 0 <= 100000
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL *)
                                  invariant { x >= 1 }
                                  invariant { x >= y || y < 100000 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }
                            goal_formula: 0 >= 0
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* GOAL *)
                                  invariant { x >= y || y < 100000 }
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }
                            goal_formula: 1 >= 1
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* GOAL *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }
                            goal_formula: 1 >= 0 || 0 < 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* GOAL, premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { x >= y }
                            goal_formula: (y + 1) <= 100000
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* GOAL, premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { x >= y }
                            goal_formula: (y + 1) >= 0
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* GOAL, premise *)
                                  invariant { x >= y || y < 100000 }  (* premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { x >= y }
                            goal_formula: (x + y) >= 1
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* GOAL, premise *)
                                  x <- x + y;  (* premise *)
                                  y <- y + 1  (* premise *)
                                done;
                                assert { x >= y }
                            goal_formula: (x + y) >= (y + 1) || (y + 1) < 100000
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in
                                x <- 1;  (* premise *)
                                y <- 0;  (* premise *)
                                while y < 100000 do  (* premise *)
                                  invariant { y <= 100000 }  (* premise *)
                                  invariant { y >= 0 }  (* premise *)
                                  invariant { x >= 1 }  (* premise *)
                                  invariant { x >= y || y < 100000 }  (* premise *)
                                  x <- x + y;
                                  y <- y + 1
                                done;
                                assert { x >= y }  (* GOAL *)
                            goal_formula: x >= y
          actions:
            - ref:
                with_ids: $150{@94}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers:
                - 94
              value:
                short: '{''error'': None, ''obligations'': [{''name'': ''VC for main (loop invariant init)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* GOAL
                  *)\n    invariant { y >= 0 }\n    invariant { x >= 1 }\n    invariant { x >= y || y
                  < 100000 }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'':
                  ''0 <= 100000''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True,
                  ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref
                  x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise
                  *)\n  while y < 100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant
                  { y >= 0 }  (* GOAL *)\n    invariant { x >= 1 }\n    invariant { x >= y || y < 100000
                  }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'':
                  ''0 >= 0''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (*
                  premise *)\n    invariant { x >= 1 }  (* GOAL *)\n    invariant { x >= y || y < 100000
                  }\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'':
                  ''1 >= 1''}, {''name'': ''VC for main (loop invariant init)'', ''proved'': True, ''relevance_hints'':
                  ''use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in\n  let
                  ref y = any int in\n  x <- 1;  (* premise *)\n  y <- 0;  (* premise *)\n  while y <
                  100000 do\n    invariant { y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (*
                  premise *)\n    invariant { x >= 1 }  (* premise *)\n    invariant { x >= y || y < 100000
                  }  (* GOAL *)\n    x <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }'', ''goal_formula'':
                  ''1 >= 0 || 0 < 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* GOAL, premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >=
                  1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* premise *)\n    x <-
                  x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { x >= y }'',
                  ''goal_formula'': ''(y + 1) <= 100000''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { y >= 0 }  (* GOAL, premise *)\n    invariant { x >=
                  1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* premise *)\n    x <-
                  x + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { x >= y }'',
                  ''goal_formula'': ''(y + 1) >= 0''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= 1 }  (*
                  GOAL, premise *)\n    invariant { x >= y || y < 100000 }  (* premise *)\n    x <- x
                  + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { x >= y }'',
                  ''goal_formula'': ''(x + y) >= 1''}, {''name'': ''VC for main (loop invariant preservation)'',
                  ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges =  (* GOAL
                  *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise *)\n  y
                  <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant { y <= 100000
                  }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant { x >= 1 }  (*
                  premise *)\n    invariant { x >= y || y < 100000 }  (* GOAL, premise *)\n    x <- x
                  + y;  (* premise *)\n    y <- y + 1  (* premise *)\n  done;\n  assert { x >= y }'',
                  ''goal_formula'': ''(x + y) >= (y + 1) || (y + 1) < 100000''}, {''name'': ''VC for main
                  (assertion)'', ''proved'': True, ''relevance_hints'': ''use int.Int\n\nlet main () diverges
                  =  (* GOAL *)\n  let ref x = any int in\n  let ref y = any int in\n  x <- 1;  (* premise
                  *)\n  y <- 0;  (* premise *)\n  while y < 100000 do  (* premise *)\n    invariant {
                  y <= 100000 }  (* premise *)\n    invariant { y >= 0 }  (* premise *)\n    invariant
                  { x >= 1 }  (* premise *)\n    invariant { x >= y || y < 100000 }  (* premise *)\n    x
                  <- x + y;\n    y <- y + 1\n  done;\n  assert { x >= y }  (* GOAL *)'', ''goal_formula'':
                  ''x >= y''}]}'
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { y >= 0 }\n'
                                                       '    invariant { x >= 1 }\n'
                                                       '    invariant { x >= y || y < 100000 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '0 <= 100000'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL *)\n'
                                                       '    invariant { x >= 1 }\n'
                                                       '    invariant { x >= y || y < 100000 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '0 >= 0'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* GOAL *)\n'
                                                       '    invariant { x >= y || y < 100000 }\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '1 >= 1'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* GOAL *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '1 >= 0 || 0 < 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '(y + 1) <= 100000'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '(y + 1) >= 0'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '(x + y) >= 1'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* GOAL, premise *)\n'
                                                       '    x <- x + y;  (* premise *)\n'
                                                       '    y <- y + 1  (* premise *)\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }',
                                    'goal_formula': '(x + y) >= (y + 1) || (y + 1) < 100000'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in\n'
                                                       '  x <- 1;  (* premise *)\n'
                                                       '  y <- 0;  (* premise *)\n'
                                                       '  while y < 100000 do  (* premise *)\n'
                                                       '    invariant { y <= 100000 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { y >= 0 }  (* premise *)\n'
                                                       '    invariant { x >= 1 }  (* premise *)\n'
                                                       '    invariant { x >= y || y < 100000 }  '
                                                       '(* premise *)\n'
                                                       '    x <- x + y;\n'
                                                       '    y <- y + 1\n'
                                                       '  done;\n'
                                                       '  assert { x >= y }  (* GOAL *)',
                                    'goal_formula': 'x >= y'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* GOAL *)
                            invariant { y >= 0 }
                            invariant { x >= 1 }
                            invariant { x >= y || y < 100000 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }
                      goal_formula: 0 <= 100000
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL *)
                            invariant { x >= 1 }
                            invariant { x >= y || y < 100000 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }
                      goal_formula: 0 >= 0
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* GOAL *)
                            invariant { x >= y || y < 100000 }
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }
                      goal_formula: 1 >= 1
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* GOAL *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }
                      goal_formula: 1 >= 0 || 0 < 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* GOAL, premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { x >= y }
                      goal_formula: (y + 1) <= 100000
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* GOAL, premise *)
                            invariant { x >= 1 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { x >= y }
                      goal_formula: (y + 1) >= 0
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* GOAL, premise *)
                            invariant { x >= y || y < 100000 }  (* premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { x >= y }
                      goal_formula: (x + y) >= 1
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* GOAL, premise *)
                            x <- x + y;  (* premise *)
                            y <- y + 1  (* premise *)
                          done;
                          assert { x >= y }
                      goal_formula: (x + y) >= (y + 1) || (y + 1) < 100000
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in
                          x <- 1;  (* premise *)
                          y <- 0;  (* premise *)
                          while y < 100000 do  (* premise *)
                            invariant { y <= 100000 }  (* premise *)
                            invariant { y >= 0 }  (* premise *)
                            invariant { x >= 1 }  (* premise *)
                            invariant { x >= y || y < 100000 }  (* premise *)
                            x <- x + y;
                            y <- y + 1
                          done;
                          assert { x >= y }  (* GOAL *)
                      goal_formula: x >= y
              destination: 170
          origin:
            - nested
            - 1
            - 74
        170:
          kind: Success
          success_value:
            short: ('proved', ['y <= 100000', 'y >= 0', 'x >= 1', 'x >= y || y < 100000'])
            long: ('proved', ['y <= 100000', 'y >= 0', 'x >= 1', 'x >= y || y < 100000'])
            json_provided: true
            json:
              - proved
              - - y <= 100000
                - y >= 0
                - x >= 1
                - x >= y || y < 100000
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 169
            - 0
        171:
          kind: Success
          success_value:
            short: |-
              use int.Int

              let main () diverges =
                let ref x = any int in
                let ref y = any int in
                x <- 1;
                y <- 0;
                while y < 100000 do
                  invariant { y <= 100000 }
                  invariant { y >= 0 }
                  invariant { x >= 1 }
                  invariant { x >= y || y < 100000 }
                  x <- x + y;
                  y <- y + 1
                done;
                assert { x >= y }
            long: |-
              ('use int.Int\n'
               '\n'
               'let main () diverges =\n'
               '  let ref x = any int in\n'
               '  let ref y = any int in\n'
               '  x <- 1;\n'
               '  y <- 0;\n'
               '  while y < 100000 do\n'
               '    invariant { y <= 100000 }\n'
               '    invariant { y >= 0 }\n'
               '    invariant { x >= 1 }\n'
               '    invariant { x >= y || y < 100000 }\n'
               '    x <- x + y;\n'
               '    y <- y + 1\n'
               '  done;\n'
               '  assert { x >= y }')
            json_provided: true
            json: |-
              use int.Int

              let main () diverges =
                let ref x = any int in
                let ref y = any int in
                x <- 1;
                y <- 0;
                while y < 100000 do
                  invariant { y <= 100000 }
                  invariant { y >= 0 }
                  invariant { x >= 1 }
                  invariant { x >= y || y < 100000 }
                  x <- x + y;
                  y <- y + 1
                done;
                assert { x >= y }
          summary_message: null
          leaf_node: true
          label: null
          tags: []
          properties: []
          actions: []
          origin:
            - child
            - 1
            - 0
      spaces:
        1:
          - 1
          - 0
        3:
          - 1
          - 1
        5:
          - 1
          - 2
        7:
          - 1
          - 3
        9:
          - 1
          - 4
        11:
          - 1
          - 5
        13:
          - 1
          - 6
        15:
          - 1
          - 7
        17:
          - 1
          - 8
        19:
          - 1
          - 9
        21:
          - 1
          - 10
        23:
          - 1
          - 11
        25:
          - 1
          - 12
        27:
          - 1
          - 13
        29:
          - 1
          - 14
        31:
          - 1
          - 15
        33:
          - 1
          - 16
        35:
          - 1
          - 17
        37:
          - 1
          - 18
        39:
          - 1
          - 19
        41:
          - 1
          - 20
        43:
          - 1
          - 21
        45:
          - 1
          - 22
        47:
          - 1
          - 23
        49:
          - 1
          - 24
        51:
          - 1
          - 25
        53:
          - 1
          - 26
        55:
          - 1
          - 27
        57:
          - 1
          - 28
        59:
          - 1
          - 29
        61:
          - 1
          - 30
        63:
          - 1
          - 31
        65:
          - 1
          - 32
        67:
          - 1
          - 33
        69:
          - 1
          - 34
        71:
          - 1
          - 35
        73:
          - 1
          - 36
        75:
          - 1
          - 37
        77:
          - 1
          - 38
        79:
          - 1
          - 39
        81:
          - 1
          - 40
        83:
          - 1
          - 41
        85:
          - 1
          - 42
        87:
          - 1
          - 43
        89:
          - 1
          - 44
        91:
          - 1
          - 45
        93:
          - 1
          - 46
        95:
          - 1
          - 47
        97:
          - 1
          - 48
        99:
          - 1
          - 49
        101:
          - 1
          - 50
        103:
          - 1
          - 51
        105:
          - 1
          - 52
        107:
          - 1
          - 53
        109:
          - 1
          - 54
        111:
          - 1
          - 55
        113:
          - 1
          - 56
        115:
          - 1
          - 57
        117:
          - 1
          - 58
        119:
          - 1
          - 59
        121:
          - 1
          - 60
        123:
          - 1
          - 61
        125:
          - 1
          - 62
        127:
          - 1
          - 63
        129:
          - 1
          - 64
        131:
          - 1
          - 65
        133:
          - 1
          - 66
        135:
          - 1
          - 67
        137:
          - 1
          - 68
        139:
          - 1
          - 69
        141:
          - 1
          - 70
        143:
          - 1
          - 71
        145:
          - 1
          - 72
        147:
          - 1
          - 73
        149:
          - 1
          - 74
        2:
          - 2
          - 0
        4:
          - 4
          - 0
        6:
          - 8
          - 0
        8:
          - 10
          - 0
        10:
          - 12
          - 0
        12:
          - 14
          - 0
        14:
          - 16
          - 0
        16:
          - 24
          - 0
        18:
          - 26
          - 0
        20:
          - 28
          - 0
        22:
          - 30
          - 0
        24:
          - 32
          - 0
        26:
          - 34
          - 0
        28:
          - 40
          - 0
        30:
          - 42
          - 0
        32:
          - 44
          - 0
        34:
          - 46
          - 0
        36:
          - 48
          - 0
        38:
          - 50
          - 0
        40:
          - 52
          - 0
        42:
          - 54
          - 0
        44:
          - 56
          - 0
        46:
          - 58
          - 0
        48:
          - 60
          - 0
        50:
          - 62
          - 0
        52:
          - 64
          - 0
        54:
          - 66
          - 0
        56:
          - 68
          - 0
        58:
          - 70
          - 0
        60:
          - 72
          - 0
        62:
          - 74
          - 0
        64:
          - 76
          - 0
        66:
          - 78
          - 0
        68:
          - 80
          - 0
        70:
          - 82
          - 0
        72:
          - 84
          - 0
        74:
          - 86
          - 0
        76:
          - 88
          - 0
        78:
          - 93
          - 0
        80:
          - 95
          - 0
        82:
          - 97
          - 0
        84:
          - 99
          - 0
        86:
          - 101
          - 0
        88:
          - 103
          - 0
        90:
          - 105
          - 0
        92:
          - 107
          - 0
        94:
          - 109
          - 0
        96:
          - 111
          - 0
        98:
          - 113
          - 0
        100:
          - 115
          - 0
        102:
          - 117
          - 0
        104:
          - 119
          - 0
        106:
          - 121
          - 0
        108:
          - 123
          - 0
        110:
          - 125
          - 0
        112:
          - 127
          - 0
        114:
          - 131
          - 0
        116:
          - 133
          - 0
        118:
          - 135
          - 0
        120:
          - 137
          - 0
        122:
          - 141
          - 0
        124:
          - 143
          - 0
        126:
          - 145
          - 0
        128:
          - 147
          - 0
        130:
          - 149
          - 0
        132:
          - 151
          - 0
        134:
          - 153
          - 0
        136:
          - 155
          - 0
        138:
          - 157
          - 0
        140:
          - 159
          - 0
        142:
          - 161
          - 0
        144:
          - 163
          - 0
        146:
          - 165
          - 0
        148:
          - 167
          - 0
        150:
          - 169
          - 0
