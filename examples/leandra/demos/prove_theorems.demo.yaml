- strategy: prove_theorem
  args:
    theorem: |
      theorem case_analysis
        (f: ℝ → ℝ) (h₀: ∀ x, f x = x ^ 2 - 5 * x + 6) (x: ℝ) (h₁: f x = 0): x > 0 := by sorry
  tests:
    - run | success
  queries: 
    - query: SketchProof
      args:
        theorem: |
          theorem case_analysis
            (f: ℝ → ℝ) (h₀: ∀ x, f x = x ^ 2 - 5 * x + 6) (x: ℝ) (h₁: f x = 0): x > 0 := by sorry
        prefix: []
      answers:
        - answer:
            steps:
              - prove: ["x_eq", "(x - 2) * (x - 3) = 0"]
              - prove: ["x_cands", "x = 2 ∨ x = 3"]


- strategy: prove_theorem
  args:
    theorem: |
      theorem mathd_algebra_22 : Real.logb (5 ^ 2) (5 ^ 4) = 2 := by sorry
  tests:
    - run | success
  queries: 
    - query: SketchProof
      args:
        theorem: |
          theorem mathd_algebra_22 : Real.logb (5 ^ 2) (5 ^ 4) = 2 := by sorry
        prefix: []
      answers:
        - answer:
            steps:
              - prove: [is_pow, "((5: ℝ) ^ 4) = ((5: ℝ) ^ 2) ^ 2"]
          justification: |
            We first rewrite 5^4 as (5^2)^2, and then conclude using log identities. It is important to annotate constants with ℝ in the intermediate proof step, without which they would be interpreted as natural numbers and not reals.
    - query: ProveGoal
      args:
        goal: |-
          is_pow : 5 ^ 4 = (5 ^ 2) ^ 2
          ⊢ Real.logb (5 ^ 2) (5 ^ 4) = 2
        prefix: []
      answers:
        - answer: |-
            simp [is_pow, Real.logb_pow, Real.logb_self_eq_one]


- strategy: prove_theorem
  args:
    theorem: |
      theorem induction_sum_odd (n : ℕ) : (∑ k ∈ Finset.range n, (2 * k + 1)) = n ^ 2 := by sorry
  tests:
    - run '#direct' | success  # we do the proof without a sketch
  queries: 
    - query: ProveGoal
      args:
        goal: |-
          n : ℕ
          ⊢ ∑ k ∈ Finset.range n, (2 * k + 1) = n ^ 2
        prefix: []
      answers:
        - answer: |-
            induction n with
              | zero => simp
              | succ n => rw [Finset.sum_range_succ] ; grind


- strategy: prove_theorem
  args:
    theorem: |
      theorem mathd_algebra_110_direct
        (q e : ℂ)
        (h₀ : q = 2 - 2 * Complex.I)
        (h₁ : e = 5 + 5 * Complex.I)
        : q * e = 20
      := by sorry
  tests:
    - run '#direct' | success
  queries: 
    - query: ProveGoal
      args:
        goal: |-
          q e : ℂ
          h₀ : q = 2 - 2 * Complex.I
          h₁ : e = 5 + 5 * Complex.I
          ⊢ q * e = 20
        prefix: []
      answers:
        - answer: |-
            have i_sq: Complex.I ^ 2 = -1 := by simp
            rw [h₁, h₀] ; grind
          justification:
            The `grind` tactic does not have knowledge about complex numbers but in this case, it is enough to add the fact that i^2=1 in context for automation to work.


- strategy: prove_theorem
  args:
    theorem: |
      theorem mathd_algebra_510
        (x y : ℝ)
        (h₀ : x + y = 13)
        (h₁ : x * y = 24) : Real.sqrt (x ^ 2 + y ^ 2) = 11
      := by sorry
  tests:
    - run | success
  queries: 
    - query: SketchProof
      args:
        theorem: |
          theorem mathd_algebra_510
            (x y : ℝ)
            (h₀ : x + y = 13)
            (h₁ : x * y = 24) : Real.sqrt (x ^ 2 + y ^ 2) = 11
          := by sorry
        prefix: []
      answers:
        - answer:
            steps:
              - prove: ["eq1", "x ^ 2 + y ^ 2 = (x + y)^2 - 2*(x * y)"]
              - prove: ["eq2", "x ^ 2 + y ^ 2 = 11^2"]
    - query: ProveGoal
      args:
        goal: |-
          x y : ℝ
          h₀ : x + y = 13
          h₁ : x * y = 24
          eq1 : x ^ 2 + y ^ 2 = (x + y) ^ 2 - 2 * (x * y)
          eq2 : x ^ 2 + y ^ 2 = 11 ^ 2
          ⊢ √(x ^ 2 + y ^ 2) = 11
        prefix: []
      answers:
        - answer: "rw [eq2] ; norm_num"


- strategy: prove_theorem
  args:
    theorem: |
      theorem mathd_numbertheory_780
        (m x : ℤ) (h₀ : 0 ≤ x) (h₁ : 10 ≤ m ∧ m ≤ 99) (h₂ : 6 * x % m = 1)
        (h₃ : (x - 6 ^ 2) % m = 0) : m = 43 := by sorry
  tests:
    - run '#direct' | success
  queries: 
    - query: ProveGoal
      args:
        goal: |-
          m x : ℤ
          h₀ : 0 ≤ x
          h₁ : 10 ≤ m ∧ m ≤ 99
          h₂ : 6 * x % m = 1
          h₃ : (x - 6 ^ 2) % m = 0
          ⊢ m = 43
        prefix: []
      answers:
        - answer: "rcases h₁ ; interval_cases m <;> grind"


- strategy: prove_theorem
  args:
    theorem: |
      theorem amc12b_2003_p17
        (x y : ℝ) (h₀ : 0 < x ∧ 0 < y)
        (h₁ : Real.log (x * y ^ 3) = 1)
        (h₂ : Real.log (x ^ 2 * y) = 1)
        : Real.log (x * y) = 3 / 5 := by sorry
  tests:
    - run | success
  queries: []
  # have: x ≠ 0 := by grind
  # have: y ≠ 0 := by grind
  # have: y^3 ≠ 0 := by grind
  # have: x^2 ≠ 0 := by grind
  # have: Real.log x + 3 * Real.log y = 1 := by rw [Real.log_mul, Real.log_pow] at h₁ <;> grind
  # have: 2 * Real.log x + Real.log y = 1 := by rw [Real.log_mul, Real.log_pow] at h₂ <;> grind
  # have: Real.log x + Real.log y = 3 / 5 := by grind
  # rw [Real.log_mul] <;> grind
