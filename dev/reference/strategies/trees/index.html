
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../../how-to-guides/">
      
      
        <link rel="next" href="../strategies/">
      
      
      <link rel="icon" href="../../../None">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.18">
    
    
      
        <title>Trees and Spaces - Delphyne</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="https://unpkg.com/katex@0/dist/katex.min.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#trees-and-spaces" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Delphyne" class="md-header__button md-logo" aria-label="Delphyne" data-md-component="logo">
      
  <img src="../../../assets/logos/white/mini.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Delphyne
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Trees and Spaces
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Delphyne" class="md-nav__button md-logo" aria-label="Delphyne" data-md-component="logo">
      
  <img src="../../../assets/logos/white/mini.png" alt="logo">

    </a>
    Delphyne
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Getting Started
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Manual
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Manual
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../manual/overview/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../manual/strategies/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Strategies and Trees
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../manual/policies/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Policies
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../manual/demos/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Demonstrations
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../manual/extension/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    VSCode Extension
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../how-to-guides/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    How-To Guides
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Reference
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1" checked>
        
          
          <label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Strategy Language
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4_1">
            <span class="md-nav__icon md-icon"></span>
            Strategy Language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Trees and Spaces
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Trees and Spaces
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#trees" class="md-nav__link">
    <span class="md-ellipsis">
      Trees
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Trees">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.Tree" class="md-nav__link">
    <span class="md-ellipsis">
      Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.Tree.transform" class="md-nav__link">
    <span class="md-ellipsis">
      transform
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Success" class="md-nav__link">
    <span class="md-ellipsis">
      Success
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node" class="md-nav__link">
    <span class="md-ellipsis">
      Node
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Node">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.navigate" class="md-nav__link">
    <span class="md-ellipsis">
      navigate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.summary_message" class="md-nav__link">
    <span class="md-ellipsis">
      summary_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.leaf_node" class="md-nav__link">
    <span class="md-ellipsis">
      leaf_node
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.valid_action" class="md-nav__link">
    <span class="md-ellipsis">
      valid_action
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.primary_space" class="md-nav__link">
    <span class="md-ellipsis">
      primary_space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.get_extra_tags" class="md-nav__link">
    <span class="md-ellipsis">
      get_extra_tags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.fields" class="md-nav__link">
    <span class="md-ellipsis">
      fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.effect_name" class="md-nav__link">
    <span class="md-ellipsis">
      effect_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.get_tags" class="md-nav__link">
    <span class="md-ellipsis">
      get_tags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.primary_space_ref" class="md-nav__link">
    <span class="md-ellipsis">
      primary_space_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.nested_space" class="md-nav__link">
    <span class="md-ellipsis">
      nested_space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.spawn" class="md-nav__link">
    <span class="md-ellipsis">
      spawn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.map_embedded" class="md-nav__link">
    <span class="md-ellipsis">
      map_embedded
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Navigation" class="md-nav__link">
    <span class="md-ellipsis">
      Navigation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.NavigationError" class="md-nav__link">
    <span class="md-ellipsis">
      NavigationError
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#node-fields" class="md-nav__link">
    <span class="md-ellipsis">
      Node Fields
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Node Fields">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields" class="md-nav__link">
    <span class="md-ellipsis">
      node_fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.NodeFields" class="md-nav__link">
    <span class="md-ellipsis">
      NodeFields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.FieldKind" class="md-nav__link">
    <span class="md-ellipsis">
      FieldKind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.FieldKind" class="md-nav__link">
    <span class="md-ellipsis">
      FieldKind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.LeafFieldKind" class="md-nav__link">
    <span class="md-ellipsis">
      LeafFieldKind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.SpaceF" class="md-nav__link">
    <span class="md-ellipsis">
      SpaceF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.EmbeddedF" class="md-nav__link">
    <span class="md-ellipsis">
      EmbeddedF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.ParametricF" class="md-nav__link">
    <span class="md-ellipsis">
      ParametricF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.DataF" class="md-nav__link">
    <span class="md-ellipsis">
      DataF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.SequenceF" class="md-nav__link">
    <span class="md-ellipsis">
      SequenceF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.OptionalF" class="md-nav__link">
    <span class="md-ellipsis">
      OptionalF
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spaces" class="md-nav__link">
    <span class="md-ellipsis">
      Spaces
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Spaces">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.Space" class="md-nav__link">
    <span class="md-ellipsis">
      Space
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Space">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.Space.tags" class="md-nav__link">
    <span class="md-ellipsis">
      tags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Space.source" class="md-nav__link">
    <span class="md-ellipsis">
      source
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Tag" class="md-nav__link">
    <span class="md-ellipsis">
      Tag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.AttachedQuery" class="md-nav__link">
    <span class="md-ellipsis">
      AttachedQuery
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.NestedTree" class="md-nav__link">
    <span class="md-ellipsis">
      NestedTree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.TransparentQuery" class="md-nav__link">
    <span class="md-ellipsis">
      TransparentQuery
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.EmbeddedTree" class="md-nav__link">
    <span class="md-ellipsis">
      EmbeddedTree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.SpaceBuilder" class="md-nav__link">
    <span class="md-ellipsis">
      SpaceBuilder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SpaceBuilder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.SpaceBuilder.tagged" class="md-nav__link">
    <span class="md-ellipsis">
      tagged
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.SpaceBuilder.__call__" class="md-nav__link">
    <span class="md-ellipsis">
      __call__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#miscellaneous" class="md-nav__link">
    <span class="md-ellipsis">
      Miscellaneous
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Miscellaneous">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.ComputationNode" class="md-nav__link">
    <span class="md-ellipsis">
      ComputationNode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.AbstractTreeTransformer" class="md-nav__link">
    <span class="md-ellipsis">
      AbstractTreeTransformer
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../strategies/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Strategies and Reification
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../queries/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Queries and Chats
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../traces/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    References and Traces
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../misc/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Miscellaneous
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2" >
        
          
          <label class="md-nav__link" for="__nav_4_2" id="__nav_4_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Policy Language
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2">
            <span class="md-nav__icon md-icon"></span>
            Policy Language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../policies/definitions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Definitions
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../policies/streams/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Search Streams
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3" >
        
          
          <label class="md-nav__link" for="__nav_4_3" id="__nav_4_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Demonstration Language
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3">
            <span class="md-nav__icon md-icon"></span>
            Demonstration Language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../demos/definitions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Definitions
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../demos/interpreter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Interpreter
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_4" >
        
          
          <label class="md-nav__link" for="__nav_4_4" id="__nav_4_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Standard Library
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_4">
            <span class="md-nav__icon md-icon"></span>
            Standard Library
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../stdlib/basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Basic
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../stdlib/queries/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Queries
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../stdlib/streams/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Streams
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../stdlib/environments/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Environments
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../stdlib/effects/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Effects
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../stdlib/algorithms/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Algorithms
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../stdlib/commands/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Commands
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../stdlib/experiments/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Experiments
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../cli/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Delphyne CLI
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#trees" class="md-nav__link">
    <span class="md-ellipsis">
      Trees
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Trees">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.Tree" class="md-nav__link">
    <span class="md-ellipsis">
      Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.Tree.transform" class="md-nav__link">
    <span class="md-ellipsis">
      transform
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Success" class="md-nav__link">
    <span class="md-ellipsis">
      Success
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node" class="md-nav__link">
    <span class="md-ellipsis">
      Node
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Node">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.navigate" class="md-nav__link">
    <span class="md-ellipsis">
      navigate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.summary_message" class="md-nav__link">
    <span class="md-ellipsis">
      summary_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.leaf_node" class="md-nav__link">
    <span class="md-ellipsis">
      leaf_node
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.valid_action" class="md-nav__link">
    <span class="md-ellipsis">
      valid_action
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.primary_space" class="md-nav__link">
    <span class="md-ellipsis">
      primary_space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.get_extra_tags" class="md-nav__link">
    <span class="md-ellipsis">
      get_extra_tags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.fields" class="md-nav__link">
    <span class="md-ellipsis">
      fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.effect_name" class="md-nav__link">
    <span class="md-ellipsis">
      effect_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.get_tags" class="md-nav__link">
    <span class="md-ellipsis">
      get_tags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.primary_space_ref" class="md-nav__link">
    <span class="md-ellipsis">
      primary_space_ref
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.nested_space" class="md-nav__link">
    <span class="md-ellipsis">
      nested_space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.spawn" class="md-nav__link">
    <span class="md-ellipsis">
      spawn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Node.map_embedded" class="md-nav__link">
    <span class="md-ellipsis">
      map_embedded
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Navigation" class="md-nav__link">
    <span class="md-ellipsis">
      Navigation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.NavigationError" class="md-nav__link">
    <span class="md-ellipsis">
      NavigationError
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#node-fields" class="md-nav__link">
    <span class="md-ellipsis">
      Node Fields
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Node Fields">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields" class="md-nav__link">
    <span class="md-ellipsis">
      node_fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.NodeFields" class="md-nav__link">
    <span class="md-ellipsis">
      NodeFields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.FieldKind" class="md-nav__link">
    <span class="md-ellipsis">
      FieldKind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.FieldKind" class="md-nav__link">
    <span class="md-ellipsis">
      FieldKind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.LeafFieldKind" class="md-nav__link">
    <span class="md-ellipsis">
      LeafFieldKind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.SpaceF" class="md-nav__link">
    <span class="md-ellipsis">
      SpaceF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.EmbeddedF" class="md-nav__link">
    <span class="md-ellipsis">
      EmbeddedF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.ParametricF" class="md-nav__link">
    <span class="md-ellipsis">
      ParametricF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.DataF" class="md-nav__link">
    <span class="md-ellipsis">
      DataF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.SequenceF" class="md-nav__link">
    <span class="md-ellipsis">
      SequenceF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.core.node_fields.OptionalF" class="md-nav__link">
    <span class="md-ellipsis">
      OptionalF
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spaces" class="md-nav__link">
    <span class="md-ellipsis">
      Spaces
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Spaces">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.Space" class="md-nav__link">
    <span class="md-ellipsis">
      Space
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Space">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.Space.tags" class="md-nav__link">
    <span class="md-ellipsis">
      tags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Space.source" class="md-nav__link">
    <span class="md-ellipsis">
      source
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.Tag" class="md-nav__link">
    <span class="md-ellipsis">
      Tag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.AttachedQuery" class="md-nav__link">
    <span class="md-ellipsis">
      AttachedQuery
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.NestedTree" class="md-nav__link">
    <span class="md-ellipsis">
      NestedTree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.TransparentQuery" class="md-nav__link">
    <span class="md-ellipsis">
      TransparentQuery
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.EmbeddedTree" class="md-nav__link">
    <span class="md-ellipsis">
      EmbeddedTree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.SpaceBuilder" class="md-nav__link">
    <span class="md-ellipsis">
      SpaceBuilder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SpaceBuilder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.SpaceBuilder.tagged" class="md-nav__link">
    <span class="md-ellipsis">
      tagged
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.SpaceBuilder.__call__" class="md-nav__link">
    <span class="md-ellipsis">
      __call__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#miscellaneous" class="md-nav__link">
    <span class="md-ellipsis">
      Miscellaneous
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Miscellaneous">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#delphyne.ComputationNode" class="md-nav__link">
    <span class="md-ellipsis">
      ComputationNode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delphyne.AbstractTreeTransformer" class="md-nav__link">
    <span class="md-ellipsis">
      AbstractTreeTransformer
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="trees-and-spaces">Trees and Spaces</h1>
<!-- Covers core.trees, core.node_fields, core.reify -->

<h2 id="trees">Trees</h2>


<div class="doc doc-object doc-class">



<h3 id="delphyne.Tree" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">Tree</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="typing.Generic">Generic</span>[<span title="delphyne.core.trees.N">N</span>, <span title="delphyne.core.trees.P">P</span>, <span title="delphyne.core.trees.T">T</span>]</code></p>


        <p>Strategy Trees.</p>
<p>A strategy tree can be obtained by reifying a strategy computation
(see <a class="autorefs autorefs-internal" title="reify" href="../strategies/#delphyne.reify"><code>reify</code></a>). Its type parameters are: a type signature <code>N</code>, an
associated inner policy type <code>P</code>, and a return type <code>T</code>.</p>
<p>Trees are <strong>immutable</strong>.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="delphyne.Tree.node">node</span></code></td>
            <td>
                  <code><span title="delphyne.core.trees.N">N</span> | <a class="autorefs autorefs-internal" title="Success


  
      dataclass
   (delphyne.core.trees.Success)" href="#delphyne.Success">Success</a>[<span title="delphyne.core.trees.T">T</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The current node of the tree, which is either a success
leaf or a node of type compatible with signature <code>N</code>.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="delphyne.Tree.child">child</span></code></td>
            <td>
                  <code><span title="collections.abc.Callable">Callable</span>[[<a class="autorefs autorefs-internal" title="Value (delphyne.core.refs.Value)" href="../traces/#delphyne.core.refs.Value">Value</a>], <a class="autorefs autorefs-internal" title="Tree


  
      dataclass
   (delphyne.core.trees.Tree)" href="#delphyne.Tree">Tree</a>[<span title="delphyne.core.trees.N">N</span>, <span title="delphyne.core.trees.P">P</span>, <span title="delphyne.core.trees.T">T</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A function that maps an action (i.e., a local value) to a
child tree.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="delphyne.Tree.ref">ref</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="GlobalNodePath (delphyne.core.refs.GlobalNodePath)" href="../traces/#delphyne.core.refs.GlobalNodePath">GlobalNodePath</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A global reference to the node.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <div class="admonition info">
<p class="admonition-title">Locality Invariant</p>
<p>Only <em>local values</em> can be used as actions (passed to <code>child</code>)
or as arguments of parametric local spaces. A <em>local value</em>
consists in an assembly of elements of local spaces (see
<a class="autorefs autorefs-internal" title="Value" href="../traces/#delphyne.core.refs.Value"><code>Value</code></a>). This invariant is enforced at runtime and it
guarantees that a policy can always make progress at any given
node without being provided additional context. It is also a key
assumption for establishing the completeness of the
demonstration language (i.e., a demonstration with a single <code>run
| success</code> test can always be extracted from a successful run of
an oracular program).</p>
</div>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Tree</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Strategy Trees.</span>

<span class="sd">    A strategy tree can be obtained by reifying a strategy computation</span>
<span class="sd">    (see `reify`). Its type parameters are: a type signature `N`, an</span>
<span class="sd">    associated inner policy type `P`, and a return type `T`.</span>

<span class="sd">    Trees are **immutable**.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        node: The current node of the tree, which is either a success</span>
<span class="sd">            leaf or a node of type compatible with signature `N`.</span>
<span class="sd">        child: A function that maps an action (i.e., a local value) to a</span>
<span class="sd">            child tree.</span>
<span class="sd">        ref: A global reference to the node.</span>

<span class="sd">    !!! info &quot;Locality Invariant&quot;</span>
<span class="sd">        Only *local values* can be used as actions (passed to `child`)</span>
<span class="sd">        or as arguments of parametric local spaces. A *local value*</span>
<span class="sd">        consists in an assembly of elements of local spaces (see</span>
<span class="sd">        `Value`). This invariant is enforced at runtime and it</span>
<span class="sd">        guarantees that a policy can always make progress at any given</span>
<span class="sd">        node without being provided additional context. It is also a key</span>
<span class="sd">        assumption for establishing the completeness of the</span>
<span class="sd">        demonstration language (i.e., a demonstration with a single `run</span>
<span class="sd">        | success` test can always be extracted from a successful run of</span>
<span class="sd">        an oracular program).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;N | Success[T]&quot;</span>
    <span class="n">child</span><span class="p">:</span> <span class="s2">&quot;Callable[[Value], Tree[N, P, T]]&quot;</span>
    <span class="n">ref</span><span class="p">:</span> <span class="n">GlobalNodePath</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">[</span><span class="n">M</span><span class="p">:</span> <span class="n">Node</span><span class="p">](</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;M | Success[T]&quot;</span><span class="p">,</span>
        <span class="n">transformer</span><span class="p">:</span> <span class="s2">&quot;AbstractTreeTransformer[N, M]&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Tree[M, P, T]&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively apply a function to all embedded trees and subtrees</span>
<span class="sd">        of a tree.</span>

<span class="sd">        This is a pure method that does not modify its arguments. It is</span>
<span class="sd">        useful to implement tree transformers such as `elim_compute`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">child</span><span class="p">(</span><span class="n">action</span><span class="p">:</span> <span class="n">Value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">M</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">(</span><span class="n">action</span><span class="p">))</span>

        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">map_embedded</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h4 id="delphyne.Tree.transform" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">transform</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">transform</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n"><span title="delphyne.core.trees.Tree.transform[M]">M</span></span> <span class="o">|</span> <span class="n"><a class="autorefs autorefs-internal" title="Success


  
      dataclass
   (delphyne.core.trees.Success)" href="#delphyne.Success">Success</a></span><span class="p">[</span><span class="n"><span title="delphyne.core.trees.T">T</span></span><span class="p">],</span> <span class="n">transformer</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="AbstractTreeTransformer (delphyne.core.trees.AbstractTreeTransformer)" href="#delphyne.AbstractTreeTransformer">AbstractTreeTransformer</a></span><span class="p">[</span><span class="n"><span title="delphyne.core.trees.N">N</span></span><span class="p">,</span> <span class="n"><span title="delphyne.core.trees.Tree.transform[M]">M</span></span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n"><a class="autorefs autorefs-internal" title="Tree


  
      dataclass
   (delphyne.core.trees.Tree)" href="#delphyne.Tree">Tree</a></span><span class="p">[</span><span class="n"><span title="delphyne.core.trees.Tree.transform[M]">M</span></span><span class="p">,</span> <span class="n"><span title="delphyne.core.trees.P">P</span></span><span class="p">,</span> <span class="n"><span title="delphyne.core.trees.T">T</span></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Recursively apply a function to all embedded trees and subtrees
of a tree.</p>
<p>This is a pure method that does not modify its arguments. It is
useful to implement tree transformers such as <a class="autorefs autorefs-internal" title="elim_compute" href="../../stdlib/effects/#delphyne.stdlib.computations.elim_compute"><code>elim_compute</code></a>.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">[</span><span class="n">M</span><span class="p">:</span> <span class="n">Node</span><span class="p">](</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;M | Success[T]&quot;</span><span class="p">,</span>
    <span class="n">transformer</span><span class="p">:</span> <span class="s2">&quot;AbstractTreeTransformer[N, M]&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Tree[M, P, T]&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively apply a function to all embedded trees and subtrees</span>
<span class="sd">    of a tree.</span>

<span class="sd">    This is a pure method that does not modify its arguments. It is</span>
<span class="sd">    useful to implement tree transformers such as `elim_compute`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">child</span><span class="p">(</span><span class="n">action</span><span class="p">:</span> <span class="n">Value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">M</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">(</span><span class="n">action</span><span class="p">))</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">map_embedded</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.Success" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">Success</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">


        <p>A success leaf, carrying a tracked value.</p>
<details class="note">
<summary>Implementation Note</summary>
<p>Although it largely implements the same interface via duck
typing, <a class="autorefs autorefs-internal" title="Success


  
      dataclass
  " href="#delphyne.Success"><code>Success</code></a> does not inherit <a class="autorefs autorefs-internal" title="Node" href="#delphyne.Node"><code>Node</code></a>. The reason is that
<code>Tree[N, P, T].node</code> has type <code>Success[T] | N</code>. If <a class="autorefs autorefs-internal" title="Success


  
      dataclass
  " href="#delphyne.Success"><code>Success</code></a>
inherited <a class="autorefs autorefs-internal" title="Node" href="#delphyne.Node"><code>Node</code></a>, it would be possible for <code>N</code> to include a
value of type <code>Success[T2]</code> for some <code>T2 != T</code>, which we want to
rule out.</p>
</details>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Success</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A success leaf, carrying a tracked value.</span>

<span class="sd">    ??? note &quot;Implementation Note&quot;</span>
<span class="sd">        Although it largely implements the same interface via duck</span>
<span class="sd">        typing, `Success` does not inherit `Node`. The reason is that</span>
<span class="sd">        `Tree[N, P, T].node` has type `Success[T] | N`. If `Success`</span>
<span class="sd">        inherited `Node`, it would be possible for `N` to include a</span>
<span class="sd">        value of type `Success[T2]` for some `T2 != T`, which we want to</span>
<span class="sd">        rule out.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">success</span><span class="p">:</span> <span class="n">Tracked</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">leaf_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">valid_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">navigate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Navigation</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">summary_message</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">primary_space</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">primary_space_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">effect_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">nested_space</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">refs</span><span class="o">.</span><span class="n">SpaceName</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Space</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">map_embedded</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">trans</span><span class="p">:</span> <span class="s2">&quot;AbstractTreeTransformer[Any, Any]&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Success[T]&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.Node" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">Node</span>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="abc.ABC">ABC</span></code></p>


        <p>Abstract type for a tree node.</p>
<p>New effects can be added to the strategy language by subclassing
<a class="autorefs autorefs-internal" title="Node" href="#delphyne.Node"><code>Node</code></a> and then defining a triggering function that calls the
<code>spawn</code> class method (manually defining such a wrapper allows
providing users with precise type annotations: i.e., <a class="autorefs autorefs-internal" title="branch" href="../../stdlib/effects/#delphyne.stdlib.nodes.branch"><code>branch</code></a> for
<a class="autorefs autorefs-internal" title="Branch


  
      dataclass
  " href="../../stdlib/effects/#delphyne.stdlib.nodes.Branch"><code>Branch</code></a>).</p>
<p><strong>Methods to override:</strong></p>
<ul>
<li>The <code>navigate</code> method must be overriden for all node types.</li>
<li>The <code>leaf_node</code> method must be overriden for all leaf nodes.</li>
<li>The following methods are also frequently overriden:
    <code>summary_message</code>, <code>valid_action</code>, <code>primary_space</code>, and
    <code>get_extra_tags</code>.</li>
</ul>
<p>Other methods are implemented via inspection and are not typically
overriden.</p>
<details class="note">
<summary>On the absence of type parameters</summary>
<p>In order to precisely type the fields of node subclasses (e.g.
<a class="autorefs autorefs-internal" title="Branch


  
      dataclass
  " href="../../stdlib/effects/#delphyne.stdlib.nodes.Branch"><code>Branch</code></a>), <a class="autorefs autorefs-internal" title="Node" href="#delphyne.Node"><code>Node</code></a> would need to have type parameters standing
for the surrounding inner policy type, the action type, etc.
However, Python's type system is not expressive enough to
properly constrain such type parameters in the definition of
trees since it lacks GADTs and higher-kinded types. In
particular, the way we express signatures as unions of subtypes
of <a class="autorefs autorefs-internal" title="Node" href="#delphyne.Node"><code>Node</code></a> would not work if <a class="autorefs autorefs-internal" title="Node" href="#delphyne.Node"><code>Node</code></a> were parametric.</p>
<p>As a result, types such as inner policy types and action types
must be represented using <code>Any</code> in the definition of nodes (e.g.
<a class="autorefs autorefs-internal" title="Branch


  
      dataclass
  " href="../../stdlib/effects/#delphyne.stdlib.nodes.Branch"><code>Branch</code></a>) and the type safety of search policy implementations
(e.g. <a class="autorefs autorefs-internal" title="dfs" href="../../stdlib/algorithms/#delphyne.stdlib.search.dfs.dfs"><code>dfs</code></a>) cannot be fully enforced statically. However,
effect <em>triggering functions</em> such as <a class="autorefs autorefs-internal" title="branch" href="../../stdlib/effects/#delphyne.stdlib.nodes.branch"><code>branch</code></a> can typically be
typed precisely, providing static type safety for strategy
writers.</p>
</details>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract type for a tree node.</span>

<span class="sd">    New effects can be added to the strategy language by subclassing</span>
<span class="sd">    `Node` and then defining a triggering function that calls the</span>
<span class="sd">    `spawn` class method (manually defining such a wrapper allows</span>
<span class="sd">    providing users with precise type annotations: i.e., `branch` for</span>
<span class="sd">    `Branch`).</span>

<span class="sd">    **Methods to override:**</span>

<span class="sd">    - The `navigate` method must be overriden for all node types.</span>
<span class="sd">    - The `leaf_node` method must be overriden for all leaf nodes.</span>
<span class="sd">    - The following methods are also frequently overriden:</span>
<span class="sd">        `summary_message`, `valid_action`, `primary_space`, and</span>
<span class="sd">        `get_extra_tags`.</span>

<span class="sd">    Other methods are implemented via inspection and are not typically</span>
<span class="sd">    overriden.</span>

<span class="sd">    ??? note &quot;On the absence of type parameters&quot;</span>
<span class="sd">        In order to precisely type the fields of node subclasses (e.g.</span>
<span class="sd">        `Branch`), `Node` would need to have type parameters standing</span>
<span class="sd">        for the surrounding inner policy type, the action type, etc.</span>
<span class="sd">        However, Python&#39;s type system is not expressive enough to</span>
<span class="sd">        properly constrain such type parameters in the definition of</span>
<span class="sd">        trees since it lacks GADTs and higher-kinded types. In</span>
<span class="sd">        particular, the way we express signatures as unions of subtypes</span>
<span class="sd">        of `Node` would not work if `Node` were parametric.</span>

<span class="sd">        As a result, types such as inner policy types and action types</span>
<span class="sd">        must be represented using `Any` in the definition of nodes (e.g.</span>
<span class="sd">        `Branch`) and the type safety of search policy implementations</span>
<span class="sd">        (e.g. `dfs`) cannot be fully enforced statically. However,</span>
<span class="sd">        effect *triggering functions* such as `branch` can typically be</span>
<span class="sd">        typed precisely, providing static type safety for strategy</span>
<span class="sd">        writers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Methods that **must** be overriden</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">navigate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Navigation&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The navigation method, to be defined for each node type.</span>

<span class="sd">        It should only be called when `self.leaf_node()` returns False.</span>

<span class="sd">        See `Navigation` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="c1"># Methods that are _sometimes_ overriden</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">summary_message</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an optional summary message for the node, to be</span>
<span class="sd">        displayed in the Delphyne extension&#39;s Tree View.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">leaf_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the node is a leaf node (e.g., `Fail`) and False</span>
<span class="sd">        otherwise.</span>

<span class="sd">        Leaf nodes do not have to define `navigate` and are treated</span>
<span class="sd">        specially by the demonstration interpreter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">valid_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether an action is valid.</span>

<span class="sd">        This method is used to dynamically check actions passed to</span>
<span class="sd">        `Tree.child`, **after** the `Tracked` wrapper is removed. By</span>
<span class="sd">        default, it always returns `True` (unless the node is a leaf</span>
<span class="sd">        node, in which case it returns `False`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_node</span><span class="p">()</span> <span class="k">else</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">primary_space</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Space[object] | None&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optionally return the node&#39;s primary space.</span>

<span class="sd">        Primary spaces are useful to shorten space references,</span>
<span class="sd">        especially when writing demonstration tests. For example, if</span>
<span class="sd">        `cands` is the primary space of the current node, then</span>
<span class="sd">        `compare([cands{&#39;&#39;}, cands{&#39;foo bar&#39;}])` can be abbreviated into</span>
<span class="sd">        `compare([&#39;&#39;, &#39;foo bar&#39;])`.</span>

<span class="sd">        By default, all tags of a node&#39;s primary space are also</span>
<span class="sd">        inherited by this node (see `get_tags` method).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_extra_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the extra tags associated with the node, in addition to</span>
<span class="sd">        the default ones inherited from the primary space (see</span>
<span class="sd">        `get_tags` method).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># Inspecting the kinds of node fields</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fields</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NodeFields</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary mapping each field of the node to some</span>
<span class="sd">        metadata (e.g., whether the field denotes a local space).</span>

<span class="sd">        Such metadata is useful in particular to implement `spawn`.</span>

<span class="sd">        The default implementation uses inspection, via</span>
<span class="sd">        `detect_node_structure`. See the</span>
<span class="sd">        [`node_fields`][delphyne.core.node_fields] module for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">detect_node_structure</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">embedded_class</span><span class="o">=</span><span class="n">EmbeddedTree</span><span class="p">,</span> <span class="n">space_class</span><span class="o">=</span><span class="n">Space</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Impossible to autodetect the structure of </span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="c1"># Methods with a sensible default behavior that are _rarely_ overriden</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">effect_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Name of the associated effect.</span>

<span class="sd">        Used for generating message errors and in the VSCode extension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all tags attached to the node.</span>

<span class="sd">        Tags are leveraged by the demonstration language to identify</span>
<span class="sd">        nodes (e.g., `at` test command).</span>

<span class="sd">        By default, this method returns all tags from the primary space</span>
<span class="sd">        (if any), along with any additional tag returned by</span>
<span class="sd">        `get_extra_tags`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">primary</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_space</span><span class="p">())</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">primary</span><span class="o">.</span><span class="n">tags</span><span class="p">(),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">get_extra_tags</span><span class="p">()]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extra_tags</span><span class="p">()</span>

    <span class="c1"># Methods that should not be overriden</span>

    <span class="nd">@final</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">primary_space_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">refs</span><span class="o">.</span><span class="n">SpaceRef</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for returning a reference to the node&#39;s</span>
<span class="sd">        primary space, if it is defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_space</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">space</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">source</span><span class="p">()</span><span class="o">.</span><span class="n">ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@final</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nested_space</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">refs</span><span class="o">.</span><span class="n">SpaceName</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Space</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dynamically retrieve a local space given its name and</span>
<span class="sd">        parameters.</span>

<span class="sd">        For nonparametric spaces, `args` should be the empty tuple.</span>

<span class="sd">        This method is used by the demonstration interpreter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
                <span class="c1"># TODO: we could check that the field is not supposed to be</span>
                <span class="c1"># parametric</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Space</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Space</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Callable</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Space</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span> <span class="n">f</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@final</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spawn</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">spawner</span><span class="p">:</span> <span class="s2">&quot;AbstractBuilderExecutor&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Spawn an instance of the node type, using a dictionary of</span>
<span class="sd">        arguments to populate its fields.</span>

<span class="sd">        Arguments are processed according to their kind (see</span>
<span class="sd">        [delphyne.core.node_fields][]). For example opaque space</span>
<span class="sd">        builders (`Opaque`) are turned into opaque spaces</span>
<span class="sd">        (`OpaqueSpace`) and strategy computations (`StrategyComp`) are</span>
<span class="sd">        turned into embedded trees (`EmbeddedTree`).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">convert</span><span class="p">(</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">refs</span><span class="o">.</span><span class="n">SpaceName</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">nf</span><span class="o">.</span><span class="n">FieldKind</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">match</span> <span class="n">field</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">SpaceF</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">spawner</span><span class="o">.</span><span class="n">nonparametric</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">ParametricF</span><span class="p">(</span><span class="n">nf</span><span class="o">.</span><span class="n">SpaceF</span><span class="p">()):</span>
                    <span class="k">return</span> <span class="n">spawner</span><span class="o">.</span><span class="n">parametric</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">EmbeddedF</span><span class="p">():</span>
                    <span class="n">builder</span> <span class="o">=</span> <span class="n">EmbeddedTree</span><span class="o">.</span><span class="n">builder</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">spawner</span><span class="o">.</span><span class="n">nonparametric</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">ParametricF</span><span class="p">(</span><span class="n">nf</span><span class="o">.</span><span class="n">EmbeddedF</span><span class="p">()):</span>
                    <span class="n">parametric_builder</span> <span class="o">=</span> <span class="n">EmbeddedTree</span><span class="o">.</span><span class="n">parametric_builder</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">spawner</span><span class="o">.</span><span class="n">parametric</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parametric_builder</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">DataF</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">obj</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">SequenceF</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">convert</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">OptionalF</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="n">convert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="kc">False</span>

        <span class="n">args_new</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">fname</span><span class="p">:</span> <span class="n">convert</span><span class="p">(</span><span class="n">refs</span><span class="o">.</span><span class="n">SpaceName</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="p">()),</span> <span class="n">fkind</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">fname</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fkind</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">args_new</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_embedded</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="n">Node</span><span class="p">](</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">N</span><span class="p">,</span> <span class="n">trans</span><span class="p">:</span> <span class="s2">&quot;AbstractTreeTransformer[Any, Any]&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">N</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function to all embedded trees.</span>

<span class="sd">        This is a pure method that returns an updated node. It is useful</span>
<span class="sd">        for implementing `Tree.transform`, which in turn is useful for</span>
<span class="sd">        implementing standard tree transformers such as `elim_join` and</span>
<span class="sd">        `elim_compute`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">convert_embedded</span><span class="p">(</span>
            <span class="n">emb</span><span class="p">:</span> <span class="n">EmbeddedTree</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EmbeddedTree</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">emb</span><span class="p">,</span> <span class="n">EmbeddedTree</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected an EmbeddedTree, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">emb</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">nested</span> <span class="o">=</span> <span class="n">NestedTree</span><span class="p">(</span>
                <span class="n">strategy</span><span class="o">=</span><span class="n">emb</span><span class="o">.</span><span class="n">nested</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span>
                <span class="n">ref</span><span class="o">=</span><span class="n">emb</span><span class="o">.</span><span class="n">nested</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                <span class="n">spawn_tree</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">trans</span><span class="p">(</span><span class="n">emb</span><span class="o">.</span><span class="n">nested</span><span class="o">.</span><span class="n">spawn_tree</span><span class="p">()),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">EmbeddedTree</span><span class="p">(</span><span class="n">nested</span><span class="p">,</span> <span class="n">_tags</span><span class="o">=</span><span class="n">emb</span><span class="o">.</span><span class="n">tags</span><span class="p">())</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">convert_parametric_embedded</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">convert_embedded</span><span class="p">(</span><span class="n">obj</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">convert</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">nf</span><span class="o">.</span><span class="n">FieldKind</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">match</span> <span class="n">field</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">SpaceF</span><span class="p">()</span> <span class="o">|</span> <span class="n">nf</span><span class="o">.</span><span class="n">ParametricF</span><span class="p">(</span><span class="n">nf</span><span class="o">.</span><span class="n">SpaceF</span><span class="p">())</span> <span class="o">|</span> <span class="n">nf</span><span class="o">.</span><span class="n">DataF</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">obj</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">EmbeddedF</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">convert_embedded</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">ParametricF</span><span class="p">(</span><span class="n">nf</span><span class="o">.</span><span class="n">EmbeddedF</span><span class="p">()):</span>
                    <span class="k">return</span> <span class="n">convert_parametric_embedded</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">SequenceF</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">convert</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
                <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">OptionalF</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="kc">False</span>

        <span class="n">args_new</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">fname</span><span class="p">:</span> <span class="n">convert</span><span class="p">(</span><span class="n">fkind</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fkind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="o">**</span><span class="n">args_new</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.navigate" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">navigate</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">navigate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><a class="autorefs autorefs-internal" title="Navigation (delphyne.core.trees.Navigation)" href="#delphyne.Navigation">Navigation</a></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>The navigation method, to be defined for each node type.</p>
<p>It should only be called when <code>self.leaf_node()</code> returns False.</p>
<p>See <a class="autorefs autorefs-internal" title="Navigation" href="#delphyne.Navigation"><code>Navigation</code></a> for details.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abstractmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">navigate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Navigation&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The navigation method, to be defined for each node type.</span>

<span class="sd">    It should only be called when `self.leaf_node()` returns False.</span>

<span class="sd">    See `Navigation` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.summary_message" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">summary_message</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">summary_message</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><span title="str">str</span></span> <span class="o">|</span> <span class="kc">None</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return an optional summary message for the node, to be
displayed in the Delphyne extension's Tree View.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">summary_message</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an optional summary message for the node, to be</span>
<span class="sd">    displayed in the Delphyne extension&#39;s Tree View.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.leaf_node" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">leaf_node</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">leaf_node</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><span title="bool">bool</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return True if the node is a leaf node (e.g., <a class="autorefs autorefs-internal" title="Fail


  
      dataclass
  " href="../../stdlib/effects/#delphyne.stdlib.nodes.Fail"><code>Fail</code></a>) and False
otherwise.</p>
<p>Leaf nodes do not have to define <code>navigate</code> and are treated
specially by the demonstration interpreter.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">leaf_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if the node is a leaf node (e.g., `Fail`) and False</span>
<span class="sd">    otherwise.</span>

<span class="sd">    Leaf nodes do not have to define `navigate` and are treated</span>
<span class="sd">    specially by the demonstration interpreter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.valid_action" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">valid_action</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">valid_action</span><span class="p">(</span><span class="n">action</span><span class="p">:</span> <span class="n"><span title="object">object</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="bool">bool</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return whether an action is valid.</p>
<p>This method is used to dynamically check actions passed to
<code>Tree.child</code>, <strong>after</strong> the <a class="autorefs autorefs-internal" title="Tracked


  
      dataclass
  " href="../traces/#delphyne.core.refs.Tracked"><code>Tracked</code></a> wrapper is removed. By
default, it always returns <code>True</code> (unless the node is a leaf
node, in which case it returns <code>False</code>).</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">valid_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether an action is valid.</span>

<span class="sd">    This method is used to dynamically check actions passed to</span>
<span class="sd">    `Tree.child`, **after** the `Tracked` wrapper is removed. By</span>
<span class="sd">    default, it always returns `True` (unless the node is a leaf</span>
<span class="sd">    node, in which case it returns `False`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">False</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_node</span><span class="p">()</span> <span class="k">else</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.primary_space" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">primary_space</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">primary_space</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><a class="autorefs autorefs-internal" title="Space (delphyne.core.trees.Space)" href="#delphyne.Space">Space</a></span><span class="p">[</span><span class="n"><span title="object">object</span></span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Optionally return the node's primary space.</p>
<p>Primary spaces are useful to shorten space references,
especially when writing demonstration tests. For example, if
<code>cands</code> is the primary space of the current node, then
<code>compare([cands{''}, cands{'foo bar'}])</code> can be abbreviated into
<code>compare(['', 'foo bar'])</code>.</p>
<p>By default, all tags of a node's primary space are also
inherited by this node (see <code>get_tags</code> method).</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">primary_space</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Space[object] | None&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optionally return the node&#39;s primary space.</span>

<span class="sd">    Primary spaces are useful to shorten space references,</span>
<span class="sd">    especially when writing demonstration tests. For example, if</span>
<span class="sd">    `cands` is the primary space of the current node, then</span>
<span class="sd">    `compare([cands{&#39;&#39;}, cands{&#39;foo bar&#39;}])` can be abbreviated into</span>
<span class="sd">    `compare([&#39;&#39;, &#39;foo bar&#39;])`.</span>

<span class="sd">    By default, all tags of a node&#39;s primary space are also</span>
<span class="sd">    inherited by this node (see `get_tags` method).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.get_extra_tags" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">get_extra_tags</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_extra_tags</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><span title="collections.abc.Sequence">Sequence</span></span><span class="p">[</span><span class="n"><a class="autorefs autorefs-internal" title="Tag (delphyne.core.trees.Tag)" href="#delphyne.Tag">Tag</a></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return the extra tags associated with the node, in addition to
the default ones inherited from the primary space (see
<code>get_tags</code> method).</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_extra_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the extra tags associated with the node, in addition to</span>
<span class="sd">    the default ones inherited from the primary space (see</span>
<span class="sd">    `get_tags` method).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.fields" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">fields</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">fields</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><a class="autorefs autorefs-internal" title="NodeFields (delphyne.core.node_fields.NodeFields)" href="#delphyne.core.node_fields.NodeFields">NodeFields</a></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return a dictionary mapping each field of the node to some
metadata (e.g., whether the field denotes a local space).</p>
<p>Such metadata is useful in particular to implement <code>spawn</code>.</p>
<p>The default implementation uses inspection, via
<code>detect_node_structure</code>. See the
<a class="autorefs autorefs-internal" title="delphyne.core.node_fields" href="#delphyne.core.node_fields"><code>node_fields</code></a> module for details.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fields</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NodeFields</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a dictionary mapping each field of the node to some</span>
<span class="sd">    metadata (e.g., whether the field denotes a local space).</span>

<span class="sd">    Such metadata is useful in particular to implement `spawn`.</span>

<span class="sd">    The default implementation uses inspection, via</span>
<span class="sd">    `detect_node_structure`. See the</span>
<span class="sd">    [`node_fields`][delphyne.core.node_fields] module for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">detect_node_structure</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">embedded_class</span><span class="o">=</span><span class="n">EmbeddedTree</span><span class="p">,</span> <span class="n">space_class</span><span class="o">=</span><span class="n">Space</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Impossible to autodetect the structure of </span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>
    <span class="k">return</span> <span class="n">f</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.effect_name" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">effect_name</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">effect_name</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><span title="str">str</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Name of the associated effect.</p>
<p>Used for generating message errors and in the VSCode extension.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">effect_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Name of the associated effect.</span>

<span class="sd">    Used for generating message errors and in the VSCode extension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.get_tags" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">get_tags</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_tags</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><span title="collections.abc.Sequence">Sequence</span></span><span class="p">[</span><span class="n"><a class="autorefs autorefs-internal" title="Tag (delphyne.core.trees.Tag)" href="#delphyne.Tag">Tag</a></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return all tags attached to the node.</p>
<p>Tags are leveraged by the demonstration language to identify
nodes (e.g., <code>at</code> test command).</p>
<p>By default, this method returns all tags from the primary space
(if any), along with any additional tag returned by
<code>get_extra_tags</code>.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return all tags attached to the node.</span>

<span class="sd">    Tags are leveraged by the demonstration language to identify</span>
<span class="sd">    nodes (e.g., `at` test command).</span>

<span class="sd">    By default, this method returns all tags from the primary space</span>
<span class="sd">    (if any), along with any additional tag returned by</span>
<span class="sd">    `get_extra_tags`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">primary</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_space</span><span class="p">())</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">primary</span><span class="o">.</span><span class="n">tags</span><span class="p">(),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">get_extra_tags</span><span class="p">()]</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extra_tags</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.primary_space_ref" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">primary_space_ref</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">primary_space_ref</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><a class="autorefs autorefs-internal" title="SpaceRef


  
      dataclass
   (delphyne.core.refs.SpaceRef)" href="../traces/#delphyne.core.refs.SpaceRef">SpaceRef</a></span> <span class="o">|</span> <span class="kc">None</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Convenience method for returning a reference to the node's
primary space, if it is defined.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@final</span>
<span class="k">def</span><span class="w"> </span><span class="nf">primary_space_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">refs</span><span class="o">.</span><span class="n">SpaceRef</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience method for returning a reference to the node&#39;s</span>
<span class="sd">    primary space, if it is defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_space</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">space</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">source</span><span class="p">()</span><span class="o">.</span><span class="n">ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.nested_space" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">nested_space</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">nested_space</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="SpaceName


  
      dataclass
   (delphyne.core.refs.SpaceName)" href="../traces/#delphyne.core.refs.SpaceName">SpaceName</a></span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n"><span title="tuple">tuple</span></span><span class="p">[</span><span class="n"><a class="autorefs autorefs-internal" title="Value (delphyne.core.refs.Value)" href="../traces/#delphyne.core.refs.Value">Value</a></span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n"><a class="autorefs autorefs-internal" title="Space (delphyne.core.trees.Space)" href="#delphyne.Space">Space</a></span><span class="p">[</span><span class="n"><span title="typing.Any">Any</span></span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Dynamically retrieve a local space given its name and
parameters.</p>
<p>For nonparametric spaces, <code>args</code> should be the empty tuple.</p>
<p>This method is used by the demonstration interpreter.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@final</span>
<span class="k">def</span><span class="w"> </span><span class="nf">nested_space</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">refs</span><span class="o">.</span><span class="n">SpaceName</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Space</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dynamically retrieve a local space given its name and</span>
<span class="sd">    parameters.</span>

<span class="sd">    For nonparametric spaces, `args` should be the empty tuple.</span>

<span class="sd">    This method is used by the demonstration interpreter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">f</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="c1"># TODO: we could check that the field is not supposed to be</span>
            <span class="c1"># parametric</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Space</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Space</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Callable</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Space</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span> <span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.spawn" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">spawn</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">spawn</span><span class="p">(</span><span class="n">spawner</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="AbstractBuilderExecutor (delphyne.core.trees.AbstractBuilderExecutor)" href="../strategies/#delphyne.core.trees.AbstractBuilderExecutor">AbstractBuilderExecutor</a></span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">:</span> <span class="n"><span title="typing.Any">Any</span></span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Spawn an instance of the node type, using a dictionary of
arguments to populate its fields.</p>
<p>Arguments are processed according to their kind (see
<a class="autorefs autorefs-internal" title="delphyne.core.node_fields" href="#delphyne.core.node_fields">delphyne.core.node_fields</a>). For example opaque space
builders (<a class="autorefs autorefs-internal" title="Opaque" href="../../stdlib/basic/#delphyne.Opaque"><code>Opaque</code></a>) are turned into opaque spaces
(<a class="autorefs autorefs-internal" title="OpaqueSpace


  
      dataclass
  " href="../../stdlib/basic/#delphyne.OpaqueSpace"><code>OpaqueSpace</code></a>) and strategy computations (<a class="autorefs autorefs-internal" title="StrategyComp


  
      dataclass
  " href="../strategies/#delphyne.StrategyComp"><code>StrategyComp</code></a>) are
turned into embedded trees (<a class="autorefs autorefs-internal" title="EmbeddedTree


  
      dataclass
  " href="#delphyne.EmbeddedTree"><code>EmbeddedTree</code></a>).</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@final</span>
<span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">spawn</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">spawner</span><span class="p">:</span> <span class="s2">&quot;AbstractBuilderExecutor&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Spawn an instance of the node type, using a dictionary of</span>
<span class="sd">    arguments to populate its fields.</span>

<span class="sd">    Arguments are processed according to their kind (see</span>
<span class="sd">    [delphyne.core.node_fields][]). For example opaque space</span>
<span class="sd">    builders (`Opaque`) are turned into opaque spaces</span>
<span class="sd">    (`OpaqueSpace`) and strategy computations (`StrategyComp`) are</span>
<span class="sd">    turned into embedded trees (`EmbeddedTree`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">convert</span><span class="p">(</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">refs</span><span class="o">.</span><span class="n">SpaceName</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">nf</span><span class="o">.</span><span class="n">FieldKind</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">match</span> <span class="n">field</span><span class="p">:</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">SpaceF</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">spawner</span><span class="o">.</span><span class="n">nonparametric</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">ParametricF</span><span class="p">(</span><span class="n">nf</span><span class="o">.</span><span class="n">SpaceF</span><span class="p">()):</span>
                <span class="k">return</span> <span class="n">spawner</span><span class="o">.</span><span class="n">parametric</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">EmbeddedF</span><span class="p">():</span>
                <span class="n">builder</span> <span class="o">=</span> <span class="n">EmbeddedTree</span><span class="o">.</span><span class="n">builder</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">spawner</span><span class="o">.</span><span class="n">nonparametric</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">ParametricF</span><span class="p">(</span><span class="n">nf</span><span class="o">.</span><span class="n">EmbeddedF</span><span class="p">()):</span>
                <span class="n">parametric_builder</span> <span class="o">=</span> <span class="n">EmbeddedTree</span><span class="o">.</span><span class="n">parametric_builder</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">spawner</span><span class="o">.</span><span class="n">parametric</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parametric_builder</span><span class="p">)</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">DataF</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">SequenceF</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">convert</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">OptionalF</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">convert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>

    <span class="n">args_new</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">fname</span><span class="p">:</span> <span class="n">convert</span><span class="p">(</span><span class="n">refs</span><span class="o">.</span><span class="n">SpaceName</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="p">()),</span> <span class="n">fkind</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">fname</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fkind</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">args_new</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Node.map_embedded" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">map_embedded</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">map_embedded</span><span class="p">(</span><span class="n">trans</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="AbstractTreeTransformer (delphyne.core.trees.AbstractTreeTransformer)" href="#delphyne.AbstractTreeTransformer">AbstractTreeTransformer</a></span><span class="p">[</span><span class="n"><span title="typing.Any">Any</span></span><span class="p">,</span> <span class="n"><span title="typing.Any">Any</span></span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n"><span title="delphyne.core.trees.Node.map_embedded[N]">N</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Apply a function to all embedded trees.</p>
<p>This is a pure method that returns an updated node. It is useful
for implementing <code>Tree.transform</code>, which in turn is useful for
implementing standard tree transformers such as <code>elim_join</code> and
<a class="autorefs autorefs-internal" title="elim_compute" href="../../stdlib/effects/#delphyne.stdlib.computations.elim_compute"><code>elim_compute</code></a>.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@final</span>
<span class="k">def</span><span class="w"> </span><span class="nf">map_embedded</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="n">Node</span><span class="p">](</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">N</span><span class="p">,</span> <span class="n">trans</span><span class="p">:</span> <span class="s2">&quot;AbstractTreeTransformer[Any, Any]&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">N</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a function to all embedded trees.</span>

<span class="sd">    This is a pure method that returns an updated node. It is useful</span>
<span class="sd">    for implementing `Tree.transform`, which in turn is useful for</span>
<span class="sd">    implementing standard tree transformers such as `elim_join` and</span>
<span class="sd">    `elim_compute`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">convert_embedded</span><span class="p">(</span>
        <span class="n">emb</span><span class="p">:</span> <span class="n">EmbeddedTree</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EmbeddedTree</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">emb</span><span class="p">,</span> <span class="n">EmbeddedTree</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected an EmbeddedTree, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">emb</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">nested</span> <span class="o">=</span> <span class="n">NestedTree</span><span class="p">(</span>
            <span class="n">strategy</span><span class="o">=</span><span class="n">emb</span><span class="o">.</span><span class="n">nested</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span>
            <span class="n">ref</span><span class="o">=</span><span class="n">emb</span><span class="o">.</span><span class="n">nested</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
            <span class="n">spawn_tree</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">trans</span><span class="p">(</span><span class="n">emb</span><span class="o">.</span><span class="n">nested</span><span class="o">.</span><span class="n">spawn_tree</span><span class="p">()),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">EmbeddedTree</span><span class="p">(</span><span class="n">nested</span><span class="p">,</span> <span class="n">_tags</span><span class="o">=</span><span class="n">emb</span><span class="o">.</span><span class="n">tags</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">convert_parametric_embedded</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">convert_embedded</span><span class="p">(</span><span class="n">obj</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">convert</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">nf</span><span class="o">.</span><span class="n">FieldKind</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">match</span> <span class="n">field</span><span class="p">:</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">SpaceF</span><span class="p">()</span> <span class="o">|</span> <span class="n">nf</span><span class="o">.</span><span class="n">ParametricF</span><span class="p">(</span><span class="n">nf</span><span class="o">.</span><span class="n">SpaceF</span><span class="p">())</span> <span class="o">|</span> <span class="n">nf</span><span class="o">.</span><span class="n">DataF</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">EmbeddedF</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">convert_embedded</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">ParametricF</span><span class="p">(</span><span class="n">nf</span><span class="o">.</span><span class="n">EmbeddedF</span><span class="p">()):</span>
                <span class="k">return</span> <span class="n">convert_parametric_embedded</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">SequenceF</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">convert</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
            <span class="k">case</span> <span class="n">nf</span><span class="o">.</span><span class="n">OptionalF</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>

    <span class="n">args_new</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">fname</span><span class="p">:</span> <span class="n">convert</span><span class="p">(</span><span class="n">fkind</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fkind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="o">**</span><span class="n">args_new</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="delphyne.Navigation" class="doc doc-heading">
            <span class="doc doc-object-name doc-attribute-name">Navigation</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="n">Navigation</span><span class="p">:</span> <span class="n"><span title="collections.abc.Generator">Generator</span></span><span class="p">[</span><span class="n"><a class="autorefs autorefs-internal" title="Space (delphyne.core.trees.Space)" href="#delphyne.Space">Space</a></span><span class="p">[</span><span class="n"><span title="typing.Any">Any</span></span><span class="p">],</span> <span class="n"><a class="autorefs autorefs-internal" title="Tracked


  
      dataclass
   (delphyne.core.refs.Tracked)" href="../traces/#delphyne.core.refs.Tracked">Tracked</a></span><span class="p">[</span><span class="n"><span title="typing.Any">Any</span></span><span class="p">],</span> <span class="n"><a class="autorefs autorefs-internal" title="Value (delphyne.core.refs.Value)" href="../traces/#delphyne.core.refs.Value">Value</a></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents first">

        <p>A navigation generator.</p>
<p>A navigation generator is returned by the
<a class="autorefs autorefs-internal" title="navigate


  
      abstractmethod
  " href="#delphyne.Node.navigate"><code>navigate</code></a> method of non-leaf nodes. It yields
local spaces and receives corresponding elements until an action is
generated and returned.</p>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.NavigationError" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">NavigationError</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="Exception">Exception</span></code></p>


        <p>Exception raised when an error occurs during navigation.</p>
<p>For internal errors that should not occur within normal use,
assertions shoule be used instead. This exception is meant to
represent errors that can occur during normal use, and reported in
the user interface. For an example, see <a class="autorefs autorefs-internal" title="Abduction


  
      dataclass
  " href="../../stdlib/algorithms/#delphyne.Abduction"><code>Abduction</code></a>.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="delphyne.NavigationError.message">message</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A human-readable error message.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NavigationError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception raised when an error occurs during navigation.</span>

<span class="sd">    For internal errors that should not occur within normal use,</span>
<span class="sd">    assertions shoule be used instead. This exception is meant to</span>
<span class="sd">    represent errors that can occur during normal use, and reported in</span>
<span class="sd">    the user interface. For an example, see `Abduction`.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        message: A human-readable error message.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">message</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div><h2 id="node-fields">Node Fields</h2>


<div class="doc doc-object doc-module">



<h3 id="delphyne.core.node_fields" class="doc doc-heading">
            <span class="doc doc-object-name doc-module-name">delphyne.core.node_fields</span>


</h3>

    <div class="doc doc-contents first">

        <p>Classifying and inferring different kinds of node fields.</p>
<p>When spawning a node via <code>Tree.spawn</code>, different field arguments must be
processed differently. For example, an opaque space builder (<a class="autorefs autorefs-internal" title="Opaque" href="../../stdlib/basic/#delphyne.Opaque"><code>Opaque</code></a>)
must be turned into an opaque space (<a class="autorefs autorefs-internal" title="OpaqueSpace


  
      dataclass
  " href="../../stdlib/basic/#delphyne.OpaqueSpace"><code>OpaqueSpace</code></a>) by providing an
appropriate space reference. Other fields such as data fields must not
be processed.</p>
<p>This module defines a type for classifying node fields (<code>FieldType</code>)
along with a utility function to automatically classify the fields of a
custom node via inspection (<code>detect_node_structure</code>).</p>










  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="delphyne.core.node_fields.NodeFields" class="doc doc-heading">
            <span class="doc doc-object-name doc-attribute-name">NodeFields</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="n">NodeFields</span><span class="p">:</span> <span class="n"><span title="dict">dict</span></span><span class="p">[</span><span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n"><a class="autorefs autorefs-internal" title="FieldKind (delphyne.core.node_fields.FieldKind)" href="#delphyne.core.node_fields.FieldKind">FieldKind</a></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents first">

        <p>A dictionary mapping each field name to its kind.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="delphyne.core.node_fields.FieldKind" class="doc doc-heading">
            <span class="doc doc-object-name doc-attribute-name">FieldKind</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="n">FieldKind</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="LeafFieldKind (delphyne.core.node_fields.LeafFieldKind)" href="#delphyne.core.node_fields.LeafFieldKind">LeafFieldKind</a></span> <span class="o">|</span> <span class="n"><a class="autorefs autorefs-internal" title="SequenceF


  
      dataclass
   (delphyne.core.node_fields.SequenceF)" href="#delphyne.core.node_fields.SequenceF">SequenceF</a></span> <span class="o">|</span> <span class="n"><a class="autorefs autorefs-internal" title="OptionalF


  
      dataclass
   (delphyne.core.node_fields.OptionalF)" href="#delphyne.core.node_fields.OptionalF">OptionalF</a></span>
</code></pre></div>

    <div class="doc doc-contents first">

        <p>Kind of a node field.</p>
<p>A node field can be an embedded tree, another local space, a parametric
embedded tree or space, a sequence of such elements or an optional
element.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="delphyne.core.node_fields.FieldKind" class="doc doc-heading">
            <span class="doc doc-object-name doc-attribute-name">FieldKind</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="n">FieldKind</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="LeafFieldKind (delphyne.core.node_fields.LeafFieldKind)" href="#delphyne.core.node_fields.LeafFieldKind">LeafFieldKind</a></span> <span class="o">|</span> <span class="n"><a class="autorefs autorefs-internal" title="SequenceF


  
      dataclass
   (delphyne.core.node_fields.SequenceF)" href="#delphyne.core.node_fields.SequenceF">SequenceF</a></span> <span class="o">|</span> <span class="n"><a class="autorefs autorefs-internal" title="OptionalF


  
      dataclass
   (delphyne.core.node_fields.OptionalF)" href="#delphyne.core.node_fields.OptionalF">OptionalF</a></span>
</code></pre></div>

    <div class="doc doc-contents first">

        <p>Kind of a node field.</p>
<p>A node field can be an embedded tree, another local space, a parametric
embedded tree or space, a sequence of such elements or an optional
element.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="delphyne.core.node_fields.LeafFieldKind" class="doc doc-heading">
            <span class="doc doc-object-name doc-attribute-name">LeafFieldKind</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="n">LeafFieldKind</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="SpaceF


  
      dataclass
   (delphyne.core.node_fields.SpaceF)" href="#delphyne.core.node_fields.SpaceF">SpaceF</a></span> <span class="o">|</span> <span class="n"><a class="autorefs autorefs-internal" title="EmbeddedF


  
      dataclass
   (delphyne.core.node_fields.EmbeddedF)" href="#delphyne.core.node_fields.EmbeddedF">EmbeddedF</a></span> <span class="o">|</span> <span class="n"><a class="autorefs autorefs-internal" title="DataF


  
      dataclass
   (delphyne.core.node_fields.DataF)" href="#delphyne.core.node_fields.DataF">DataF</a></span> <span class="o">|</span> <span class="n"><a class="autorefs autorefs-internal" title="ParametricF


  
      dataclass
   (delphyne.core.node_fields.ParametricF)" href="#delphyne.core.node_fields.ParametricF">ParametricF</a></span>
</code></pre></div>

    <div class="doc doc-contents first">

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.core.node_fields.SpaceF" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">SpaceF</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">


        <p>A space field that does not correspond to an embedded nested tree.</p>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/node_fields.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SpaceF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A space field that does not correspond to an embedded nested tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.core.node_fields.EmbeddedF" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">EmbeddedF</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">


        <p>A field corresponding to a nested embedded space.</p>
<p>Recognizing this particular case is useful so that triggering
functions can directly accept strategy computations as arguments
(<a class="autorefs autorefs-internal" title="StrategyComp


  
      dataclass
  " href="../strategies/#delphyne.StrategyComp"><code>StrategyComp</code></a>) instead of space builders (<a class="autorefs autorefs-internal" title="SpaceBuilder


  
      dataclass
  " href="#delphyne.SpaceBuilder"><code>SpaceBuilder</code></a>).</p>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/node_fields.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">EmbeddedF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A field corresponding to a nested embedded space.</span>

<span class="sd">    Recognizing this particular case is useful so that triggering</span>
<span class="sd">    functions can directly accept strategy computations as arguments</span>
<span class="sd">    (`StrategyComp`) instead of space builders (`SpaceBuilder`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.core.node_fields.ParametricF" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">ParametricF</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">


        <p>A field corresponding to a parametric space.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="delphyne.core.node_fields.ParametricF.res">res</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="SpaceF


  
      dataclass
   (delphyne.core.node_fields.SpaceF)" href="#delphyne.core.node_fields.SpaceF">SpaceF</a> | <a class="autorefs autorefs-internal" title="EmbeddedF


  
      dataclass
   (delphyne.core.node_fields.EmbeddedF)" href="#delphyne.core.node_fields.EmbeddedF">EmbeddedF</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>kind of the result space.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/node_fields.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ParametricF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A field corresponding to a parametric space.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        res: kind of the result space.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">res</span><span class="p">:</span> <span class="n">SpaceF</span> <span class="o">|</span> <span class="n">EmbeddedF</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.core.node_fields.DataF" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">DataF</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">


        <p>A field that corresponds to some other kind of data.</p>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/node_fields.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DataF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A field that corresponds to some other kind of data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.core.node_fields.SequenceF" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">SequenceF</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">


        <p>A field corresponding to a sequence of spaces.</p>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/node_fields.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SequenceF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A field corresponding to a sequence of spaces.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;FieldKind&quot;</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.core.node_fields.OptionalF" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">OptionalF</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">


        <p>A field corresponding to a sequence of spaces.</p>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/node_fields.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OptionalF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A field corresponding to a sequence of spaces.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;FieldKind&quot;</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div><h2 id="spaces">Spaces</h2>


<div class="doc doc-object doc-class">



<h3 id="delphyne.Space" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">Space</span>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="abc.ABC">ABC</span></code></p>


        <p>Abstract type for a space.</p>
<p>Tree nodes feature local spaces (possibly parametric), that are
backed by either queries or nested trees. Examples of spaces
include <a class="autorefs autorefs-internal" title="EmbeddedTree


  
      dataclass
  " href="#delphyne.EmbeddedTree"><code>EmbeddedTree</code></a>, <a class="autorefs autorefs-internal" title="OpaqueSpace


  
      dataclass
  " href="../../stdlib/basic/#delphyne.OpaqueSpace"><code>OpaqueSpace</code></a> and <a class="autorefs autorefs-internal" title="TransparentQuery


  
      dataclass
  " href="#delphyne.TransparentQuery"><code>TransparentQuery</code></a>.</p>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Space</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract type for a space.</span>

<span class="sd">    Tree nodes feature local spaces (possibly parametric), that are</span>
<span class="sd">    backed by either queries or nested trees. Examples of spaces</span>
<span class="sd">    include `EmbeddedTree`, `OpaqueSpace` and `TransparentQuery`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tags associated with the space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;NestedTree[Any, Any, T] | AttachedQuery[T]&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the source of the space, which is either a nested tree</span>
<span class="sd">        or an attached query.</span>

<span class="sd">        This method is mostly useful to the demonstration interpreter.</span>
<span class="sd">        It is not typically used in policies since it breaks</span>
<span class="sd">        abstraction (e.g., whether or not an opaque space is defined via</span>
<span class="sd">        a query or a strategy is irrelevant).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h4 id="delphyne.Space.tags" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">tags</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">tags</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><span title="collections.abc.Sequence">Sequence</span></span><span class="p">[</span><span class="n"><a class="autorefs autorefs-internal" title="Tag (delphyne.core.trees.Tag)" href="#delphyne.Tag">Tag</a></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return the tags associated with the space.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abstractmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the tags associated with the space.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.Space.source" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">source</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">source</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><a class="autorefs autorefs-internal" title="NestedTree


  
      dataclass
   (delphyne.core.trees.NestedTree)" href="#delphyne.NestedTree">NestedTree</a></span><span class="p">[</span><span class="n"><span title="typing.Any">Any</span></span><span class="p">,</span> <span class="n"><span title="typing.Any">Any</span></span><span class="p">,</span> <span class="n"><span title="delphyne.core.trees.Space[T]">T</span></span><span class="p">]</span> <span class="o">|</span> <span class="n"><a class="autorefs autorefs-internal" title="AttachedQuery


  
      dataclass
   (delphyne.core.trees.AttachedQuery)" href="#delphyne.AttachedQuery">AttachedQuery</a></span><span class="p">[</span><span class="n"><span title="delphyne.core.trees.Space[T]">T</span></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return the source of the space, which is either a nested tree
or an attached query.</p>
<p>This method is mostly useful to the demonstration interpreter.
It is not typically used in policies since it breaks
abstraction (e.g., whether or not an opaque space is defined via
a query or a strategy is irrelevant).</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abstractmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;NestedTree[Any, Any, T] | AttachedQuery[T]&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the source of the space, which is either a nested tree</span>
<span class="sd">    or an attached query.</span>

<span class="sd">    This method is mostly useful to the demonstration interpreter.</span>
<span class="sd">    It is not typically used in policies since it breaks</span>
<span class="sd">    abstraction (e.g., whether or not an opaque space is defined via</span>
<span class="sd">    a query or a strategy is irrelevant).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="delphyne.Tag" class="doc doc-heading">
            <span class="doc doc-object-name doc-attribute-name">Tag</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="n">Tag</span><span class="p">:</span> <span class="n"><span title="str">str</span></span>
</code></pre></div>

    <div class="doc doc-contents first">

        <p>String tags for nodes and spaces.</p>
<p>Nodes and spaces can be assigned string identifiers, which may be
referenced in demonstration tests or when defining inner policies
(e.g., <a class="autorefs autorefs-internal" title="IPDict" href="../../stdlib/basic/#delphyne.IPDict"><code>IPDict</code></a>). Tags should contain only alphanumeric characters,
underscores, dots, and dashes.</p>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.AttachedQuery" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">AttachedQuery</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">


        <p>Wrapper for a query attached to a specific space.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="delphyne.AttachedQuery.query">query</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="AbstractQuery (delphyne.core.queries.AbstractQuery)" href="../queries/#delphyne.AbstractQuery">AbstractQuery</a>[<span title="delphyne.core.trees.AttachedQuery[T]">T</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The wrapped query.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="delphyne.AttachedQuery.ref">ref</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="GlobalSpacePath (delphyne.core.refs.GlobalSpacePath)" href="../traces/#delphyne.core.refs.GlobalSpacePath">GlobalSpacePath</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A global reference to the space to which the query is
attached.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="delphyne.AttachedQuery.parse_answer">parse_answer</span></code></td>
            <td>
                  <code><span title="collections.abc.Callable">Callable</span>[[<a class="autorefs autorefs-internal" title="Answer


  
      dataclass
   (delphyne.core.refs.Answer)" href="../traces/#delphyne.Answer">Answer</a>], <a class="autorefs autorefs-internal" title="Tracked


  
      dataclass
   (delphyne.core.refs.Tracked)" href="../traces/#delphyne.core.refs.Tracked">Tracked</a>[<span title="delphyne.core.trees.AttachedQuery[T]">T</span>] | <a class="autorefs autorefs-internal" title="ParseError


  
      dataclass
   (delphyne.core.queries.ParseError)" href="../queries/#delphyne.ParseError">ParseError</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A wrapper around <code>self.query.parse_answer</code>,
which attaches proper tracking information to answers.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AttachedQuery</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for a query attached to a specific space.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        query: The wrapped query.</span>
<span class="sd">        ref: A global reference to the space to which the query is</span>
<span class="sd">            attached.</span>
<span class="sd">        parse_answer: A wrapper around `self.query.parse_answer`,</span>
<span class="sd">            which attaches proper tracking information to answers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">query</span><span class="p">:</span> <span class="n">AbstractQuery</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
    <span class="n">ref</span><span class="p">:</span> <span class="n">refs</span><span class="o">.</span><span class="n">GlobalSpacePath</span>
    <span class="n">parse_answer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">refs</span><span class="o">.</span><span class="n">Answer</span><span class="p">],</span> <span class="n">Tracked</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">|</span> <span class="n">ParseError</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.NestedTree" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">NestedTree</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">


        <p>Wrapper for a tree attached to a particular node.</p>
<p>The <a class="autorefs autorefs-internal" title="AttachedQuery


  
      dataclass
  " href="#delphyne.AttachedQuery"><code>AttachedQuery</code></a> type plays an equivalent role for queries.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>One cannot count on the <a class="autorefs autorefs-internal" title="strategy" href="../../stdlib/basic/#delphyne.strategy"><code>strategy</code></a> field having the same node
type as <code>spawn_tree</code> since nested trees can be applied tree
transformers (see <code>Node.map_embedded</code>).</p>
</div>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NestedTree</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for a tree attached to a particular node.</span>

<span class="sd">    The `AttachedQuery` type plays an equivalent role for queries.</span>

<span class="sd">    !!! note</span>
<span class="sd">        One cannot count on the `strategy` field having the same node</span>
<span class="sd">        type as `spawn_tree` since nested trees can be applied tree</span>
<span class="sd">        transformers (see `Node.map_embedded`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">strategy</span><span class="p">:</span> <span class="n">StrategyComp</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]</span>
    <span class="n">ref</span><span class="p">:</span> <span class="n">refs</span><span class="o">.</span><span class="n">GlobalSpacePath</span>
    <span class="n">spawn_tree</span><span class="p">:</span> <span class="s2">&quot;Callable[[], Tree[N, P, T]]&quot;</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.TransparentQuery" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">TransparentQuery</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="Space (delphyne.core.trees.Space)" href="#delphyne.Space">Space</a>[<span title="delphyne.core.trees.TransparentQuery[T]">T</span>]</code></p>


        <p>A space that is defined by a single, <em>transparent</em> query.</p>
<p>As opposed to <a class="autorefs autorefs-internal" title="OpaqueSpace


  
      dataclass
  " href="../../stdlib/basic/#delphyne.OpaqueSpace"><code>OpaqueSpace</code></a>, the query is meant to be directly
exposed to policies. This is used to define <a class="autorefs autorefs-internal" title="Compute


  
      dataclass
  " href="../../stdlib/effects/#delphyne.stdlib.computations.Compute"><code>Compute</code></a> and <a class="autorefs autorefs-internal" title="Flag


  
      dataclass
  " href="../../stdlib/effects/#delphyne.Flag"><code>Flag</code></a>
nodes for example.</p>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TransparentQuery</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Space</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A space that is defined by a single, *transparent* query.</span>

<span class="sd">    As opposed to `OpaqueSpace`, the query is meant to be directly</span>
<span class="sd">    exposed to policies. This is used to define `Compute` and `Flag`</span>
<span class="sd">    nodes for example.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attached</span><span class="p">:</span> <span class="n">AttachedQuery</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
    <span class="n">_tags</span><span class="p">:</span> <span class="s2">&quot;Sequence[Tag]&quot;</span>

    <span class="nd">@override</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AttachedQuery</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attached</span>

    <span class="nd">@override</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">[</span><span class="n">T1</span><span class="p">](</span>
        <span class="n">query</span><span class="p">:</span> <span class="n">AbstractQuery</span><span class="p">[</span><span class="n">T1</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SpaceBuilder[TransparentQuery[T1]]&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SpaceBuilder</span><span class="p">(</span>
            <span class="n">build</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">spawner</span><span class="p">,</span> <span class="n">tags</span><span class="p">:</span> <span class="n">TransparentQuery</span><span class="p">(</span>
                <span class="n">spawner</span><span class="p">(</span><span class="n">query</span><span class="p">),</span> <span class="n">tags</span>
            <span class="p">),</span>
            <span class="n">tags</span><span class="o">=</span><span class="n">query</span><span class="o">.</span><span class="n">default_tags</span><span class="p">(),</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.EmbeddedTree" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">EmbeddedTree</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="Space (delphyne.core.trees.Space)" href="#delphyne.Space">Space</a>[<span title="delphyne.core.trees.EmbeddedTree[T]">T</span>]</code></p>


        <p>Space defined by a nested tree with the same signature and inner
policy as its surrounding tree.</p>
<p>This is useful to define effects such as <a class="autorefs autorefs-internal" title="Join


  
      dataclass
  " href="../../stdlib/effects/#delphyne.stdlib.nodes.Join"><code>Join</code></a>.</p>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">EmbeddedTree</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">](</span><span class="n">Space</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Space defined by a nested tree with the same signature and inner</span>
<span class="sd">    policy as its surrounding tree.</span>

<span class="sd">    This is useful to define effects such as `Join`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nested</span><span class="p">:</span> <span class="n">NestedTree</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]</span>
    <span class="n">_tags</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">builder</span><span class="p">[</span><span class="n">N1</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">T1</span><span class="p">](</span>
        <span class="n">strategy</span><span class="p">:</span> <span class="n">StrategyComp</span><span class="p">[</span><span class="n">N1</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">T1</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SpaceBuilder[EmbeddedTree[N1, P1, T1]]&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SpaceBuilder</span><span class="p">[</span><span class="n">EmbeddedTree</span><span class="p">[</span><span class="n">N1</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">T1</span><span class="p">]](</span>
            <span class="n">build</span><span class="o">=</span><span class="k">lambda</span> <span class="n">spawn</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">tags</span><span class="p">:</span> <span class="n">EmbeddedTree</span><span class="p">(</span><span class="n">spawn</span><span class="p">(</span><span class="n">strategy</span><span class="p">),</span> <span class="n">tags</span><span class="p">),</span>
            <span class="n">tags</span><span class="o">=</span><span class="n">strategy</span><span class="o">.</span><span class="n">default_tags</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parametric_builder</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">N1</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">T1</span><span class="p">](</span>
        <span class="n">parametric_strategy</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">A</span><span class="p">],</span> <span class="n">StrategyComp</span><span class="p">[</span><span class="n">N1</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">T1</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Callable[[A], SpaceBuilder[EmbeddedTree[N1, P1, T1]]]&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">EmbeddedTree</span><span class="o">.</span><span class="n">builder</span><span class="p">(</span><span class="n">parametric_strategy</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;NestedTree[Any, Any, T]&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">spawn_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Tree[N, P, T]&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="o">.</span><span class="n">spawn_tree</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.SpaceBuilder" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">SpaceBuilder</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h3>


    <div class="doc doc-contents first">


        <p>Wrapper for a function that builds a space, given the ability to
spawn nested trees and attached queries.</p>
<p>Effect triggering functions such as <a class="autorefs autorefs-internal" title="branch" href="../../stdlib/effects/#delphyne.stdlib.nodes.branch"><code>branch</code></a> do not directly take
spaces as their arguments but space builders instead.</p>
<p>Space builders are also equipped with modifiable tags, to be
ultimately passed to the resulting space.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="delphyne.SpaceBuilder.build">build</span></code></td>
            <td>
                  <code><span title="collections.abc.Callable">Callable</span>[[<a class="autorefs autorefs-internal" title="NestedTreeSpawner (delphyne.core.trees.NestedTreeSpawner)" href="../strategies/#delphyne.core.trees.NestedTreeSpawner">NestedTreeSpawner</a>, <a class="autorefs autorefs-internal" title="QuerySpawner (delphyne.core.trees.QuerySpawner)" href="../strategies/#delphyne.core.trees.QuerySpawner">QuerySpawner</a>, <span title="collections.abc.Sequence">Sequence</span>[<a class="autorefs autorefs-internal" title="Tag (delphyne.core.trees.Tag)" href="#delphyne.Tag">Tag</a>]], <span title="delphyne.core.trees.SpaceBuilder[S]">S</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Wrapped builder function</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="delphyne.SpaceBuilder.tags">tags</span></code></td>
            <td>
                  <code><span title="collections.abc.Sequence">Sequence</span>[<a class="autorefs autorefs-internal" title="Tag (delphyne.core.trees.Tag)" href="#delphyne.Tag">Tag</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Tags to be assocaited to the space.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SpaceBuilder</span><span class="p">[</span><span class="n">S</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for a function that builds a space, given the ability to</span>
<span class="sd">    spawn nested trees and attached queries.</span>

<span class="sd">    Effect triggering functions such as `branch` do not directly take</span>
<span class="sd">    spaces as their arguments but space builders instead.</span>

<span class="sd">    Space builders are also equipped with modifiable tags, to be</span>
<span class="sd">    ultimately passed to the resulting space.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        build: Wrapped builder function</span>
<span class="sd">        tags: Tags to be assocaited to the space.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">build</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">NestedTreeSpawner</span><span class="p">,</span> <span class="n">QuerySpawner</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]],</span> <span class="n">S</span><span class="p">]</span>
    <span class="n">tags</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tag</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tagged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tags</span><span class="p">:</span> <span class="n">Tag</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SpaceBuilder[S]&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add new tags to the space builder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">,</span> <span class="o">*</span><span class="n">tags</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">spawner</span><span class="p">:</span> <span class="n">NestedTreeSpawner</span><span class="p">,</span> <span class="n">query_spawner</span><span class="p">:</span> <span class="n">QuerySpawner</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a space, given the provided capabilities along with the</span>
<span class="sd">        current set of tags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">spawner</span><span class="p">,</span> <span class="n">query_spawner</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h4 id="delphyne.SpaceBuilder.tagged" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">tagged</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">tagged</span><span class="p">(</span><span class="o">*</span><span class="n">tags</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="Tag (delphyne.core.trees.Tag)" href="#delphyne.Tag">Tag</a></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><a class="autorefs autorefs-internal" title="SpaceBuilder


  
      dataclass
   (delphyne.core.trees.SpaceBuilder)" href="#delphyne.SpaceBuilder">SpaceBuilder</a></span><span class="p">[</span><span class="n"><span title="delphyne.core.trees.SpaceBuilder[S]">S</span></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Add new tags to the space builder.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">tagged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tags</span><span class="p">:</span> <span class="n">Tag</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SpaceBuilder[S]&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add new tags to the space builder.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">,</span> <span class="o">*</span><span class="n">tags</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="delphyne.SpaceBuilder.__call__" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">__call__</span>


</h4>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">__call__</span><span class="p">(</span><span class="n">spawner</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="NestedTreeSpawner (delphyne.core.trees.NestedTreeSpawner)" href="../strategies/#delphyne.core.trees.NestedTreeSpawner">NestedTreeSpawner</a></span><span class="p">,</span> <span class="n">query_spawner</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="QuerySpawner (delphyne.core.trees.QuerySpawner)" href="../strategies/#delphyne.core.trees.QuerySpawner">QuerySpawner</a></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="delphyne.core.trees.SpaceBuilder[S]">S</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Build a space, given the provided capabilities along with the
current set of tags.</p>


            <details class="quote">
              <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">spawner</span><span class="p">:</span> <span class="n">NestedTreeSpawner</span><span class="p">,</span> <span class="n">query_spawner</span><span class="p">:</span> <span class="n">QuerySpawner</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a space, given the provided capabilities along with the</span>
<span class="sd">    current set of tags.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">spawner</span><span class="p">,</span> <span class="n">query_spawner</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="miscellaneous">Miscellaneous</h2>


<div class="doc doc-object doc-class">



<h3 id="delphyne.ComputationNode" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">ComputationNode</span>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="Node (delphyne.core.trees.Node)" href="#delphyne.Node">Node</a></code></p>


        <p>Abstract type for computation nodes.</p>
<p>A computation node has an additional method that can be called to
compute an <em>answer</em>. The demonstration interpreter uses this
information to navigate computation nodes while accumulating
implicit answers.</p>
<p>The standard <a class="autorefs autorefs-internal" title="Compute


  
      dataclass
  " href="../../stdlib/effects/#delphyne.stdlib.computations.Compute"><code>Compute</code></a> node inherits this class.</p>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ComputationNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract type for computation nodes.</span>

<span class="sd">    A computation node has an additional method that can be called to</span>
<span class="sd">    compute an _answer_. The demonstration interpreter uses this</span>
<span class="sd">    information to navigate computation nodes while accumulating</span>
<span class="sd">    implicit answers.</span>

<span class="sd">    The standard `Compute` node inherits this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run_computation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="delphyne.AbstractTreeTransformer" class="doc doc-heading">
            <span class="doc doc-object-name doc-class-name">AbstractTreeTransformer</span>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="typing.Protocol">Protocol</span></code></p>


        <p>A function that transforms any tree with signature N into a tree
with signature M, preserving its inner policy type and return type.</p>








              <details class="quote">
                <summary>Source code in <code>src/delphyne/core/trees.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AbstractTreeTransformer</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">Node</span><span class="p">](</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function that transforms any tree with signature N into a tree</span>
<span class="sd">    with signature M, preserving its inner policy type and return type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="s2">&quot;Tree[N, P, T]&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Tree[M, P, T]&quot;</span><span class="p">:</span> <span class="o">...</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.annotate", "content.code.copy", "content.tabs.link", "navigation.indexes"], "search": "../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.92b07e13.min.js"></script>
      
        <script src="../../../javascript/katex.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/katex.min.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>