{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Delphyne is a programming framework for building reliable and modular LLM applications. It is based on a new paradigm named oracular programming, where high-level problem-solving strategies are expressed as nondeterministic programs whose choice points are annotated with examples and resolved by LLMs. Delphyne combines three languages:</p> <ul> <li>A strategy language embedded in Python that allows writing nondeterministic programs that can be reified into (modular) search trees.</li> <li>A policy language for specifying ways to navigate such trees (with LLM guidance) by composing reusable search primitives.</li> <li>A demonstration language for describing successful and unsuccessful search scenarios to be used as training or prompting examples. A dedicated language server allows writing demonstrations interactively and keeping them synchronized with evolving strategies.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>First, download the Delphyne repository and enter it:</p> <pre><code>git clone git@github.com:jonathan-laurent/delphyne.git\ncd delphyne\n</code></pre> <p>Then, to install the Delphyne library in your current Python environment:</p> <pre><code>pip install -e .\n</code></pre> <p>Note that Python 3.12 (or more recent) is required. Once this is done, it should be possible to run <code>import delphyne</code> inside a Python interpreter. Next, you should build the Delphyne vscode extension. For this, assuming you have Node.js installed (version 22 or later), run:</p> <pre><code>cd vscode-ui\nnpm install\nnpx vsce package\n</code></pre> <p>The last command should create a <code>delphyne-xxx.vsix</code> extensions archive, which can be installed in vscode using the <code>Extensions: Install from VSIX</code> command (use <code>Ctrl+Shift+P</code> to search for this command).</p>"},{"location":"#testing-your-installation","title":"Testing your installation","text":"<p>To test your installation, open VSCode and set the <code>examples/find_invariants</code> folder as your workspace root. Click on the Delphyne logo on the Activity Bar to start the Delphyne extension, and open the demonstration file <code>abduct_and_branch.demo.yaml</code>. Then, open the command palette (<code>Ctrl+Shift+P</code>) and run the command <code>Delphyne: Evaluate All Demonstrations in File</code>. Diagnostics should then appear to indicate that all tests passed (but no warning or error). Note that adding new demonstrations requires installing <code>why3py</code>, as explained in the example's README.</p>"},{"location":"how-to-guides/","title":"How-To Guides","text":""},{"location":"how-to-guides/#creating-a-new-delphyne-project","title":"Creating a New Delphyne Project","text":""},{"location":"how-to-guides/#running-an-oracular-program","title":"Running an Oracular Program","text":""},{"location":"how-to-guides/#debugging-an-oracular-program","title":"Debugging an Oracular Program","text":""},{"location":"how-to-guides/#defining-a-new-effect","title":"Defining a New Effect","text":""},{"location":"how-to-guides/#defining-a-new-policy","title":"Defining a New Policy","text":""},{"location":"how-to-guides/#writing-a-conversational-agent","title":"Writing a Conversational Agent","text":""},{"location":"how-to-guides/#performing-expensive-or-non-replicable-computations-in-strategies","title":"Performing Expensive Or Non-Replicable Computations in Strategies","text":""},{"location":"dev/test-markdown/","title":"MkDocs Tricks","text":"<p>Use <code>!!!</code> to introduce admonitions and <code>???</code> for collapsible admonitions (<code>???+</code> for collapsible but expanded by default). Supported kinds include: <code>note</code>, <code>abstract</code>, <code>info</code>, <code>tip</code>, <code>success</code>, <code>question</code>, <code>warning</code>, <code>failure</code>, <code>danger</code>, <code>bug</code>, <code>example</code>, <code>quote</code>.</p> <p>You need to learn stuff</p> <p>Here is an example.</p> You can expand this <pre><code>def fun(x):\n    return x + 1\n</code></pre> <p>I can display some code:</p> <pre><code>@strategy(dfs)\ndef my_strategy(spec): # (1)!\n    prog = yield from branch(AskProg(spec))\n</code></pre> <ol> <li>I am not using any return type here.</li> </ol> <p>I can show some math: \\[ \\int_0^1 F \\varphi(u) du. \\]</p> <p>I can display keyboard keys: Ctrl+Shift+Del or Ctrl+. or Cmd+..</p> <p>I can also include some snippets:</p> <pre><code>\"\"\"\nTypes for representing LLM chat histories.\n\"\"\"\n\nfrom collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom typing import Any, Literal\n\nfrom delphyne.core.refs import Answer, Structured, ToolCall\n\n\n@dataclass(frozen=True)\nclass OracleMessage:\n    \"\"\"\n    Messge containing an oracle answer.\n    \"\"\"\n\n    kind: Literal[\"oracle\"]\n    answer: Answer\n\n\n@dataclass(frozen=True)\nclass FeedbackMessage:\n    \"\"\"\n    Message containing user feedback.\n    \"\"\"\n\n    kind: Literal[\"feedback\"]\n    label: str | None = None\n    description: str | None = None\n    meta: Any | None = None  # must be serializable\n\n\n@dataclass(frozen=True)\nclass ToolResult:\n    \"\"\"\n    User message containing the result of a tool call previously\n    initiated by an LLM.\n    \"\"\"\n\n    kind: Literal[\"tool\"]\n    call: ToolCall\n    result: str | Structured\n\n\ntype AnswerPrefixElement = OracleMessage | FeedbackMessage | ToolResult\n\"\"\"\nLLM chat history element.\n\"\"\"\n\n\ntype AnswerPrefix = Sequence[AnswerPrefixElement]\n\"\"\"\nAn LLM chat history, to be passed to a query as an answer prefix (see\n`Query.query_prefix`).\n\"\"\"\n</code></pre> <p>Content tabs:</p> CC++ <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n  printf(\"Hello world!\\n\");\n  return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\n  std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>"},{"location":"dev/test-mkdocs/","title":"Testing MkDocs","text":""},{"location":"dev/test-mkdocs/#resources-on-writing-good-docstrings","title":"Resources on Writing Good Docstrings","text":"<ul> <li>Pydantic Example</li> </ul>"},{"location":"dev/test-mkdocs/#tricks","title":"Tricks","text":"<ul> <li>In docstrings, both <code>[`AttachedQuery`][delphyne.core.AttachedQuery]</code> and <code>[delphyne.core.AttachedQuery][]</code> will work but the former is better style.</li> <li>The <code>\"rewrap.autoWrap.enabled\": true</code> option is pretty good for what I want to do. Also, always select before rewrapping and we should be good.</li> <li>Start documenting each field in uppercase.</li> </ul>"},{"location":"dev/test-mkdocs/#api-documentation-for-query","title":"API Documentation for Query","text":"<p>The <code>Query</code> class is the base class for all queries in Delphyne, providing convenient features and automatic type inference. Does it work to have partial paths (<code>Query</code>)?</p>"},{"location":"dev/test-mkdocs/#documenting-type-aliases","title":"Documenting Type Aliases","text":""},{"location":"dev/test-mkdocs/#delphyne.Stream","title":"Stream  <code>dataclass</code>","text":"<p>               Bases: <code>AbstractStream[Stream[T]]</code></p> <p>A search stream produced by a search policy or prompting policy.</p> <p>This class inherits [<code>AbstractStream</code>][delphyne.AbstractStream] and supports various methods and combinators for assembling streams, while guaranteeing adherence to the search stream protocol.</p> <p>Attributes:</p> Name Type Description <code>_generate</code> <code>Callable[[], StreamGen[Stream[T]]]</code> <p>A zeroary function that produces a stream generator.</p> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>@dataclass(frozen=True)\nclass Stream[T](dp.AbstractStream[T]):\n    \"\"\"\n    A search stream produced by a search policy or prompting policy.\n\n    This class inherits `AbstractStream` and supports various methods\n    and combinators for assembling streams, while guaranteeing adherence\n    to the [search stream protocol](delphyne.core.streams).\n\n    Attributes:\n        _generate: A zeroary function that produces a stream generator.\n    \"\"\"\n\n    _generate: Callable[[], dp.StreamGen[T]]\n\n    @override\n    def gen(self) -&gt; dp.StreamGen[T]:\n        return self._generate()\n\n    ## Collecting all elements\n\n    def collect(\n        self,\n        budget: dp.BudgetLimit | None = None,\n        num_generated: int | None = None,\n    ) -&gt; tuple[Sequence[dp.Solution[T]], dp.Budget]:\n        \"\"\"\n        Exhaust a stream and collect all generated solutions.\n\n        Attributes:\n            budget (optional): Budget limit (see `with_budget` method).\n            num_generated (optional): Number of solutions to generate\n                (see `take` method).\n\n        Returns:\n            A sequence of solutions along with the total spent budget.\n\n        !!! warning\n            This function must only be used at top-level and *not*\n            within the definition of a search stream generator (in which\n            case the consumed resources won't be accounted for in the\n            parent stream). See `Stream.all`.\n        \"\"\"\n        if budget is not None:\n            self = self.with_budget(budget)\n        if num_generated is not None:\n            self = self.take(num_generated)\n        return stream_collect(self.gen())\n\n    ## Transforming the stream\n\n    def with_budget(self, budget: dp.BudgetLimit):\n        \"\"\"\n        Return an identical stream that denies all spending requests\n        once a given amount of budget is spent.\n\n        **Guarantees**: if all budget spending over-estimates passed to\n        `spend_on` are accurate, the given budget limit is rigorously\n        respected. If not, the spent amount may exceed the budget by an\n        amount of `Delta * N`, where `Delta` is the maximum estimation\n        error and `N` is the concurrency level of the stream (1 if\n        `Stream.parallel` is never used).\n        \"\"\"\n        return Stream(lambda: stream_with_budget(self.gen(), budget))\n\n    def take(self, num_generated: int, strict: bool = True):\n        \"\"\"\n        Return an identical stream that terminates once a given number\n        of solution is generated. If `strict` is set to `False`, more\n        solutions can be returned, provided that no additional budget\n        must be spent for generating them.\n        \"\"\"\n        return Stream(lambda: stream_take(self.gen(), num_generated, strict))\n\n    def loop(\n        self, n: int | None = None, *, stop_on_reject: bool = True\n    ) -&gt; \"Stream[T]\":\n        \"\"\"\n        Repeatedly execute a stream.\n\n        Arguments:\n            n (optional): Number of times to repeat the stream. By\n                default, the stream is repeated indefinitely.\n            stop_on_reject: If set to `True` (default), the resulting\n                stream stops after the first iteration during which no\n                spending request was granted. This guarantees\n                termination, even if `n` is `None`.\n        \"\"\"\n        it = itertools.count() if n is None else range(n)\n        return Stream(\n            lambda: stream_sequence(\n                (self.gen for _ in it), stop_on_reject=stop_on_reject\n            )\n        )\n\n    def bind[U](\n        self, f: Callable[[dp.Solution[T]], dp.StreamGen[U]]\n    ) -&gt; \"Stream[U]\":\n        \"\"\"\n        Apply a function to all generated solutions of a stream and\n        concatenate the resulting streams.\n\n        This is analogous to the `concat_map` funtion on lists:\n\n            def concat_map(f, xs):\n                return [y for x in xs for y in f(x)]\n        \"\"\"\n        return Stream(lambda: stream_bind(self.gen(), f))\n\n    ## Monadic Methods\n\n    def first(self) -&gt; dp.StreamContext[dp.Solution[T] | None]:\n        \"\"\"\n        Obtain the first solution from a stream, or return `None` if the\n        stream terminates without yielding any solution.\n        \"\"\"\n        return stream_first(self.gen())\n\n    def all(self) -&gt; dp.StreamContext[Sequence[dp.Solution[T]]]:\n        \"\"\"\n        Obtain all solutions from a stream.\n        \"\"\"\n        return stream_all(self.gen())\n\n    def next(\n        self,\n    ) -&gt; dp.StreamContext[\n        \"tuple[Sequence[dp.Solution[T]], dp.Budget, Stream[T] | None]\"\n    ]:\n        \"\"\"\n        Make an atomic attempt to obtain a solution from the stream,\n        stopping right before a second spending request is made.\n\n        Return a sequence of generated solutions, the total spent\n        budget, and the remaining stream, if any.\n        \"\"\"\n        gen, budg, rest = yield from stream_next(self.gen())\n        new_rest = None if rest is None else Stream(lambda: rest)\n        return gen, budg, new_rest\n\n    ## Static Methods\n\n    @staticmethod\n    def sequence[U](\n        streams: Iterable[\"Stream[U]\"], *, stop_on_reject: bool = True\n    ) -&gt; \"Stream[U]\":\n        \"\"\"\n        Concatenate all streams from a possibly infinite collection.\n\n        If `stop_on_reject` is set to `True` (default), then the\n        resulting stream is stopped as soon as one stream in the\n        collection terminates without a single spending request being\n        granted. This allows guaranteeing termination, even if an\n        infinite collection of streams is passed.\n        \"\"\"\n        return Stream(\n            lambda: stream_sequence(\n                (s.gen for s in streams), stop_on_reject=stop_on_reject\n            )\n        )\n\n    @staticmethod\n    def parallel[U](streams: Sequence[\"Stream[U]\"]) -&gt; \"Stream[U]\":\n        \"\"\"\n        Run all streams of a sequence in separate threads, possibly\n        interleaving the resulting solutions.\n        \"\"\"\n        return Stream(lambda: stream_parallel([s.gen() for s in streams]))\n\n    @staticmethod\n    def or_else[U](main: \"Stream[U]\", fallback: \"Stream[U]\") -&gt; \"Stream[U]\":\n        \"\"\"\n        Run the `main` stream and, if it does not yield any solution,\n        run the `fallback` stream.\n        \"\"\"\n        return Stream(lambda: stream_or_else(main.gen, fallback.gen))\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.collect","title":"collect","text":"<pre><code>collect(budget: BudgetLimit | None = None, num_generated: int | None = None) -&gt; tuple[Sequence[Solution[Stream[T]]], Budget]\n</code></pre> <p>Exhaust a stream and collect all generated solutions.</p> <p>Attributes:</p> Name Type Description <code>budget</code> <code>optional</code> <p>Budget limit (see [<code>with_budget</code>][delphyne.with_budget] method).</p> <code>num_generated</code> <code>optional</code> <p>Number of solutions to generate (see [<code>take</code>][delphyne.take] method).</p> <p>Returns:</p> Type Description <code>tuple[Sequence[Solution[Stream[T]]], Budget]</code> <p>A sequence of solutions along with the total spent budget.</p> <p>Warning</p> <p>This function must only be used at top-level and not within the definition of a search stream generator (in which case the consumed resources won't be accounted for in the parent stream). See <code>Stream.all</code>.</p> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>def collect(\n    self,\n    budget: dp.BudgetLimit | None = None,\n    num_generated: int | None = None,\n) -&gt; tuple[Sequence[dp.Solution[T]], dp.Budget]:\n    \"\"\"\n    Exhaust a stream and collect all generated solutions.\n\n    Attributes:\n        budget (optional): Budget limit (see `with_budget` method).\n        num_generated (optional): Number of solutions to generate\n            (see `take` method).\n\n    Returns:\n        A sequence of solutions along with the total spent budget.\n\n    !!! warning\n        This function must only be used at top-level and *not*\n        within the definition of a search stream generator (in which\n        case the consumed resources won't be accounted for in the\n        parent stream). See `Stream.all`.\n    \"\"\"\n    if budget is not None:\n        self = self.with_budget(budget)\n    if num_generated is not None:\n        self = self.take(num_generated)\n    return stream_collect(self.gen())\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.with_budget","title":"with_budget","text":"<pre><code>with_budget(budget: BudgetLimit)\n</code></pre> <p>Return an identical stream that denies all spending requests once a given amount of budget is spent.</p> <p>Guarantees: if all budget spending over-estimates passed to [<code>spend_on</code>][delphyne.spend_on] are accurate, the given budget limit is rigorously respected. If not, the spent amount may exceed the budget by an amount of <code>Delta * N</code>, where <code>Delta</code> is the maximum estimation error and <code>N</code> is the concurrency level of the stream (1 if <code>Stream.parallel</code> is never used).</p> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>def with_budget(self, budget: dp.BudgetLimit):\n    \"\"\"\n    Return an identical stream that denies all spending requests\n    once a given amount of budget is spent.\n\n    **Guarantees**: if all budget spending over-estimates passed to\n    `spend_on` are accurate, the given budget limit is rigorously\n    respected. If not, the spent amount may exceed the budget by an\n    amount of `Delta * N`, where `Delta` is the maximum estimation\n    error and `N` is the concurrency level of the stream (1 if\n    `Stream.parallel` is never used).\n    \"\"\"\n    return Stream(lambda: stream_with_budget(self.gen(), budget))\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.take","title":"take","text":"<pre><code>take(num_generated: int, strict: bool = True)\n</code></pre> <p>Return an identical stream that terminates once a given number of solution is generated. If <code>strict</code> is set to <code>False</code>, more solutions can be returned, provided that no additional budget must be spent for generating them.</p> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>def take(self, num_generated: int, strict: bool = True):\n    \"\"\"\n    Return an identical stream that terminates once a given number\n    of solution is generated. If `strict` is set to `False`, more\n    solutions can be returned, provided that no additional budget\n    must be spent for generating them.\n    \"\"\"\n    return Stream(lambda: stream_take(self.gen(), num_generated, strict))\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.loop","title":"loop","text":"<pre><code>loop(n: int | None = None, *, stop_on_reject: bool = True) -&gt; Stream[Stream[T]]\n</code></pre> <p>Repeatedly execute a stream.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>optional</code> <p>Number of times to repeat the stream. By default, the stream is repeated indefinitely.</p> <code>None</code> <code>stop_on_reject</code> <code>bool</code> <p>If set to <code>True</code> (default), the resulting stream stops after the first iteration during which no spending request was granted. This guarantees termination, even if <code>n</code> is <code>None</code>.</p> <code>True</code> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>def loop(\n    self, n: int | None = None, *, stop_on_reject: bool = True\n) -&gt; \"Stream[T]\":\n    \"\"\"\n    Repeatedly execute a stream.\n\n    Arguments:\n        n (optional): Number of times to repeat the stream. By\n            default, the stream is repeated indefinitely.\n        stop_on_reject: If set to `True` (default), the resulting\n            stream stops after the first iteration during which no\n            spending request was granted. This guarantees\n            termination, even if `n` is `None`.\n    \"\"\"\n    it = itertools.count() if n is None else range(n)\n    return Stream(\n        lambda: stream_sequence(\n            (self.gen for _ in it), stop_on_reject=stop_on_reject\n        )\n    )\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.bind","title":"bind","text":"<pre><code>bind(f: Callable[[Solution[Stream[T]]], StreamGen[bind[U]]]) -&gt; Stream[bind[U]]\n</code></pre> <p>Apply a function to all generated solutions of a stream and concatenate the resulting streams.</p> <p>This is analogous to the <code>concat_map</code> funtion on lists:</p> <pre><code>def concat_map(f, xs):\n    return [y for x in xs for y in f(x)]\n</code></pre> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>def bind[U](\n    self, f: Callable[[dp.Solution[T]], dp.StreamGen[U]]\n) -&gt; \"Stream[U]\":\n    \"\"\"\n    Apply a function to all generated solutions of a stream and\n    concatenate the resulting streams.\n\n    This is analogous to the `concat_map` funtion on lists:\n\n        def concat_map(f, xs):\n            return [y for x in xs for y in f(x)]\n    \"\"\"\n    return Stream(lambda: stream_bind(self.gen(), f))\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.first","title":"first","text":"<pre><code>first() -&gt; StreamContext[Solution[Stream[T]] | None]\n</code></pre> <p>Obtain the first solution from a stream, or return <code>None</code> if the stream terminates without yielding any solution.</p> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>def first(self) -&gt; dp.StreamContext[dp.Solution[T] | None]:\n    \"\"\"\n    Obtain the first solution from a stream, or return `None` if the\n    stream terminates without yielding any solution.\n    \"\"\"\n    return stream_first(self.gen())\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.all","title":"all","text":"<pre><code>all() -&gt; StreamContext[Sequence[Solution[Stream[T]]]]\n</code></pre> <p>Obtain all solutions from a stream.</p> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>def all(self) -&gt; dp.StreamContext[Sequence[dp.Solution[T]]]:\n    \"\"\"\n    Obtain all solutions from a stream.\n    \"\"\"\n    return stream_all(self.gen())\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.next","title":"next","text":"<pre><code>next() -&gt; StreamContext[tuple[Sequence[Solution[Stream[T]]], Budget, Stream[Stream[T]] | None]]\n</code></pre> <p>Make an atomic attempt to obtain a solution from the stream, stopping right before a second spending request is made.</p> <p>Return a sequence of generated solutions, the total spent budget, and the remaining stream, if any.</p> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>def next(\n    self,\n) -&gt; dp.StreamContext[\n    \"tuple[Sequence[dp.Solution[T]], dp.Budget, Stream[T] | None]\"\n]:\n    \"\"\"\n    Make an atomic attempt to obtain a solution from the stream,\n    stopping right before a second spending request is made.\n\n    Return a sequence of generated solutions, the total spent\n    budget, and the remaining stream, if any.\n    \"\"\"\n    gen, budg, rest = yield from stream_next(self.gen())\n    new_rest = None if rest is None else Stream(lambda: rest)\n    return gen, budg, new_rest\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.sequence","title":"sequence  <code>staticmethod</code>","text":"<pre><code>sequence(streams: Iterable[Stream[sequence[U]]], *, stop_on_reject: bool = True) -&gt; Stream[sequence[U]]\n</code></pre> <p>Concatenate all streams from a possibly infinite collection.</p> <p>If <code>stop_on_reject</code> is set to <code>True</code> (default), then the resulting stream is stopped as soon as one stream in the collection terminates without a single spending request being granted. This allows guaranteeing termination, even if an infinite collection of streams is passed.</p> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>@staticmethod\ndef sequence[U](\n    streams: Iterable[\"Stream[U]\"], *, stop_on_reject: bool = True\n) -&gt; \"Stream[U]\":\n    \"\"\"\n    Concatenate all streams from a possibly infinite collection.\n\n    If `stop_on_reject` is set to `True` (default), then the\n    resulting stream is stopped as soon as one stream in the\n    collection terminates without a single spending request being\n    granted. This allows guaranteeing termination, even if an\n    infinite collection of streams is passed.\n    \"\"\"\n    return Stream(\n        lambda: stream_sequence(\n            (s.gen for s in streams), stop_on_reject=stop_on_reject\n        )\n    )\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.parallel","title":"parallel  <code>staticmethod</code>","text":"<pre><code>parallel(streams: Sequence[Stream[parallel[U]]]) -&gt; Stream[parallel[U]]\n</code></pre> <p>Run all streams of a sequence in separate threads, possibly interleaving the resulting solutions.</p> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>@staticmethod\ndef parallel[U](streams: Sequence[\"Stream[U]\"]) -&gt; \"Stream[U]\":\n    \"\"\"\n    Run all streams of a sequence in separate threads, possibly\n    interleaving the resulting solutions.\n    \"\"\"\n    return Stream(lambda: stream_parallel([s.gen() for s in streams]))\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Stream.or_else","title":"or_else  <code>staticmethod</code>","text":"<pre><code>or_else(main: Stream[or_else[U]], fallback: Stream[or_else[U]]) -&gt; Stream[or_else[U]]\n</code></pre> <p>Run the <code>main</code> stream and, if it does not yield any solution, run the <code>fallback</code> stream.</p> Source code in <code>src/delphyne/stdlib/streams.py</code> <pre><code>@staticmethod\ndef or_else[U](main: \"Stream[U]\", fallback: \"Stream[U]\") -&gt; \"Stream[U]\":\n    \"\"\"\n    Run the `main` stream and, if it does not yield any solution,\n    run the `fallback` stream.\n    \"\"\"\n    return Stream(lambda: stream_or_else(main.gen, fallback.gen))\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.AnswerPrefix","title":"AnswerPrefix","text":"<pre><code>AnswerPrefix: Sequence[AnswerPrefixElement]\n</code></pre> <p>An LLM chat history, to be passed to a query as an answer prefix (see <code>Query.query_prefix</code>).</p>"},{"location":"dev/test-mkdocs/#delphyne.Tag","title":"Tag","text":"<pre><code>Tag: str\n</code></pre> <p>String tags for nodes and spaces.</p> <p>Nodes and spaces can be assigned string identifiers, which may be referenced in demonstration tests or when defining inner policies (e.g., <code>IPDict</code>). Tags should contain only alphanumeric characters, underscores, dots, and dashes.</p>"},{"location":"dev/test-mkdocs/#delphyne.IPDict","title":"IPDict","text":"<pre><code>IPDict: Mapping[str, Policy[Any, Any] | PromptingPolicy]\n</code></pre> <p>Type of an Inner-Policy Dictionary.</p> <p>Inner-Policy dictionaries allow to define strategies in a more concise way in exchange for less static type safety.</p> <p>Normally, an inner policy type must be defined for every strategy, and opaque spaces are created from queries or strategy by passing the <code>using</code> method a mapping from the ambient inner policy to a proper sub-policy, often in the form of an anonymous function:</p> <pre><code>@dataclass class MyInnerPolicy:\n    foo: PromptingPolicy # etc\n\ndef my_strategy() -&gt; Strategy[Branch, MyInnerPolicy, str]:\n    x = yield from branch(Foo().using(lambda p: p.foo)) # etc\n</code></pre> <p>As an alternative, one can have a strategy use an inner policy dictionary, by passing ellipses (<code>...</code>) to the <code>using</code> method:</p> <pre><code>def my_strategy() -&gt; Strategy[Branch, IPDict, str]:\n    x = yield from branch(Foo().using(...)) # etc\n</code></pre> <p>When doing so, a simple Python dictionary can be used as an inner policy, whose keys are space tags (the same tags can be referenced in demonstration tests). In the example above, and since a spaces induced by a query inherits its name as a tag by default, one can define an inner policy for <code>my_strategy</code> as:</p> <pre><code>{\"Foo\": foo_prompting_policy, ...}\n</code></pre> <p>A conjunction of tags can also be specified, separated by <code>&amp;</code> (without spaces). For example, <code>{\"tag1&amp;tag2\": pp, ...}</code> associates prompting policies <code>pp</code> to spaces with both tags <code>tag1</code> and <code>tag2</code>. New tags can be added to a space builder using the <code>SpaceBuilder.tagged</code> method.</p> <p>Info</p> <p>If several entries of the inner policy dictionary apply for a given instance of <code>.using(...)</code>, a runtime error is raised.</p> <p>See <code>tests/example_strategies:generate_number</code> for another example.</p>"},{"location":"dev/test-mkdocs/#documenting-a-class","title":"Documenting a Class","text":""},{"location":"dev/test-mkdocs/#delphyne.Query","title":"Query","text":"<p>               Bases: <code>AbstractQuery[Query[T]]</code></p> <p>Base class for queries.</p> <p>This class adds standard convenience features on top of <code>AbstractQuery</code>, using reflection to allow queries to be defined concisely. Here is a simple example of a query type definition:</p> <pre><code>@dataclass class MakeSum(Query[list[int]]):\n    ''' Given a list of allowed numbers and a target number, you\n    must find a sub-list whose elements sum up to the target.\n    Just answer with a list of numbers as a JSON object and\n    nothing else. '''\n\n    allowed: list[int] target: int\n</code></pre> <p>In general, a query type is a dataclass that inherits <code>Query[T]</code>, where <code>T</code> is the query's answer type. In the example above, no parser is specified and so oracles are requested to provide structured answers as JSON objects, which are automatically parsed into the answer type (<code>list[int]</code>) using pydantic. Assuming that no Jinja prompt file is provided, the docstring is used as a system prompt and instance prompts are generated by simply serializing <code>MakeSum</code> instances into YAML.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--customizing-prompts","title":"Customizing Prompts","text":"<p>System and instance prompts can be specified via Jinja templates. The templates manager (<code>TemplatesManager</code>) looks for templates named \"..jinja\". Templates can also be provided by defining the <code>__system_prompt__</code> and/or <code>__instance_prompt__</code> class attributes. If none of these are provided, the query's docstring is used as a system prompt and <code>DEFAULT_INSTANCE_PROMPT</code> is used as an instance prompt template. <p>The following arguments are usually made available to templates (although specific prompting policies can add more):</p> <ul> <li><code>query</code>: the query instance.</li> <li><code>mode</code>: the requested answer mode.</li> <li><code>params</code>: the query hyperparameters (e.g., as passed to <code>few_shot</code>)</li> </ul>"},{"location":"dev/test-mkdocs/#delphyne.Query--answer-modes-and-configurations","title":"Answer Modes and Configurations","text":"<p>A query can define several answer modes (<code>AnswerMode</code>), each of which can be associated with a different parser and set of settings. By default, the only answer mode is <code>None</code>. More answer modes can be defined by setting class variable <code>__modes__</code>.</p> <p>The <code>query_config</code> method maps modes to configurations (i.e., a set of settings, including a parser specification). Its default behavior works by inspecting the <code>__parser__</code> and <code>__config__</code> class attributes and does not typically require overriding.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--allowing-multi-message-exchanges-and-tool-calls","title":"Allowing Multi-Message Exchanges and Tool Calls","text":"<p>A common pattern for interacting with LLMs is to have multi-message exchanges where the full conversation history is resent repeatedly. LLMs are also often allowed to request tool call. This interaction pattern is implemented in the [<code>interact</code>][delphyne.interact] standard strategy. It is enabled by several features on the <code>Query</code> side.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--answer-prefixes","title":"Answer Prefixes","text":"<p>If a query type has a prefix attribute with type <code>AnswerPrefix</code>, this attribute can be used to provide a chat history, to be added to the query's prompt.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--the-response-type","title":"The <code>Response</code> Type","text":"<p>If the query answer type is <code>Response</code>, the query does not only return a parsed answer, but also the LLM raw answer (which can be appended to a chat history), and possibly a sequence of tool calls.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--manually-overriding-the-parse-method","title":"Manually Overriding the <code>parse</code> Method","text":"<p>For advanced use cases, it is possible to directly override the <code>parse</code> method that turns an answer into an object of type <code>T</code>. When this is done, the <code>__config__</code> and <code>__parser__</code> class attributes must not be set. Also, the <code>query_settings</code> method always returns the default settings instead of relying on <code>query_config</code> and must be overriden if another behavior is desired.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>class Query[T](dp.AbstractQuery[T]):\n    \"\"\"\n    Base class for queries.\n\n    This class adds standard convenience features on top of\n    `AbstractQuery`, using reflection to allow queries to be defined\n    concisely. Here is a simple example of a query type definition:\n\n        @dataclass class MakeSum(Query[list[int]]):\n            ''' Given a list of allowed numbers and a target number, you\n            must find a sub-list whose elements sum up to the target.\n            Just answer with a list of numbers as a JSON object and\n            nothing else. '''\n\n            allowed: list[int] target: int\n\n    In general, a query type is a dataclass that inherits `Query[T]`,\n    where `T` is the query's answer type. In the example above, no\n    parser is specified and so oracles are requested to provide\n    structured answers as JSON objects, which are automatically parsed\n    into the answer type (`list[int]`) using pydantic. Assuming that no\n    Jinja prompt file is provided, the docstring is used as a system\n    prompt and instance prompts are generated by simply serializing\n    `MakeSum` instances into YAML.\n\n    ### Customizing Prompts\n\n    System and instance prompts can be specified via Jinja templates.\n    The templates manager (`TemplatesManager`) looks for templates named\n    \"&lt;QueryName&gt;.&lt;instance|system&gt;.jinja\". Templates can also be\n    provided by defining the `__system_prompt__` and/or `__instance_prompt__`\n    class attributes. If none of these are provided, the query's\n    docstring is used as a system prompt and `DEFAULT_INSTANCE_PROMPT`\n    is used as an instance prompt template.\n\n    The following arguments are usually made available to templates\n    (although specific prompting policies can add more):\n\n    - `query`: the query instance.\n    - `mode`: the requested answer mode.\n    - `params`: the query hyperparameters (e.g., as passed to `few_shot`)\n\n    ### Answer Modes and Configurations\n\n    A query can define several answer modes (`AnswerMode`), each of\n    which can be associated with a different parser and set of settings.\n    By default, the only answer mode is `None`. More answer modes can be\n    defined by setting class variable `__modes__`.\n\n    The `query_config` method maps modes to configurations (i.e., a set\n    of settings, including a parser specification). Its default behavior\n    works by inspecting the `__parser__` and `__config__` class\n    attributes and does not typically require overriding.\n\n    ### Allowing Multi-Message Exchanges and Tool Calls\n\n    A common pattern for interacting with LLMs is to have multi-message\n    exchanges where the full conversation history is resent repeatedly.\n    LLMs are also often allowed to request tool call. This interaction\n    pattern is implemented in the `interact` standard strategy. It is\n    enabled by several features on the `Query` side.\n\n    #### Answer Prefixes\n\n    If a query type has a prefix attribute with type `AnswerPrefix`,\n    this attribute can be used to provide a chat history, to be added to\n    the query's prompt.\n\n    #### The `Response` Type\n\n    If the query answer type is `Response`, the query does not only\n    return a parsed answer, but also the LLM raw answer (which can be\n    appended to a chat history), and possibly a sequence of tool calls.\n\n    ### Manually Overriding the `parse` Method\n\n    For advanced use cases, it is possible to directly override the\n    `parse` method that turns an answer into an object of type `T`. When\n    this is done, the `__config__` and `__parser__` class attributes\n    must not be set. Also, the `query_settings` method always returns\n    the default settings instead of relying on `query_config` and must\n    be overriden if another behavior is desired.\n    \"\"\"\n\n    __modes__: ClassVar[Sequence[dp.AnswerMode] | None] = None\n    __parser__: ClassVar[ParserSpec | ParserSpecDict | None] = None\n    __config__: ClassVar[QueryConfig | QueryConfigDict | None] = None\n\n    ### Inspection methods\n\n    def query_config(self, mode: dp.AnswerMode) -&gt; QueryConfig | None:\n        \"\"\"\n        Map modes to configurations.\n\n        This method inspects the `__config__` and `__parser__` class\n        attributes (none or either can be set but not both).\n\n        - If no attribute is set, the default configuration is used for\n              all modes, which uses the `\"structured\"` parser.\n        - If `__config__` is set to a `QueryConfig`, this configuration\n              is used for all modes.\n        - Alternatively, `__config__` can be set to a dictionary mapping\n              modes to configurations.\n        - If `__parser__` is set to a parser specification, the default\n              configuration is used for all modes, *except* that the\n              provided parser is used instead of the default one.\n        - Alternatively, `__parser__` can also be set to a dictionary.\n\n        In the special case where the `parse` method is overriden and\n        only in this case, return `None` after ensuring that\n        `__config__` and `__parser__` are not set.\n        \"\"\"\n        cls = type(self)\n        parse_overriden = dpi.is_method_overridden(Query, cls, \"parse\")\n        if parse_overriden:\n            assert cls.__config__ is None\n            assert cls.__parser__ is None\n            return None\n        if cls.__config__ is not None:\n            assert self.__parser__ is None, (\n                \"Cannot have both __config__ and __parser__ attributes.\"\n            )\n            config_attr = cls.__config__\n            if isinstance(config_attr, QueryConfig):\n                return config_attr\n            else:\n                assert isinstance(config_attr, Mapping)\n                return cast(Any, config_attr)[mode]\n        elif cls.__parser__ is not None:\n            parser_attr: Any = cls.__parser__\n            if isinstance(parser_attr, Mapping):\n                parser = cast(Any, parser_attr)[mode]\n            else:\n                parser = parser_attr\n            _check_valid_parser_spec(parser)\n            return QueryConfig(parser)\n        else:\n            return QueryConfig(\"structured\")\n\n    @classmethod\n    def _decomposed_answer_type(cls) -&gt; _DecomposedAnswerType:\n        return _DecomposedAnswerType(cls._answer_type())\n\n    ### Parsing Answers\n\n    @override\n    def parse_answer(self, answer: dp.Answer) -&gt; T | dp.ParseError:\n        assert answer.mode in self.query_modes(), (\n            f\"Unknown mode: {answer.mode}\"\n        )\n        try:\n            return self.parse(answer)\n        except dp.ParseError as e:\n            return e\n\n    def parse(self, answer: Answer) -&gt; T:\n        \"\"\"\n        A more convenient method to override instead of `parse_answer`.\n\n        Raises `ParseError`.\n        \"\"\"\n\n        # Decompose the specified answer type\n        config = self.query_config(answer.mode)\n        assert config is not None\n        attr = config.parser\n        ans_type = self._decomposed_answer_type()\n\n        # Compute base parsing function `parser`\n        parser: _ParsingFunction[Any]\n        if attr == \"structured\":\n            parser = _from_structured(ans_type.to_parse)\n        elif attr == \"final_tool_call\":\n            assert isinstance(ans_type.to_parse, type)\n            parser = _from_final_tool_call(cast(type[Any], ans_type.to_parse))\n        else:\n            assert callable(attr)\n            attr = cast(Callable[..., Any], attr)\n            sig = inspect.signature(attr)\n            nargs = len(sig.parameters)\n            assert nargs == 1 or nargs == 2\n            if nargs == 1:\n                parser = _from_text_parser(attr)\n            else:\n                parser = _from_generic_text_parser(attr, ans_type.to_parse)\n\n        if ans_type.wrap_parse_errors():\n            parser = _wrap_parse_errors(parser)\n\n        # If the answer type has form `Response[..., ...]`\n        if ans_type.resp:\n            if _has_final_tool_call(ans_type, answer):\n                tcs = []\n            else:\n                tcs = [\n                    _parse_tool_call(ans_type.resp.tools, tc)\n                    for tc in answer.tool_calls\n                ]\n            if tcs:\n                return cast(T, Response(answer, ToolRequests(tcs)))\n            else:\n                return cast(T, Response(answer, FinalAnswer(parser(answer))))\n\n        return parser(answer)\n\n    ### Query Settings\n\n    @override\n    def query_settings(self, mode: dp.AnswerMode) -&gt; dp.QuerySettings:\n        \"\"\"\n        Return the settings associated with the query.\n\n        By default, this method uses the result of `query_config` to\n        determine settings if `parse` is not overriden, and the default\n        set of settings otherwise.\n        \"\"\"\n        config = self.query_config(mode)\n        if config is None:\n            # `parse` is overriden\n            return dp.QuerySettings(structured_output=None, tools=None)\n        structured_output = None\n        if config.parser == \"structured\":\n            type = self._decomposed_answer_type().final\n            structured_output = dp.StructuredOutputSettings(type)\n        tools = None\n        if tool_types := self._query_tools(config.parser):\n            tools = dp.ToolSettings(\n                tool_types, force_tool_call=config.parser == \"final_tool_call\"\n            )\n        return dp.QuerySettings(\n            structured_output=structured_output,\n            tools=tools,\n        )\n\n    def _structured_output_type(self) -&gt; TypeAnnot[Any] | ty.NoTypeInfo:\n        decomposed = self._decomposed_answer_type()\n        return decomposed.final\n\n    def _query_tools(self, parser: ParserSpec) -&gt; Sequence[type[Any]]:\n        ans_type = self._decomposed_answer_type()\n        tools: list[type[Any]] = []\n        if ans_type.resp is not None:\n            tools = [*ans_type.resp.tools]\n        if parser == \"final_tool_call\":\n            assert isinstance(ans_type.final, type)\n            tools.append(ans_type.final)\n        return tools\n\n    ### Query Prefixes\n\n    @classmethod\n    def _has_special_prefix_attr(cls):\n        annots = typing.get_type_hints(cls)\n        return \"prefix\" in annots and annots[\"prefix\"] is ct.AnswerPrefix\n\n    @override\n    def query_prefix(self) -&gt; ct.AnswerPrefix | None:\n        \"\"\"\n        Return the value of the `prefix` attribute if it has type\n        annotation `AnswerPrefix` or return `None`.\n        \"\"\"\n        if self._has_special_prefix_attr():\n            return getattr(self, \"prefix\")\n        return None\n\n    ### Producing Prompts\n\n    @override\n    def generate_prompt(\n        self,\n        *,\n        kind: Literal[\"system\", \"instance\"] | str,\n        mode: dp.AnswerMode,\n        params: dict[str, object],\n        extra_args: dict[str, object] | None = None,\n        env: dp.TemplatesManager | None = None,\n    ) -&gt; str:\n        assert env is not None, _no_prompt_manager_error()\n        args: dict[str, object] = {\n            \"query\": self,\n            \"mode\": mode,\n            \"params\": params,\n        }\n        if extra_args:\n            args.update(extra_args)\n        if (glob := self.globals()) is not None:\n            args[\"globals\"] = glob\n        return env.prompt(\n            query_name=self.query_name(),\n            prompt_kind=kind,\n            template_args=args,\n            default_template=self._default_prompt(kind),\n        )\n\n    @classmethod\n    def _default_prompt(\n        cls, kind: Literal[\"system\", \"instance\"] | str\n    ) -&gt; str | None:\n        attr_name = f\"__{kind}_prompt__\"\n        if hasattr(cls, attr_name):\n            res = getattr(cls, attr_name)\n            assert isinstance(res, str)\n            return textwrap.dedent(res).strip()\n        if kind == \"instance\":\n            if cls._has_special_prefix_attr():\n                return DEFAULT_INSTANCE_PROMPT_WITH_PREFIX\n            else:\n                return DEFAULT_INSTANCE_PROMPT\n        if kind == \"system\" and (doc := inspect.getdoc(cls)) is not None:\n            return doc\n        if kind == \"feedback\":\n            return DEFAULT_FEEDBACK_PROMPT\n        return None\n\n    def globals(self) -&gt; dict[str, object] | None:\n        \"\"\"\n        Return global objects accessible in prompts via the `globals`\n        attribute.\n        \"\"\"\n        return None\n\n    ### Other Simple Overrides\n\n    @override\n    def serialize_args(self) -&gt; dict[str, object]:\n        return cast(dict[str, object], ty.pydantic_dump(type(self), self))\n\n    @classmethod\n    def _answer_type(cls) -&gt; TypeAnnot[T]:\n        return dpi.first_parameter_of_base_class(cls)\n\n    @override\n    def answer_type(self) -&gt; TypeAnnot[T]:\n        return self._answer_type()\n\n    @override\n    def finite_answer_set(self) -&gt; Sequence[dp.Answer] | None:\n        # We handle the special case where the return type is a literal\n        # type that is a subtype of str.\n        ans = self.answer_type()\n        if (res := _match_string_literal_type(ans)) is not None:\n            return [dp.Answer(None, v) for v in res]\n        return None\n\n    @override\n    def query_modes(self) -&gt; Sequence[dp.AnswerMode]:\n        if self.__modes__ is not None:\n            return self.__modes__\n        return [None]\n\n    ### Generating Opaque Spaces\n\n    @overload\n    def using(self, get_policy: EllipsisType, /) -&gt; Opaque[IPDict, T]: ...\n\n    @overload\n    def using[P](\n        self,\n        get_policy: Callable[[P], pol.PromptingPolicy] | EllipsisType,\n        /,\n        inner_policy_type: type[P] | None = None,\n    ) -&gt; Opaque[P, T]: ...\n\n    def using[P](\n        self,\n        get_policy: Callable[[P], pol.PromptingPolicy] | EllipsisType,\n        /,\n        inner_policy_type: type[P] | None = None,\n    ) -&gt; Opaque[P, T]:\n        \"\"\"\n        Turn a query into an opaque space by providing a mapping from\n        the ambient inner policy to a prompting policy.\n\n        Attributes:\n            get_policy: A function that maps the ambient inner policy to\n                a prompting policy to use for answering the query.\n                Alternatively, if the ellipsis value `...` is passed, the\n                inner policy type is assumed to be `IPDict`, and\n                prompting policies are automatically selected using tags\n                (see `IPDict` documentation).\n            inner_policy_type: Ambient inner policy type. This information\n                is not used at runtime but it can be provided to help type\n                inference when necessary.\n\n        The optional `inner_policy_type` argument is ignored at runtime\n        and can be used to help type checkers infer the type of the\n        ambient inner policy.\n        \"\"\"\n        if isinstance(get_policy, EllipsisType):\n            return OpaqueSpace[P, T].from_query(\n                self, cast(Any, pol.dict_subpolicy)\n            )\n        return OpaqueSpace[P, T].from_query(self, lambda p, _: get_policy(p))\n\n    def run_toplevel(\n        self,\n        env: dp.PolicyEnv,\n        policy: pol.PromptingPolicy,\n    ) -&gt; Stream[T]:\n        \"\"\"\n        Obtain a search stream of query answers, given a prompting\n        policy.\n        \"\"\"\n        attached = dp.spawn_standalone_query(self)\n        return policy(attached, env)\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Query.query_config","title":"query_config","text":"<pre><code>query_config(mode: AnswerMode) -&gt; QueryConfig | None\n</code></pre> <p>Map modes to configurations.</p> <p>This method inspects the <code>__config__</code> and <code>__parser__</code> class attributes (none or either can be set but not both).</p> <ul> <li>If no attribute is set, the default configuration is used for       all modes, which uses the <code>\"structured\"</code> parser.</li> <li>If <code>__config__</code> is set to a <code>QueryConfig</code>, this configuration       is used for all modes.</li> <li>Alternatively, <code>__config__</code> can be set to a dictionary mapping       modes to configurations.</li> <li>If <code>__parser__</code> is set to a parser specification, the default       configuration is used for all modes, except that the       provided parser is used instead of the default one.</li> <li>Alternatively, <code>__parser__</code> can also be set to a dictionary.</li> </ul> <p>In the special case where the <code>parse</code> method is overriden and only in this case, return <code>None</code> after ensuring that <code>__config__</code> and <code>__parser__</code> are not set.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>def query_config(self, mode: dp.AnswerMode) -&gt; QueryConfig | None:\n    \"\"\"\n    Map modes to configurations.\n\n    This method inspects the `__config__` and `__parser__` class\n    attributes (none or either can be set but not both).\n\n    - If no attribute is set, the default configuration is used for\n          all modes, which uses the `\"structured\"` parser.\n    - If `__config__` is set to a `QueryConfig`, this configuration\n          is used for all modes.\n    - Alternatively, `__config__` can be set to a dictionary mapping\n          modes to configurations.\n    - If `__parser__` is set to a parser specification, the default\n          configuration is used for all modes, *except* that the\n          provided parser is used instead of the default one.\n    - Alternatively, `__parser__` can also be set to a dictionary.\n\n    In the special case where the `parse` method is overriden and\n    only in this case, return `None` after ensuring that\n    `__config__` and `__parser__` are not set.\n    \"\"\"\n    cls = type(self)\n    parse_overriden = dpi.is_method_overridden(Query, cls, \"parse\")\n    if parse_overriden:\n        assert cls.__config__ is None\n        assert cls.__parser__ is None\n        return None\n    if cls.__config__ is not None:\n        assert self.__parser__ is None, (\n            \"Cannot have both __config__ and __parser__ attributes.\"\n        )\n        config_attr = cls.__config__\n        if isinstance(config_attr, QueryConfig):\n            return config_attr\n        else:\n            assert isinstance(config_attr, Mapping)\n            return cast(Any, config_attr)[mode]\n    elif cls.__parser__ is not None:\n        parser_attr: Any = cls.__parser__\n        if isinstance(parser_attr, Mapping):\n            parser = cast(Any, parser_attr)[mode]\n        else:\n            parser = parser_attr\n        _check_valid_parser_spec(parser)\n        return QueryConfig(parser)\n    else:\n        return QueryConfig(\"structured\")\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Query.parse","title":"parse","text":"<pre><code>parse(answer: Answer) -&gt; Query[T]\n</code></pre> <p>A more convenient method to override instead of <code>parse_answer</code>.</p> <p>Raises <code>ParseError</code>.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>def parse(self, answer: Answer) -&gt; T:\n    \"\"\"\n    A more convenient method to override instead of `parse_answer`.\n\n    Raises `ParseError`.\n    \"\"\"\n\n    # Decompose the specified answer type\n    config = self.query_config(answer.mode)\n    assert config is not None\n    attr = config.parser\n    ans_type = self._decomposed_answer_type()\n\n    # Compute base parsing function `parser`\n    parser: _ParsingFunction[Any]\n    if attr == \"structured\":\n        parser = _from_structured(ans_type.to_parse)\n    elif attr == \"final_tool_call\":\n        assert isinstance(ans_type.to_parse, type)\n        parser = _from_final_tool_call(cast(type[Any], ans_type.to_parse))\n    else:\n        assert callable(attr)\n        attr = cast(Callable[..., Any], attr)\n        sig = inspect.signature(attr)\n        nargs = len(sig.parameters)\n        assert nargs == 1 or nargs == 2\n        if nargs == 1:\n            parser = _from_text_parser(attr)\n        else:\n            parser = _from_generic_text_parser(attr, ans_type.to_parse)\n\n    if ans_type.wrap_parse_errors():\n        parser = _wrap_parse_errors(parser)\n\n    # If the answer type has form `Response[..., ...]`\n    if ans_type.resp:\n        if _has_final_tool_call(ans_type, answer):\n            tcs = []\n        else:\n            tcs = [\n                _parse_tool_call(ans_type.resp.tools, tc)\n                for tc in answer.tool_calls\n            ]\n        if tcs:\n            return cast(T, Response(answer, ToolRequests(tcs)))\n        else:\n            return cast(T, Response(answer, FinalAnswer(parser(answer))))\n\n    return parser(answer)\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Query.query_settings","title":"query_settings","text":"<pre><code>query_settings(mode: AnswerMode) -&gt; QuerySettings\n</code></pre> <p>Return the settings associated with the query.</p> <p>By default, this method uses the result of <code>query_config</code> to determine settings if <code>parse</code> is not overriden, and the default set of settings otherwise.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>@override\ndef query_settings(self, mode: dp.AnswerMode) -&gt; dp.QuerySettings:\n    \"\"\"\n    Return the settings associated with the query.\n\n    By default, this method uses the result of `query_config` to\n    determine settings if `parse` is not overriden, and the default\n    set of settings otherwise.\n    \"\"\"\n    config = self.query_config(mode)\n    if config is None:\n        # `parse` is overriden\n        return dp.QuerySettings(structured_output=None, tools=None)\n    structured_output = None\n    if config.parser == \"structured\":\n        type = self._decomposed_answer_type().final\n        structured_output = dp.StructuredOutputSettings(type)\n    tools = None\n    if tool_types := self._query_tools(config.parser):\n        tools = dp.ToolSettings(\n            tool_types, force_tool_call=config.parser == \"final_tool_call\"\n        )\n    return dp.QuerySettings(\n        structured_output=structured_output,\n        tools=tools,\n    )\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Query.query_prefix","title":"query_prefix","text":"<pre><code>query_prefix() -&gt; AnswerPrefix | None\n</code></pre> <p>Return the value of the <code>prefix</code> attribute if it has type annotation <code>AnswerPrefix</code> or return <code>None</code>.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>@override\ndef query_prefix(self) -&gt; ct.AnswerPrefix | None:\n    \"\"\"\n    Return the value of the `prefix` attribute if it has type\n    annotation `AnswerPrefix` or return `None`.\n    \"\"\"\n    if self._has_special_prefix_attr():\n        return getattr(self, \"prefix\")\n    return None\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Query.globals","title":"globals","text":"<pre><code>globals() -&gt; dict[str, object] | None\n</code></pre> <p>Return global objects accessible in prompts via the <code>globals</code> attribute.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>def globals(self) -&gt; dict[str, object] | None:\n    \"\"\"\n    Return global objects accessible in prompts via the `globals`\n    attribute.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Query.using","title":"using","text":"<pre><code>using(get_policy: EllipsisType) -&gt; Opaque[IPDict, Query[T]]\n</code></pre><pre><code>using(get_policy: Callable[[using[P]], PromptingPolicy] | EllipsisType, /, inner_policy_type: type[using[P]] | None = None) -&gt; Opaque[using[P], Query[T]]\n</code></pre> <pre><code>using(get_policy: Callable[[using[P]], PromptingPolicy] | EllipsisType, /, inner_policy_type: type[using[P]] | None = None) -&gt; Opaque[using[P], Query[T]]\n</code></pre> <p>Turn a query into an opaque space by providing a mapping from the ambient inner policy to a prompting policy.</p> <p>Attributes:</p> Name Type Description <code>get_policy</code> <p>A function that maps the ambient inner policy to a prompting policy to use for answering the query. Alternatively, if the ellipsis value <code>...</code> is passed, the inner policy type is assumed to be <code>IPDict</code>, and prompting policies are automatically selected using tags (see <code>IPDict</code> documentation).</p> <code>inner_policy_type</code> <p>Ambient inner policy type. This information is not used at runtime but it can be provided to help type inference when necessary.</p> <p>The optional <code>inner_policy_type</code> argument is ignored at runtime and can be used to help type checkers infer the type of the ambient inner policy.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>def using[P](\n    self,\n    get_policy: Callable[[P], pol.PromptingPolicy] | EllipsisType,\n    /,\n    inner_policy_type: type[P] | None = None,\n) -&gt; Opaque[P, T]:\n    \"\"\"\n    Turn a query into an opaque space by providing a mapping from\n    the ambient inner policy to a prompting policy.\n\n    Attributes:\n        get_policy: A function that maps the ambient inner policy to\n            a prompting policy to use for answering the query.\n            Alternatively, if the ellipsis value `...` is passed, the\n            inner policy type is assumed to be `IPDict`, and\n            prompting policies are automatically selected using tags\n            (see `IPDict` documentation).\n        inner_policy_type: Ambient inner policy type. This information\n            is not used at runtime but it can be provided to help type\n            inference when necessary.\n\n    The optional `inner_policy_type` argument is ignored at runtime\n    and can be used to help type checkers infer the type of the\n    ambient inner policy.\n    \"\"\"\n    if isinstance(get_policy, EllipsisType):\n        return OpaqueSpace[P, T].from_query(\n            self, cast(Any, pol.dict_subpolicy)\n        )\n    return OpaqueSpace[P, T].from_query(self, lambda p, _: get_policy(p))\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Query.run_toplevel","title":"run_toplevel","text":"<pre><code>run_toplevel(env: PolicyEnv, policy: PromptingPolicy) -&gt; Stream[Query[T]]\n</code></pre> <p>Obtain a search stream of query answers, given a prompting policy.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>def run_toplevel(\n    self,\n    env: dp.PolicyEnv,\n    policy: pol.PromptingPolicy,\n) -&gt; Stream[T]:\n    \"\"\"\n    Obtain a search stream of query answers, given a prompting\n    policy.\n    \"\"\"\n    attached = dp.spawn_standalone_query(self)\n    return policy(attached, env)\n</code></pre>"},{"location":"dev/test-mkdocs/#documenting-a-class-without-members","title":"Documenting a Class without Members","text":""},{"location":"dev/test-mkdocs/#delphyne.Query","title":"Query","text":"<p>               Bases: <code>AbstractQuery[Query[T]]</code></p> <p>Base class for queries.</p> <p>This class adds standard convenience features on top of <code>AbstractQuery</code>, using reflection to allow queries to be defined concisely. Here is a simple example of a query type definition:</p> <pre><code>@dataclass class MakeSum(Query[list[int]]):\n    ''' Given a list of allowed numbers and a target number, you\n    must find a sub-list whose elements sum up to the target.\n    Just answer with a list of numbers as a JSON object and\n    nothing else. '''\n\n    allowed: list[int] target: int\n</code></pre> <p>In general, a query type is a dataclass that inherits <code>Query[T]</code>, where <code>T</code> is the query's answer type. In the example above, no parser is specified and so oracles are requested to provide structured answers as JSON objects, which are automatically parsed into the answer type (<code>list[int]</code>) using pydantic. Assuming that no Jinja prompt file is provided, the docstring is used as a system prompt and instance prompts are generated by simply serializing <code>MakeSum</code> instances into YAML.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--customizing-prompts","title":"Customizing Prompts","text":"<p>System and instance prompts can be specified via Jinja templates. The templates manager (<code>TemplatesManager</code>) looks for templates named \"..jinja\". Templates can also be provided by defining the <code>__system_prompt__</code> and/or <code>__instance_prompt__</code> class attributes. If none of these are provided, the query's docstring is used as a system prompt and <code>DEFAULT_INSTANCE_PROMPT</code> is used as an instance prompt template. <p>The following arguments are usually made available to templates (although specific prompting policies can add more):</p> <ul> <li><code>query</code>: the query instance.</li> <li><code>mode</code>: the requested answer mode.</li> <li><code>params</code>: the query hyperparameters (e.g., as passed to <code>few_shot</code>)</li> </ul>"},{"location":"dev/test-mkdocs/#delphyne.Query--answer-modes-and-configurations","title":"Answer Modes and Configurations","text":"<p>A query can define several answer modes (<code>AnswerMode</code>), each of which can be associated with a different parser and set of settings. By default, the only answer mode is <code>None</code>. More answer modes can be defined by setting class variable <code>__modes__</code>.</p> <p>The <code>query_config</code> method maps modes to configurations (i.e., a set of settings, including a parser specification). Its default behavior works by inspecting the <code>__parser__</code> and <code>__config__</code> class attributes and does not typically require overriding.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--allowing-multi-message-exchanges-and-tool-calls","title":"Allowing Multi-Message Exchanges and Tool Calls","text":"<p>A common pattern for interacting with LLMs is to have multi-message exchanges where the full conversation history is resent repeatedly. LLMs are also often allowed to request tool call. This interaction pattern is implemented in the [<code>interact</code>][delphyne.interact] standard strategy. It is enabled by several features on the <code>Query</code> side.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--answer-prefixes","title":"Answer Prefixes","text":"<p>If a query type has a prefix attribute with type <code>AnswerPrefix</code>, this attribute can be used to provide a chat history, to be added to the query's prompt.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--the-response-type","title":"The <code>Response</code> Type","text":"<p>If the query answer type is <code>Response</code>, the query does not only return a parsed answer, but also the LLM raw answer (which can be appended to a chat history), and possibly a sequence of tool calls.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--manually-overriding-the-parse-method","title":"Manually Overriding the <code>parse</code> Method","text":"<p>For advanced use cases, it is possible to directly override the <code>parse</code> method that turns an answer into an object of type <code>T</code>. When this is done, the <code>__config__</code> and <code>__parser__</code> class attributes must not be set. Also, the <code>query_settings</code> method always returns the default settings instead of relying on <code>query_config</code> and must be overriden if another behavior is desired.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>class Query[T](dp.AbstractQuery[T]):\n    \"\"\"\n    Base class for queries.\n\n    This class adds standard convenience features on top of\n    `AbstractQuery`, using reflection to allow queries to be defined\n    concisely. Here is a simple example of a query type definition:\n\n        @dataclass class MakeSum(Query[list[int]]):\n            ''' Given a list of allowed numbers and a target number, you\n            must find a sub-list whose elements sum up to the target.\n            Just answer with a list of numbers as a JSON object and\n            nothing else. '''\n\n            allowed: list[int] target: int\n\n    In general, a query type is a dataclass that inherits `Query[T]`,\n    where `T` is the query's answer type. In the example above, no\n    parser is specified and so oracles are requested to provide\n    structured answers as JSON objects, which are automatically parsed\n    into the answer type (`list[int]`) using pydantic. Assuming that no\n    Jinja prompt file is provided, the docstring is used as a system\n    prompt and instance prompts are generated by simply serializing\n    `MakeSum` instances into YAML.\n\n    ### Customizing Prompts\n\n    System and instance prompts can be specified via Jinja templates.\n    The templates manager (`TemplatesManager`) looks for templates named\n    \"&lt;QueryName&gt;.&lt;instance|system&gt;.jinja\". Templates can also be\n    provided by defining the `__system_prompt__` and/or `__instance_prompt__`\n    class attributes. If none of these are provided, the query's\n    docstring is used as a system prompt and `DEFAULT_INSTANCE_PROMPT`\n    is used as an instance prompt template.\n\n    The following arguments are usually made available to templates\n    (although specific prompting policies can add more):\n\n    - `query`: the query instance.\n    - `mode`: the requested answer mode.\n    - `params`: the query hyperparameters (e.g., as passed to `few_shot`)\n\n    ### Answer Modes and Configurations\n\n    A query can define several answer modes (`AnswerMode`), each of\n    which can be associated with a different parser and set of settings.\n    By default, the only answer mode is `None`. More answer modes can be\n    defined by setting class variable `__modes__`.\n\n    The `query_config` method maps modes to configurations (i.e., a set\n    of settings, including a parser specification). Its default behavior\n    works by inspecting the `__parser__` and `__config__` class\n    attributes and does not typically require overriding.\n\n    ### Allowing Multi-Message Exchanges and Tool Calls\n\n    A common pattern for interacting with LLMs is to have multi-message\n    exchanges where the full conversation history is resent repeatedly.\n    LLMs are also often allowed to request tool call. This interaction\n    pattern is implemented in the `interact` standard strategy. It is\n    enabled by several features on the `Query` side.\n\n    #### Answer Prefixes\n\n    If a query type has a prefix attribute with type `AnswerPrefix`,\n    this attribute can be used to provide a chat history, to be added to\n    the query's prompt.\n\n    #### The `Response` Type\n\n    If the query answer type is `Response`, the query does not only\n    return a parsed answer, but also the LLM raw answer (which can be\n    appended to a chat history), and possibly a sequence of tool calls.\n\n    ### Manually Overriding the `parse` Method\n\n    For advanced use cases, it is possible to directly override the\n    `parse` method that turns an answer into an object of type `T`. When\n    this is done, the `__config__` and `__parser__` class attributes\n    must not be set. Also, the `query_settings` method always returns\n    the default settings instead of relying on `query_config` and must\n    be overriden if another behavior is desired.\n    \"\"\"\n\n    __modes__: ClassVar[Sequence[dp.AnswerMode] | None] = None\n    __parser__: ClassVar[ParserSpec | ParserSpecDict | None] = None\n    __config__: ClassVar[QueryConfig | QueryConfigDict | None] = None\n\n    ### Inspection methods\n\n    def query_config(self, mode: dp.AnswerMode) -&gt; QueryConfig | None:\n        \"\"\"\n        Map modes to configurations.\n\n        This method inspects the `__config__` and `__parser__` class\n        attributes (none or either can be set but not both).\n\n        - If no attribute is set, the default configuration is used for\n              all modes, which uses the `\"structured\"` parser.\n        - If `__config__` is set to a `QueryConfig`, this configuration\n              is used for all modes.\n        - Alternatively, `__config__` can be set to a dictionary mapping\n              modes to configurations.\n        - If `__parser__` is set to a parser specification, the default\n              configuration is used for all modes, *except* that the\n              provided parser is used instead of the default one.\n        - Alternatively, `__parser__` can also be set to a dictionary.\n\n        In the special case where the `parse` method is overriden and\n        only in this case, return `None` after ensuring that\n        `__config__` and `__parser__` are not set.\n        \"\"\"\n        cls = type(self)\n        parse_overriden = dpi.is_method_overridden(Query, cls, \"parse\")\n        if parse_overriden:\n            assert cls.__config__ is None\n            assert cls.__parser__ is None\n            return None\n        if cls.__config__ is not None:\n            assert self.__parser__ is None, (\n                \"Cannot have both __config__ and __parser__ attributes.\"\n            )\n            config_attr = cls.__config__\n            if isinstance(config_attr, QueryConfig):\n                return config_attr\n            else:\n                assert isinstance(config_attr, Mapping)\n                return cast(Any, config_attr)[mode]\n        elif cls.__parser__ is not None:\n            parser_attr: Any = cls.__parser__\n            if isinstance(parser_attr, Mapping):\n                parser = cast(Any, parser_attr)[mode]\n            else:\n                parser = parser_attr\n            _check_valid_parser_spec(parser)\n            return QueryConfig(parser)\n        else:\n            return QueryConfig(\"structured\")\n\n    @classmethod\n    def _decomposed_answer_type(cls) -&gt; _DecomposedAnswerType:\n        return _DecomposedAnswerType(cls._answer_type())\n\n    ### Parsing Answers\n\n    @override\n    def parse_answer(self, answer: dp.Answer) -&gt; T | dp.ParseError:\n        assert answer.mode in self.query_modes(), (\n            f\"Unknown mode: {answer.mode}\"\n        )\n        try:\n            return self.parse(answer)\n        except dp.ParseError as e:\n            return e\n\n    def parse(self, answer: Answer) -&gt; T:\n        \"\"\"\n        A more convenient method to override instead of `parse_answer`.\n\n        Raises `ParseError`.\n        \"\"\"\n\n        # Decompose the specified answer type\n        config = self.query_config(answer.mode)\n        assert config is not None\n        attr = config.parser\n        ans_type = self._decomposed_answer_type()\n\n        # Compute base parsing function `parser`\n        parser: _ParsingFunction[Any]\n        if attr == \"structured\":\n            parser = _from_structured(ans_type.to_parse)\n        elif attr == \"final_tool_call\":\n            assert isinstance(ans_type.to_parse, type)\n            parser = _from_final_tool_call(cast(type[Any], ans_type.to_parse))\n        else:\n            assert callable(attr)\n            attr = cast(Callable[..., Any], attr)\n            sig = inspect.signature(attr)\n            nargs = len(sig.parameters)\n            assert nargs == 1 or nargs == 2\n            if nargs == 1:\n                parser = _from_text_parser(attr)\n            else:\n                parser = _from_generic_text_parser(attr, ans_type.to_parse)\n\n        if ans_type.wrap_parse_errors():\n            parser = _wrap_parse_errors(parser)\n\n        # If the answer type has form `Response[..., ...]`\n        if ans_type.resp:\n            if _has_final_tool_call(ans_type, answer):\n                tcs = []\n            else:\n                tcs = [\n                    _parse_tool_call(ans_type.resp.tools, tc)\n                    for tc in answer.tool_calls\n                ]\n            if tcs:\n                return cast(T, Response(answer, ToolRequests(tcs)))\n            else:\n                return cast(T, Response(answer, FinalAnswer(parser(answer))))\n\n        return parser(answer)\n\n    ### Query Settings\n\n    @override\n    def query_settings(self, mode: dp.AnswerMode) -&gt; dp.QuerySettings:\n        \"\"\"\n        Return the settings associated with the query.\n\n        By default, this method uses the result of `query_config` to\n        determine settings if `parse` is not overriden, and the default\n        set of settings otherwise.\n        \"\"\"\n        config = self.query_config(mode)\n        if config is None:\n            # `parse` is overriden\n            return dp.QuerySettings(structured_output=None, tools=None)\n        structured_output = None\n        if config.parser == \"structured\":\n            type = self._decomposed_answer_type().final\n            structured_output = dp.StructuredOutputSettings(type)\n        tools = None\n        if tool_types := self._query_tools(config.parser):\n            tools = dp.ToolSettings(\n                tool_types, force_tool_call=config.parser == \"final_tool_call\"\n            )\n        return dp.QuerySettings(\n            structured_output=structured_output,\n            tools=tools,\n        )\n\n    def _structured_output_type(self) -&gt; TypeAnnot[Any] | ty.NoTypeInfo:\n        decomposed = self._decomposed_answer_type()\n        return decomposed.final\n\n    def _query_tools(self, parser: ParserSpec) -&gt; Sequence[type[Any]]:\n        ans_type = self._decomposed_answer_type()\n        tools: list[type[Any]] = []\n        if ans_type.resp is not None:\n            tools = [*ans_type.resp.tools]\n        if parser == \"final_tool_call\":\n            assert isinstance(ans_type.final, type)\n            tools.append(ans_type.final)\n        return tools\n\n    ### Query Prefixes\n\n    @classmethod\n    def _has_special_prefix_attr(cls):\n        annots = typing.get_type_hints(cls)\n        return \"prefix\" in annots and annots[\"prefix\"] is ct.AnswerPrefix\n\n    @override\n    def query_prefix(self) -&gt; ct.AnswerPrefix | None:\n        \"\"\"\n        Return the value of the `prefix` attribute if it has type\n        annotation `AnswerPrefix` or return `None`.\n        \"\"\"\n        if self._has_special_prefix_attr():\n            return getattr(self, \"prefix\")\n        return None\n\n    ### Producing Prompts\n\n    @override\n    def generate_prompt(\n        self,\n        *,\n        kind: Literal[\"system\", \"instance\"] | str,\n        mode: dp.AnswerMode,\n        params: dict[str, object],\n        extra_args: dict[str, object] | None = None,\n        env: dp.TemplatesManager | None = None,\n    ) -&gt; str:\n        assert env is not None, _no_prompt_manager_error()\n        args: dict[str, object] = {\n            \"query\": self,\n            \"mode\": mode,\n            \"params\": params,\n        }\n        if extra_args:\n            args.update(extra_args)\n        if (glob := self.globals()) is not None:\n            args[\"globals\"] = glob\n        return env.prompt(\n            query_name=self.query_name(),\n            prompt_kind=kind,\n            template_args=args,\n            default_template=self._default_prompt(kind),\n        )\n\n    @classmethod\n    def _default_prompt(\n        cls, kind: Literal[\"system\", \"instance\"] | str\n    ) -&gt; str | None:\n        attr_name = f\"__{kind}_prompt__\"\n        if hasattr(cls, attr_name):\n            res = getattr(cls, attr_name)\n            assert isinstance(res, str)\n            return textwrap.dedent(res).strip()\n        if kind == \"instance\":\n            if cls._has_special_prefix_attr():\n                return DEFAULT_INSTANCE_PROMPT_WITH_PREFIX\n            else:\n                return DEFAULT_INSTANCE_PROMPT\n        if kind == \"system\" and (doc := inspect.getdoc(cls)) is not None:\n            return doc\n        if kind == \"feedback\":\n            return DEFAULT_FEEDBACK_PROMPT\n        return None\n\n    def globals(self) -&gt; dict[str, object] | None:\n        \"\"\"\n        Return global objects accessible in prompts via the `globals`\n        attribute.\n        \"\"\"\n        return None\n\n    ### Other Simple Overrides\n\n    @override\n    def serialize_args(self) -&gt; dict[str, object]:\n        return cast(dict[str, object], ty.pydantic_dump(type(self), self))\n\n    @classmethod\n    def _answer_type(cls) -&gt; TypeAnnot[T]:\n        return dpi.first_parameter_of_base_class(cls)\n\n    @override\n    def answer_type(self) -&gt; TypeAnnot[T]:\n        return self._answer_type()\n\n    @override\n    def finite_answer_set(self) -&gt; Sequence[dp.Answer] | None:\n        # We handle the special case where the return type is a literal\n        # type that is a subtype of str.\n        ans = self.answer_type()\n        if (res := _match_string_literal_type(ans)) is not None:\n            return [dp.Answer(None, v) for v in res]\n        return None\n\n    @override\n    def query_modes(self) -&gt; Sequence[dp.AnswerMode]:\n        if self.__modes__ is not None:\n            return self.__modes__\n        return [None]\n\n    ### Generating Opaque Spaces\n\n    @overload\n    def using(self, get_policy: EllipsisType, /) -&gt; Opaque[IPDict, T]: ...\n\n    @overload\n    def using[P](\n        self,\n        get_policy: Callable[[P], pol.PromptingPolicy] | EllipsisType,\n        /,\n        inner_policy_type: type[P] | None = None,\n    ) -&gt; Opaque[P, T]: ...\n\n    def using[P](\n        self,\n        get_policy: Callable[[P], pol.PromptingPolicy] | EllipsisType,\n        /,\n        inner_policy_type: type[P] | None = None,\n    ) -&gt; Opaque[P, T]:\n        \"\"\"\n        Turn a query into an opaque space by providing a mapping from\n        the ambient inner policy to a prompting policy.\n\n        Attributes:\n            get_policy: A function that maps the ambient inner policy to\n                a prompting policy to use for answering the query.\n                Alternatively, if the ellipsis value `...` is passed, the\n                inner policy type is assumed to be `IPDict`, and\n                prompting policies are automatically selected using tags\n                (see `IPDict` documentation).\n            inner_policy_type: Ambient inner policy type. This information\n                is not used at runtime but it can be provided to help type\n                inference when necessary.\n\n        The optional `inner_policy_type` argument is ignored at runtime\n        and can be used to help type checkers infer the type of the\n        ambient inner policy.\n        \"\"\"\n        if isinstance(get_policy, EllipsisType):\n            return OpaqueSpace[P, T].from_query(\n                self, cast(Any, pol.dict_subpolicy)\n            )\n        return OpaqueSpace[P, T].from_query(self, lambda p, _: get_policy(p))\n\n    def run_toplevel(\n        self,\n        env: dp.PolicyEnv,\n        policy: pol.PromptingPolicy,\n    ) -&gt; Stream[T]:\n        \"\"\"\n        Obtain a search stream of query answers, given a prompting\n        policy.\n        \"\"\"\n        attached = dp.spawn_standalone_query(self)\n        return policy(attached, env)\n</code></pre>"},{"location":"dev/test-mkdocs/#documenting-a-class-with-selected-members","title":"Documenting a Class With Selected Members","text":""},{"location":"dev/test-mkdocs/#delphyne.Query","title":"Query","text":"<p>               Bases: <code>AbstractQuery[Query[T]]</code></p> <p>Base class for queries.</p> <p>This class adds standard convenience features on top of <code>AbstractQuery</code>, using reflection to allow queries to be defined concisely. Here is a simple example of a query type definition:</p> <pre><code>@dataclass class MakeSum(Query[list[int]]):\n    ''' Given a list of allowed numbers and a target number, you\n    must find a sub-list whose elements sum up to the target.\n    Just answer with a list of numbers as a JSON object and\n    nothing else. '''\n\n    allowed: list[int] target: int\n</code></pre> <p>In general, a query type is a dataclass that inherits <code>Query[T]</code>, where <code>T</code> is the query's answer type. In the example above, no parser is specified and so oracles are requested to provide structured answers as JSON objects, which are automatically parsed into the answer type (<code>list[int]</code>) using pydantic. Assuming that no Jinja prompt file is provided, the docstring is used as a system prompt and instance prompts are generated by simply serializing <code>MakeSum</code> instances into YAML.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--customizing-prompts","title":"Customizing Prompts","text":"<p>System and instance prompts can be specified via Jinja templates. The templates manager (<code>TemplatesManager</code>) looks for templates named \"..jinja\". Templates can also be provided by defining the <code>__system_prompt__</code> and/or <code>__instance_prompt__</code> class attributes. If none of these are provided, the query's docstring is used as a system prompt and <code>DEFAULT_INSTANCE_PROMPT</code> is used as an instance prompt template. <p>The following arguments are usually made available to templates (although specific prompting policies can add more):</p> <ul> <li><code>query</code>: the query instance.</li> <li><code>mode</code>: the requested answer mode.</li> <li><code>params</code>: the query hyperparameters (e.g., as passed to <code>few_shot</code>)</li> </ul>"},{"location":"dev/test-mkdocs/#delphyne.Query--answer-modes-and-configurations","title":"Answer Modes and Configurations","text":"<p>A query can define several answer modes (<code>AnswerMode</code>), each of which can be associated with a different parser and set of settings. By default, the only answer mode is <code>None</code>. More answer modes can be defined by setting class variable <code>__modes__</code>.</p> <p>The <code>query_config</code> method maps modes to configurations (i.e., a set of settings, including a parser specification). Its default behavior works by inspecting the <code>__parser__</code> and <code>__config__</code> class attributes and does not typically require overriding.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--allowing-multi-message-exchanges-and-tool-calls","title":"Allowing Multi-Message Exchanges and Tool Calls","text":"<p>A common pattern for interacting with LLMs is to have multi-message exchanges where the full conversation history is resent repeatedly. LLMs are also often allowed to request tool call. This interaction pattern is implemented in the [<code>interact</code>][delphyne.interact] standard strategy. It is enabled by several features on the <code>Query</code> side.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--answer-prefixes","title":"Answer Prefixes","text":"<p>If a query type has a prefix attribute with type <code>AnswerPrefix</code>, this attribute can be used to provide a chat history, to be added to the query's prompt.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--the-response-type","title":"The <code>Response</code> Type","text":"<p>If the query answer type is <code>Response</code>, the query does not only return a parsed answer, but also the LLM raw answer (which can be appended to a chat history), and possibly a sequence of tool calls.</p>"},{"location":"dev/test-mkdocs/#delphyne.Query--manually-overriding-the-parse-method","title":"Manually Overriding the <code>parse</code> Method","text":"<p>For advanced use cases, it is possible to directly override the <code>parse</code> method that turns an answer into an object of type <code>T</code>. When this is done, the <code>__config__</code> and <code>__parser__</code> class attributes must not be set. Also, the <code>query_settings</code> method always returns the default settings instead of relying on <code>query_config</code> and must be overriden if another behavior is desired.</p> <p>Methods:</p> Name Description <code>parse_answer</code> <code>query_config</code> <p>Map modes to configurations.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>class Query[T](dp.AbstractQuery[T]):\n    \"\"\"\n    Base class for queries.\n\n    This class adds standard convenience features on top of\n    `AbstractQuery`, using reflection to allow queries to be defined\n    concisely. Here is a simple example of a query type definition:\n\n        @dataclass class MakeSum(Query[list[int]]):\n            ''' Given a list of allowed numbers and a target number, you\n            must find a sub-list whose elements sum up to the target.\n            Just answer with a list of numbers as a JSON object and\n            nothing else. '''\n\n            allowed: list[int] target: int\n\n    In general, a query type is a dataclass that inherits `Query[T]`,\n    where `T` is the query's answer type. In the example above, no\n    parser is specified and so oracles are requested to provide\n    structured answers as JSON objects, which are automatically parsed\n    into the answer type (`list[int]`) using pydantic. Assuming that no\n    Jinja prompt file is provided, the docstring is used as a system\n    prompt and instance prompts are generated by simply serializing\n    `MakeSum` instances into YAML.\n\n    ### Customizing Prompts\n\n    System and instance prompts can be specified via Jinja templates.\n    The templates manager (`TemplatesManager`) looks for templates named\n    \"&lt;QueryName&gt;.&lt;instance|system&gt;.jinja\". Templates can also be\n    provided by defining the `__system_prompt__` and/or `__instance_prompt__`\n    class attributes. If none of these are provided, the query's\n    docstring is used as a system prompt and `DEFAULT_INSTANCE_PROMPT`\n    is used as an instance prompt template.\n\n    The following arguments are usually made available to templates\n    (although specific prompting policies can add more):\n\n    - `query`: the query instance.\n    - `mode`: the requested answer mode.\n    - `params`: the query hyperparameters (e.g., as passed to `few_shot`)\n\n    ### Answer Modes and Configurations\n\n    A query can define several answer modes (`AnswerMode`), each of\n    which can be associated with a different parser and set of settings.\n    By default, the only answer mode is `None`. More answer modes can be\n    defined by setting class variable `__modes__`.\n\n    The `query_config` method maps modes to configurations (i.e., a set\n    of settings, including a parser specification). Its default behavior\n    works by inspecting the `__parser__` and `__config__` class\n    attributes and does not typically require overriding.\n\n    ### Allowing Multi-Message Exchanges and Tool Calls\n\n    A common pattern for interacting with LLMs is to have multi-message\n    exchanges where the full conversation history is resent repeatedly.\n    LLMs are also often allowed to request tool call. This interaction\n    pattern is implemented in the `interact` standard strategy. It is\n    enabled by several features on the `Query` side.\n\n    #### Answer Prefixes\n\n    If a query type has a prefix attribute with type `AnswerPrefix`,\n    this attribute can be used to provide a chat history, to be added to\n    the query's prompt.\n\n    #### The `Response` Type\n\n    If the query answer type is `Response`, the query does not only\n    return a parsed answer, but also the LLM raw answer (which can be\n    appended to a chat history), and possibly a sequence of tool calls.\n\n    ### Manually Overriding the `parse` Method\n\n    For advanced use cases, it is possible to directly override the\n    `parse` method that turns an answer into an object of type `T`. When\n    this is done, the `__config__` and `__parser__` class attributes\n    must not be set. Also, the `query_settings` method always returns\n    the default settings instead of relying on `query_config` and must\n    be overriden if another behavior is desired.\n    \"\"\"\n\n    __modes__: ClassVar[Sequence[dp.AnswerMode] | None] = None\n    __parser__: ClassVar[ParserSpec | ParserSpecDict | None] = None\n    __config__: ClassVar[QueryConfig | QueryConfigDict | None] = None\n\n    ### Inspection methods\n\n    def query_config(self, mode: dp.AnswerMode) -&gt; QueryConfig | None:\n        \"\"\"\n        Map modes to configurations.\n\n        This method inspects the `__config__` and `__parser__` class\n        attributes (none or either can be set but not both).\n\n        - If no attribute is set, the default configuration is used for\n              all modes, which uses the `\"structured\"` parser.\n        - If `__config__` is set to a `QueryConfig`, this configuration\n              is used for all modes.\n        - Alternatively, `__config__` can be set to a dictionary mapping\n              modes to configurations.\n        - If `__parser__` is set to a parser specification, the default\n              configuration is used for all modes, *except* that the\n              provided parser is used instead of the default one.\n        - Alternatively, `__parser__` can also be set to a dictionary.\n\n        In the special case where the `parse` method is overriden and\n        only in this case, return `None` after ensuring that\n        `__config__` and `__parser__` are not set.\n        \"\"\"\n        cls = type(self)\n        parse_overriden = dpi.is_method_overridden(Query, cls, \"parse\")\n        if parse_overriden:\n            assert cls.__config__ is None\n            assert cls.__parser__ is None\n            return None\n        if cls.__config__ is not None:\n            assert self.__parser__ is None, (\n                \"Cannot have both __config__ and __parser__ attributes.\"\n            )\n            config_attr = cls.__config__\n            if isinstance(config_attr, QueryConfig):\n                return config_attr\n            else:\n                assert isinstance(config_attr, Mapping)\n                return cast(Any, config_attr)[mode]\n        elif cls.__parser__ is not None:\n            parser_attr: Any = cls.__parser__\n            if isinstance(parser_attr, Mapping):\n                parser = cast(Any, parser_attr)[mode]\n            else:\n                parser = parser_attr\n            _check_valid_parser_spec(parser)\n            return QueryConfig(parser)\n        else:\n            return QueryConfig(\"structured\")\n\n    @classmethod\n    def _decomposed_answer_type(cls) -&gt; _DecomposedAnswerType:\n        return _DecomposedAnswerType(cls._answer_type())\n\n    ### Parsing Answers\n\n    @override\n    def parse_answer(self, answer: dp.Answer) -&gt; T | dp.ParseError:\n        assert answer.mode in self.query_modes(), (\n            f\"Unknown mode: {answer.mode}\"\n        )\n        try:\n            return self.parse(answer)\n        except dp.ParseError as e:\n            return e\n\n    def parse(self, answer: Answer) -&gt; T:\n        \"\"\"\n        A more convenient method to override instead of `parse_answer`.\n\n        Raises `ParseError`.\n        \"\"\"\n\n        # Decompose the specified answer type\n        config = self.query_config(answer.mode)\n        assert config is not None\n        attr = config.parser\n        ans_type = self._decomposed_answer_type()\n\n        # Compute base parsing function `parser`\n        parser: _ParsingFunction[Any]\n        if attr == \"structured\":\n            parser = _from_structured(ans_type.to_parse)\n        elif attr == \"final_tool_call\":\n            assert isinstance(ans_type.to_parse, type)\n            parser = _from_final_tool_call(cast(type[Any], ans_type.to_parse))\n        else:\n            assert callable(attr)\n            attr = cast(Callable[..., Any], attr)\n            sig = inspect.signature(attr)\n            nargs = len(sig.parameters)\n            assert nargs == 1 or nargs == 2\n            if nargs == 1:\n                parser = _from_text_parser(attr)\n            else:\n                parser = _from_generic_text_parser(attr, ans_type.to_parse)\n\n        if ans_type.wrap_parse_errors():\n            parser = _wrap_parse_errors(parser)\n\n        # If the answer type has form `Response[..., ...]`\n        if ans_type.resp:\n            if _has_final_tool_call(ans_type, answer):\n                tcs = []\n            else:\n                tcs = [\n                    _parse_tool_call(ans_type.resp.tools, tc)\n                    for tc in answer.tool_calls\n                ]\n            if tcs:\n                return cast(T, Response(answer, ToolRequests(tcs)))\n            else:\n                return cast(T, Response(answer, FinalAnswer(parser(answer))))\n\n        return parser(answer)\n\n    ### Query Settings\n\n    @override\n    def query_settings(self, mode: dp.AnswerMode) -&gt; dp.QuerySettings:\n        \"\"\"\n        Return the settings associated with the query.\n\n        By default, this method uses the result of `query_config` to\n        determine settings if `parse` is not overriden, and the default\n        set of settings otherwise.\n        \"\"\"\n        config = self.query_config(mode)\n        if config is None:\n            # `parse` is overriden\n            return dp.QuerySettings(structured_output=None, tools=None)\n        structured_output = None\n        if config.parser == \"structured\":\n            type = self._decomposed_answer_type().final\n            structured_output = dp.StructuredOutputSettings(type)\n        tools = None\n        if tool_types := self._query_tools(config.parser):\n            tools = dp.ToolSettings(\n                tool_types, force_tool_call=config.parser == \"final_tool_call\"\n            )\n        return dp.QuerySettings(\n            structured_output=structured_output,\n            tools=tools,\n        )\n\n    def _structured_output_type(self) -&gt; TypeAnnot[Any] | ty.NoTypeInfo:\n        decomposed = self._decomposed_answer_type()\n        return decomposed.final\n\n    def _query_tools(self, parser: ParserSpec) -&gt; Sequence[type[Any]]:\n        ans_type = self._decomposed_answer_type()\n        tools: list[type[Any]] = []\n        if ans_type.resp is not None:\n            tools = [*ans_type.resp.tools]\n        if parser == \"final_tool_call\":\n            assert isinstance(ans_type.final, type)\n            tools.append(ans_type.final)\n        return tools\n\n    ### Query Prefixes\n\n    @classmethod\n    def _has_special_prefix_attr(cls):\n        annots = typing.get_type_hints(cls)\n        return \"prefix\" in annots and annots[\"prefix\"] is ct.AnswerPrefix\n\n    @override\n    def query_prefix(self) -&gt; ct.AnswerPrefix | None:\n        \"\"\"\n        Return the value of the `prefix` attribute if it has type\n        annotation `AnswerPrefix` or return `None`.\n        \"\"\"\n        if self._has_special_prefix_attr():\n            return getattr(self, \"prefix\")\n        return None\n\n    ### Producing Prompts\n\n    @override\n    def generate_prompt(\n        self,\n        *,\n        kind: Literal[\"system\", \"instance\"] | str,\n        mode: dp.AnswerMode,\n        params: dict[str, object],\n        extra_args: dict[str, object] | None = None,\n        env: dp.TemplatesManager | None = None,\n    ) -&gt; str:\n        assert env is not None, _no_prompt_manager_error()\n        args: dict[str, object] = {\n            \"query\": self,\n            \"mode\": mode,\n            \"params\": params,\n        }\n        if extra_args:\n            args.update(extra_args)\n        if (glob := self.globals()) is not None:\n            args[\"globals\"] = glob\n        return env.prompt(\n            query_name=self.query_name(),\n            prompt_kind=kind,\n            template_args=args,\n            default_template=self._default_prompt(kind),\n        )\n\n    @classmethod\n    def _default_prompt(\n        cls, kind: Literal[\"system\", \"instance\"] | str\n    ) -&gt; str | None:\n        attr_name = f\"__{kind}_prompt__\"\n        if hasattr(cls, attr_name):\n            res = getattr(cls, attr_name)\n            assert isinstance(res, str)\n            return textwrap.dedent(res).strip()\n        if kind == \"instance\":\n            if cls._has_special_prefix_attr():\n                return DEFAULT_INSTANCE_PROMPT_WITH_PREFIX\n            else:\n                return DEFAULT_INSTANCE_PROMPT\n        if kind == \"system\" and (doc := inspect.getdoc(cls)) is not None:\n            return doc\n        if kind == \"feedback\":\n            return DEFAULT_FEEDBACK_PROMPT\n        return None\n\n    def globals(self) -&gt; dict[str, object] | None:\n        \"\"\"\n        Return global objects accessible in prompts via the `globals`\n        attribute.\n        \"\"\"\n        return None\n\n    ### Other Simple Overrides\n\n    @override\n    def serialize_args(self) -&gt; dict[str, object]:\n        return cast(dict[str, object], ty.pydantic_dump(type(self), self))\n\n    @classmethod\n    def _answer_type(cls) -&gt; TypeAnnot[T]:\n        return dpi.first_parameter_of_base_class(cls)\n\n    @override\n    def answer_type(self) -&gt; TypeAnnot[T]:\n        return self._answer_type()\n\n    @override\n    def finite_answer_set(self) -&gt; Sequence[dp.Answer] | None:\n        # We handle the special case where the return type is a literal\n        # type that is a subtype of str.\n        ans = self.answer_type()\n        if (res := _match_string_literal_type(ans)) is not None:\n            return [dp.Answer(None, v) for v in res]\n        return None\n\n    @override\n    def query_modes(self) -&gt; Sequence[dp.AnswerMode]:\n        if self.__modes__ is not None:\n            return self.__modes__\n        return [None]\n\n    ### Generating Opaque Spaces\n\n    @overload\n    def using(self, get_policy: EllipsisType, /) -&gt; Opaque[IPDict, T]: ...\n\n    @overload\n    def using[P](\n        self,\n        get_policy: Callable[[P], pol.PromptingPolicy] | EllipsisType,\n        /,\n        inner_policy_type: type[P] | None = None,\n    ) -&gt; Opaque[P, T]: ...\n\n    def using[P](\n        self,\n        get_policy: Callable[[P], pol.PromptingPolicy] | EllipsisType,\n        /,\n        inner_policy_type: type[P] | None = None,\n    ) -&gt; Opaque[P, T]:\n        \"\"\"\n        Turn a query into an opaque space by providing a mapping from\n        the ambient inner policy to a prompting policy.\n\n        Attributes:\n            get_policy: A function that maps the ambient inner policy to\n                a prompting policy to use for answering the query.\n                Alternatively, if the ellipsis value `...` is passed, the\n                inner policy type is assumed to be `IPDict`, and\n                prompting policies are automatically selected using tags\n                (see `IPDict` documentation).\n            inner_policy_type: Ambient inner policy type. This information\n                is not used at runtime but it can be provided to help type\n                inference when necessary.\n\n        The optional `inner_policy_type` argument is ignored at runtime\n        and can be used to help type checkers infer the type of the\n        ambient inner policy.\n        \"\"\"\n        if isinstance(get_policy, EllipsisType):\n            return OpaqueSpace[P, T].from_query(\n                self, cast(Any, pol.dict_subpolicy)\n            )\n        return OpaqueSpace[P, T].from_query(self, lambda p, _: get_policy(p))\n\n    def run_toplevel(\n        self,\n        env: dp.PolicyEnv,\n        policy: pol.PromptingPolicy,\n    ) -&gt; Stream[T]:\n        \"\"\"\n        Obtain a search stream of query answers, given a prompting\n        policy.\n        \"\"\"\n        attached = dp.spawn_standalone_query(self)\n        return policy(attached, env)\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Query.parse_answer","title":"parse_answer","text":"<pre><code>parse_answer(answer: Answer) -&gt; Query[T] | ParseError\n</code></pre> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>@override\ndef parse_answer(self, answer: dp.Answer) -&gt; T | dp.ParseError:\n    assert answer.mode in self.query_modes(), (\n        f\"Unknown mode: {answer.mode}\"\n    )\n    try:\n        return self.parse(answer)\n    except dp.ParseError as e:\n        return e\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.Query.query_config","title":"query_config","text":"<pre><code>query_config(mode: AnswerMode) -&gt; QueryConfig | None\n</code></pre> <p>Map modes to configurations.</p> <p>This method inspects the <code>__config__</code> and <code>__parser__</code> class attributes (none or either can be set but not both).</p> <ul> <li>If no attribute is set, the default configuration is used for       all modes, which uses the <code>\"structured\"</code> parser.</li> <li>If <code>__config__</code> is set to a <code>QueryConfig</code>, this configuration       is used for all modes.</li> <li>Alternatively, <code>__config__</code> can be set to a dictionary mapping       modes to configurations.</li> <li>If <code>__parser__</code> is set to a parser specification, the default       configuration is used for all modes, except that the       provided parser is used instead of the default one.</li> <li>Alternatively, <code>__parser__</code> can also be set to a dictionary.</li> </ul> <p>In the special case where the <code>parse</code> method is overriden and only in this case, return <code>None</code> after ensuring that <code>__config__</code> and <code>__parser__</code> are not set.</p> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>def query_config(self, mode: dp.AnswerMode) -&gt; QueryConfig | None:\n    \"\"\"\n    Map modes to configurations.\n\n    This method inspects the `__config__` and `__parser__` class\n    attributes (none or either can be set but not both).\n\n    - If no attribute is set, the default configuration is used for\n          all modes, which uses the `\"structured\"` parser.\n    - If `__config__` is set to a `QueryConfig`, this configuration\n          is used for all modes.\n    - Alternatively, `__config__` can be set to a dictionary mapping\n          modes to configurations.\n    - If `__parser__` is set to a parser specification, the default\n          configuration is used for all modes, *except* that the\n          provided parser is used instead of the default one.\n    - Alternatively, `__parser__` can also be set to a dictionary.\n\n    In the special case where the `parse` method is overriden and\n    only in this case, return `None` after ensuring that\n    `__config__` and `__parser__` are not set.\n    \"\"\"\n    cls = type(self)\n    parse_overriden = dpi.is_method_overridden(Query, cls, \"parse\")\n    if parse_overriden:\n        assert cls.__config__ is None\n        assert cls.__parser__ is None\n        return None\n    if cls.__config__ is not None:\n        assert self.__parser__ is None, (\n            \"Cannot have both __config__ and __parser__ attributes.\"\n        )\n        config_attr = cls.__config__\n        if isinstance(config_attr, QueryConfig):\n            return config_attr\n        else:\n            assert isinstance(config_attr, Mapping)\n            return cast(Any, config_attr)[mode]\n    elif cls.__parser__ is not None:\n        parser_attr: Any = cls.__parser__\n        if isinstance(parser_attr, Mapping):\n            parser = cast(Any, parser_attr)[mode]\n        else:\n            parser = parser_attr\n        _check_valid_parser_spec(parser)\n        return QueryConfig(parser)\n    else:\n        return QueryConfig(\"structured\")\n</code></pre>"},{"location":"dev/test-mkdocs/#documenting-a-dataclass","title":"Documenting a Dataclass","text":""},{"location":"dev/test-mkdocs/#delphyne.core.AttachedQuery","title":"AttachedQuery  <code>dataclass</code>","text":"<p>Wrapper for a query attached to a specific space.</p> <p>Attributes:</p> Name Type Description <code>query</code> <code>AbstractQuery[AttachedQuery[T]]</code> <p>The wrapped query.</p> <code>ref</code> <code>GlobalSpacePath</code> <p>A global reference to the space to which the query is attached.</p> <code>parse_answer</code> <code>Callable[[Answer], Tracked[AttachedQuery[T]] | ParseError]</code> <p>A wrapper around <code>self.query.parse_answer</code>, which attaches proper tracking information to answers.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass AttachedQuery[T]:\n    \"\"\"\n    Wrapper for a query attached to a specific space.\n\n    Attributes:\n        query: The wrapped query.\n        ref: A global reference to the space to which the query is\n            attached.\n        parse_answer: A wrapper around `self.query.parse_answer`,\n            which attaches proper tracking information to answers.\n    \"\"\"\n\n    query: AbstractQuery[T]\n    ref: refs.GlobalSpacePath\n    parse_answer: Callable[[refs.Answer], Tracked[T] | ParseError]\n</code></pre>"},{"location":"dev/test-mkdocs/#documenting-a-function","title":"Documenting a Function","text":"<p>The standard few-shot prompting policy.</p> <p>A prompt is formed by concatenating a system prompt, a series of examples (each of which consists in an instance prompt followed by an answer), and a final answer prompt. Then, answers are repeatedly sampled and parsed, until a spending request is declined.</p> <p>Arguments:</p> <pre><code>query: The query to answer. env: The policy environment. model:\nThe LLM to use for answering the query. params: Prompt\nhyperparameters, which are passed to prompt\n    templates as a `params` dictionary.\nselect_examples: A series of filters for selecting examples, to\n    be applied in sequence. By default, no filter is used and so\n    all available examples are fetched.\nmode: The answer mode to use for parsing the query answer.\nenable_logging: Whether to log raw oracle responses.\ntemperature: The temperature parameter to use with the LLM, as a\n    number from 0 to 2.\nnum_concurrent: The number of completions to request for each\n    LLM call. Note that most LLM providers only bill input\n    tokens once, regardless of the number of completions.\nmax_requests: The maximum number of LLM requests to perform\n    before the resulting seach stream terminates, if any.\nno_wrap_parse_errors: If set to `True`, then parser results of\n    type [`WrappedParseError`][delphyne.WrappedParseError] are unwrapped and treated as normal\n    parse errors.\niterative_mode: If set to `False` (default), answers are\n    repeatedly and independently sampled. If set to `True`, a\n    single chat conversation occurs instead: Whenever a parse\n    error occurs, a message is issued by rendering the\n    `&lt;QueryName&gt;.repair.jinja` template, asking for a new\n    attempt to be made (the [`ParseError`][delphyne.ParseError] object is available as\n    an `error` template variable). After an answer is\n    successfully generated and parsed, a message is issued by\n    rendering the `&lt;QueryName&gt;.more.jinja` template, asking for\n    another different answer to be generated.\n\n    This special mode allows creating simple conversational\n    agents with very little effort, by only defining a single\n    query. However, it does not support tool calls, and the\n    demonstration language cannot be used to illustrate how\n    `repair` and `more` messages should be handled. For\n    implementing more advanced conversational agents, see\n    the standard [`interact`][delphyne.interact] strategy.\n</code></pre> Source code in <code>src/delphyne/stdlib/queries.py</code> <pre><code>@prompting_policy\ndef few_shot[T](\n    query: dp.AttachedQuery[T],\n    env: dp.PolicyEnv,\n    model: md.LLM,\n    *,\n    params: dict[str, object] | None = None,\n    select_examples: Sequence[ExampleSelector] = (),\n    mode: dp.AnswerMode = None,\n    enable_logging: bool = True,\n    temperature: float | None = None,\n    num_concurrent: int = 1,\n    max_requests: int | None = None,\n    no_wrap_parse_errors: bool = False,\n    iterative_mode: bool = False,\n) -&gt; dp.StreamGen[T]:\n    \"\"\"\n    The standard few-shot prompting policy.\n\n    A prompt is formed by concatenating a system prompt, a series of\n    examples (each of which consists in an instance prompt followed by\n    an answer), and a final answer prompt. Then, answers are repeatedly\n    sampled and parsed, until a spending request is declined.\n\n    Arguments:\n\n        query: The query to answer. env: The policy environment. model:\n        The LLM to use for answering the query. params: Prompt\n        hyperparameters, which are passed to prompt\n            templates as a `params` dictionary.\n        select_examples: A series of filters for selecting examples, to\n            be applied in sequence. By default, no filter is used and so\n            all available examples are fetched.\n        mode: The answer mode to use for parsing the query answer.\n        enable_logging: Whether to log raw oracle responses.\n        temperature: The temperature parameter to use with the LLM, as a\n            number from 0 to 2.\n        num_concurrent: The number of completions to request for each\n            LLM call. Note that most LLM providers only bill input\n            tokens once, regardless of the number of completions.\n        max_requests: The maximum number of LLM requests to perform\n            before the resulting seach stream terminates, if any.\n        no_wrap_parse_errors: If set to `True`, then parser results of\n            type `WrappedParseError` are unwrapped and treated as normal\n            parse errors.\n        iterative_mode: If set to `False` (default), answers are\n            repeatedly and independently sampled. If set to `True`, a\n            single chat conversation occurs instead: Whenever a parse\n            error occurs, a message is issued by rendering the\n            `&lt;QueryName&gt;.repair.jinja` template, asking for a new\n            attempt to be made (the `ParseError` object is available as\n            an `error` template variable). After an answer is\n            successfully generated and parsed, a message is issued by\n            rendering the `&lt;QueryName&gt;.more.jinja` template, asking for\n            another different answer to be generated.\n\n            This special mode allows creating simple conversational\n            agents with very little effort, by only defining a single\n            query. However, it does not support tool calls, and the\n            demonstration language cannot be used to illustrate how\n            `repair` and `more` messages should be handled. For\n            implementing more advanced conversational agents, see\n            the standard `interact` strategy.\n    \"\"\"\n    assert not iterative_mode or num_concurrent == 1\n    assert max_requests is None or max_requests &gt; 0\n    env.tracer.trace_query(query.ref)\n    examples = fetch_examples(env.examples, query.query, select_examples)\n    mngr = env.templates\n    if params is None:\n        params = {}\n    prompt = create_prompt(query.query, examples, params, mode, mngr)\n    settings = query.query.query_settings(mode)\n    options: md.RequestOptions = {}\n    if temperature is not None:\n        options[\"temperature\"] = temperature\n    structured_output = None\n    if settings.structured_output is not None:\n        out_type = settings.structured_output.type\n        structured_output = md.Schema.make(out_type)\n    tools = []\n    if settings.tools is not None:\n        if settings.tools.force_tool_call:\n            options[\"tool_choice\"] = \"required\"\n        tools = [md.Schema.make(t) for t in settings.tools.tool_types]\n    num_reqs = 0\n    while max_requests is None or num_reqs &lt; max_requests:\n        num_reqs += 1\n        req = md.LLMRequest(\n            prompt,\n            num_completions=num_concurrent,\n            options=options,\n            tools=tools,\n            structured_output=structured_output,\n        )\n        resp = yield from _send_request(model, req, env)\n        if isinstance(resp, SpendingDeclined):\n            return\n        log_oracle_response(env, query, req, resp, verbose=enable_logging)\n        if not resp.outputs:\n            log(env, \"llm_no_output\", loc=query)\n            continue\n        elements: list[dp.Tracked[T] | dp.ParseError] = []\n        answers: list[dp.Answer] = []\n        for output in resp.outputs:\n            answer = dp.Answer(mode, output.content, tuple(output.tool_calls))\n            answers.append(answer)\n            element = query.parse_answer(answer)\n            if no_wrap_parse_errors:\n                element = _unwrap_parse_error(element)\n            env.tracer.trace_answer(query.ref, answer)\n            if isinstance(element, dp.ParseError):\n                log(env, \"parse_error\", {\"error\": element}, loc=query)\n            elements.append(element)\n        for element in elements:\n            if not isinstance(element, dp.ParseError):\n                yield dp.Solution(element)\n        # In iterative mode, we want to keep the conversation going\n        if iterative_mode:\n            assert len(elements) == 1 and len(answers) == 1\n            element = elements[0]\n            if isinstance(element, dp.ParseError):\n                try:\n                    repair = query.query.generate_prompt(\n                        kind=REPAIR_PROMPT,\n                        mode=mode,\n                        params={\"params\": params, \"error\": element},\n                        env=mngr,\n                    )\n                except dp.TemplateFileMissing:\n                    repair = (\n                        \"Invalid answer. Please consider the following\"\n                        + f\" feedback and try again:\\n\\n{element}\"\n                    )\n                new_message = md.UserMessage(repair)\n            else:\n                try:\n                    gen_new = query.query.generate_prompt(\n                        kind=REQUEST_OTHER_PROMPT,\n                        mode=mode,\n                        params={\"params\": params},\n                        env=mngr,\n                    )\n                except dp.TemplateFileMissing:\n                    gen_new = \"Good! Can you generate a different answer now?\"\n                new_message = md.UserMessage(gen_new)\n\n            prompt = (*prompt, md.AssistantMessage(answers[0]), new_message)\n</code></pre>"},{"location":"dev/test-mkdocs/#documenting-a-whole-module","title":"Documenting a whole module","text":""},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries","title":"queries","text":"<p>Standard queries and building blocks for prompting policies.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.REPAIR_PROMPT","title":"REPAIR_PROMPT  <code>module-attribute</code>","text":"<pre><code>REPAIR_PROMPT = 'repair'\n</code></pre> <p>Template name suffix for repair prompts. See <code>interactive</code> argument of <code>few_shot</code>.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.REQUEST_OTHER_PROMPT","title":"REQUEST_OTHER_PROMPT  <code>module-attribute</code>","text":"<pre><code>REQUEST_OTHER_PROMPT = 'more'\n</code></pre> <p>Template name suffix for a requesting different solution See <code>interactive</code> argument of <code>few_shot</code>.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.ASSISTANT_PRIMING_STR","title":"ASSISTANT_PRIMING_STR  <code>module-attribute</code>","text":"<pre><code>ASSISTANT_PRIMING_STR = '!&lt;assistant&gt;'\n</code></pre> <p>Single-line separator between the user and assistant messages in a prompt that uses assistant priming.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.DEFAULT_INSTANCE_PROMPT","title":"DEFAULT_INSTANCE_PROMPT  <code>module-attribute</code>","text":"<pre><code>DEFAULT_INSTANCE_PROMPT = '{{query | yaml | trim}}'\n</code></pre> <p>Default instance prompt template.</p> <p>See <code>DEFAULT_INSTANCE_PROMPT_WITH_PREFIX</code> for the special case where queries have a special <code>prefix</code> attribute.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.DEFAULT_INSTANCE_PROMPT_WITH_PREFIX","title":"DEFAULT_INSTANCE_PROMPT_WITH_PREFIX  <code>module-attribute</code>","text":"<pre><code>DEFAULT_INSTANCE_PROMPT_WITH_PREFIX = \"{{query | yaml(exclude_fields=['prefix']) | trim}}\"\n</code></pre> <p>Default instance prompt template in the presence of a special <code>prefix</code> attribute.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.DEFAULT_FEEDBACK_PROMPT","title":"DEFAULT_FEEDBACK_PROMPT  <code>module-attribute</code>","text":"<pre><code>DEFAULT_FEEDBACK_PROMPT = lstrip()\n</code></pre> <p>Default template for feedback prompts.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.ParserSpec","title":"ParserSpec","text":"<pre><code>ParserSpec: _StandardParserName | GenericTextParser | TextParser[Any]\n</code></pre> <p>A parser specification, which can be either:</p> <ul> <li>\"structured\": Oracles must answer with structured output, and the       resulting JSON object is parsed using Pydantic.</li> <li>\"final_tool_call\": The query answer type is presented to oracles       as a tool, which must be called to produce the final answer. This       provides an alternative to \"structured\", which additionally allows       a chain of thoughts to precede the final answer.</li> <li>A generic text parser: See <code>GenericTextParser</code>. Oracles are then       expected to produce a string answer, which is parsed using the       provided function.</li> <li>A text parser: See <code>TextParser</code>. Oracles are then       expected to produce a string answer, which is parsed using the       provided function.</li> </ul>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.ParserSpecDict","title":"ParserSpecDict","text":"<pre><code>ParserSpecDict: Mapping[AnswerMode, ParserSpec]\n</code></pre> <p>A dictionary mapping answer modes to parser specifications.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.QueryConfigDict","title":"QueryConfigDict","text":"<pre><code>QueryConfigDict: Mapping[AnswerMode, QueryConfig]\n</code></pre> <p>A dictionary mapping answer modes to query configurations.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.ExampleSelector","title":"ExampleSelector","text":"<pre><code>ExampleSelector: Callable[[Sequence[Example]], Sequence[Example]]\n</code></pre> <p>A function for selecting a subset of examples from a given sequence.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.FinalAnswer","title":"FinalAnswer  <code>dataclass</code>","text":"<p>See <code>Response</code>.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.ToolRequests","title":"ToolRequests  <code>dataclass</code>","text":"<p>See <code>Response</code>.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Response","title":"Response  <code>dataclass</code>","text":"<p>Answer type for queries that allow follow-ups.</p> <p><code>Response</code> values give access to both the raw LLM response (to be passed pass in <code>AnswerPrefix</code>) and to eventual tool calls.</p> <p>Attributes:</p> Name Type Description <code>answer</code> <code>Answer</code> <p>The raw, unparsed LLM answer.</p> <code>parsed</code> <code>FinalAnswer[Response[F]] | ToolRequests[Response[T]]</code> <p>Either the parsed answer wrapped in <code>FinalAnswer</code> or some tool call requests wrapped in <code>ToolRequests</code>.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.WrappedParseError","title":"WrappedParseError  <code>dataclass</code>","text":"<p>A wrapped parse error that is returned to a strategy instead of causing a failure.</p> <p>For queries that declare a return type of the form <code>Response[... | WrappedParseError, ...]</code>, parse errors do not result in failures but are instead wrapped and returned, to be handled explicitly by the surrounding strategy. For example, when building conversational agents with [<code>interact</code>][delphyne.interact], having the query include <code>WrappedParseError</code> in its return type allows explicitly asking the agent to fix parse errors instead of failing (or having the policy retry an identical prompt).</p> <p>Attributes:</p> Name Type Description <code>error</code> <code>ParseError</code> <p>The wrapped parse error.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.QueryConfig","title":"QueryConfig  <code>dataclass</code>","text":"<p>Mode-specific query settings.</p> <p>More settings could be added in the future.</p> <p>Attributes:</p> Name Type Description <code>parser</code> <code>ParserSpec</code> <p>A parser specification.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.GenericTextParser","title":"GenericTextParser","text":"<p>               Bases: <code>Protocol</code></p> <p>A function that takes a type annotation along with a string as arguments and either returns a parsed object of the specified type or raises <code>ParseError</code>.</p> <p>Example: <code>yaml_from_last_block</code>.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.TextParser","title":"TextParser","text":"<p>               Bases: <code>Protocol</code></p> <p>A function that takes a string as an argument and either returns a parsed object or raises <code>ParseError</code>.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query","title":"Query","text":"<p>               Bases: <code>AbstractQuery[Query[T]]</code></p> <p>Base class for queries.</p> <p>This class adds standard convenience features on top of <code>AbstractQuery</code>, using reflection to allow queries to be defined concisely. Here is a simple example of a query type definition:</p> <pre><code>@dataclass class MakeSum(Query[list[int]]):\n    ''' Given a list of allowed numbers and a target number, you\n    must find a sub-list whose elements sum up to the target.\n    Just answer with a list of numbers as a JSON object and\n    nothing else. '''\n\n    allowed: list[int] target: int\n</code></pre> <p>In general, a query type is a dataclass that inherits <code>Query[T]</code>, where <code>T</code> is the query's answer type. In the example above, no parser is specified and so oracles are requested to provide structured answers as JSON objects, which are automatically parsed into the answer type (<code>list[int]</code>) using pydantic. Assuming that no Jinja prompt file is provided, the docstring is used as a system prompt and instance prompts are generated by simply serializing <code>MakeSum</code> instances into YAML.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query--customizing-prompts","title":"Customizing Prompts","text":"<p>System and instance prompts can be specified via Jinja templates. The templates manager (<code>TemplatesManager</code>) looks for templates named \"..jinja\". Templates can also be provided by defining the <code>__system_prompt__</code> and/or <code>__instance_prompt__</code> class attributes. If none of these are provided, the query's docstring is used as a system prompt and <code>DEFAULT_INSTANCE_PROMPT</code> is used as an instance prompt template. <p>The following arguments are usually made available to templates (although specific prompting policies can add more):</p> <ul> <li><code>query</code>: the query instance.</li> <li><code>mode</code>: the requested answer mode.</li> <li><code>params</code>: the query hyperparameters (e.g., as passed to <code>few_shot</code>)</li> </ul>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query--answer-modes-and-configurations","title":"Answer Modes and Configurations","text":"<p>A query can define several answer modes (<code>AnswerMode</code>), each of which can be associated with a different parser and set of settings. By default, the only answer mode is <code>None</code>. More answer modes can be defined by setting class variable <code>__modes__</code>.</p> <p>The <code>query_config</code> method maps modes to configurations (i.e., a set of settings, including a parser specification). Its default behavior works by inspecting the <code>__parser__</code> and <code>__config__</code> class attributes and does not typically require overriding.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query--allowing-multi-message-exchanges-and-tool-calls","title":"Allowing Multi-Message Exchanges and Tool Calls","text":"<p>A common pattern for interacting with LLMs is to have multi-message exchanges where the full conversation history is resent repeatedly. LLMs are also often allowed to request tool call. This interaction pattern is implemented in the [<code>interact</code>][delphyne.interact] standard strategy. It is enabled by several features on the <code>Query</code> side.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query--answer-prefixes","title":"Answer Prefixes","text":"<p>If a query type has a prefix attribute with type <code>AnswerPrefix</code>, this attribute can be used to provide a chat history, to be added to the query's prompt.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query--the-response-type","title":"The <code>Response</code> Type","text":"<p>If the query answer type is <code>Response</code>, the query does not only return a parsed answer, but also the LLM raw answer (which can be appended to a chat history), and possibly a sequence of tool calls.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query--manually-overriding-the-parse-method","title":"Manually Overriding the <code>parse</code> Method","text":"<p>For advanced use cases, it is possible to directly override the <code>parse</code> method that turns an answer into an object of type <code>T</code>. When this is done, the <code>__config__</code> and <code>__parser__</code> class attributes must not be set. Also, the <code>query_settings</code> method always returns the default settings instead of relying on <code>query_config</code> and must be overriden if another behavior is desired.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query.query_config","title":"query_config","text":"<pre><code>query_config(mode: AnswerMode) -&gt; QueryConfig | None\n</code></pre> <p>Map modes to configurations.</p> <p>This method inspects the <code>__config__</code> and <code>__parser__</code> class attributes (none or either can be set but not both).</p> <ul> <li>If no attribute is set, the default configuration is used for       all modes, which uses the <code>\"structured\"</code> parser.</li> <li>If <code>__config__</code> is set to a <code>QueryConfig</code>, this configuration       is used for all modes.</li> <li>Alternatively, <code>__config__</code> can be set to a dictionary mapping       modes to configurations.</li> <li>If <code>__parser__</code> is set to a parser specification, the default       configuration is used for all modes, except that the       provided parser is used instead of the default one.</li> <li>Alternatively, <code>__parser__</code> can also be set to a dictionary.</li> </ul> <p>In the special case where the <code>parse</code> method is overriden and only in this case, return <code>None</code> after ensuring that <code>__config__</code> and <code>__parser__</code> are not set.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query.parse","title":"parse","text":"<pre><code>parse(answer: Answer) -&gt; Query[T]\n</code></pre> <p>A more convenient method to override instead of <code>parse_answer</code>.</p> <p>Raises <code>ParseError</code>.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query.query_settings","title":"query_settings","text":"<pre><code>query_settings(mode: AnswerMode) -&gt; QuerySettings\n</code></pre> <p>Return the settings associated with the query.</p> <p>By default, this method uses the result of <code>query_config</code> to determine settings if <code>parse</code> is not overriden, and the default set of settings otherwise.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query.query_prefix","title":"query_prefix","text":"<pre><code>query_prefix() -&gt; AnswerPrefix | None\n</code></pre> <p>Return the value of the <code>prefix</code> attribute if it has type annotation <code>AnswerPrefix</code> or return <code>None</code>.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query.globals","title":"globals","text":"<pre><code>globals() -&gt; dict[str, object] | None\n</code></pre> <p>Return global objects accessible in prompts via the <code>globals</code> attribute.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query.using","title":"using","text":"<pre><code>using(get_policy: EllipsisType) -&gt; Opaque[IPDict, Query[T]]\n</code></pre><pre><code>using(get_policy: Callable[[using[P]], PromptingPolicy] | EllipsisType, /, inner_policy_type: type[using[P]] | None = None) -&gt; Opaque[using[P], Query[T]]\n</code></pre> <pre><code>using(get_policy: Callable[[using[P]], PromptingPolicy] | EllipsisType, /, inner_policy_type: type[using[P]] | None = None) -&gt; Opaque[using[P], Query[T]]\n</code></pre> <p>Turn a query into an opaque space by providing a mapping from the ambient inner policy to a prompting policy.</p> <p>Attributes:</p> Name Type Description <code>get_policy</code> <p>A function that maps the ambient inner policy to a prompting policy to use for answering the query. Alternatively, if the ellipsis value <code>...</code> is passed, the inner policy type is assumed to be <code>IPDict</code>, and prompting policies are automatically selected using tags (see <code>IPDict</code> documentation).</p> <code>inner_policy_type</code> <p>Ambient inner policy type. This information is not used at runtime but it can be provided to help type inference when necessary.</p> <p>The optional <code>inner_policy_type</code> argument is ignored at runtime and can be used to help type checkers infer the type of the ambient inner policy.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.Query.run_toplevel","title":"run_toplevel","text":"<pre><code>run_toplevel(env: PolicyEnv, policy: PromptingPolicy) -&gt; Stream[Query[T]]\n</code></pre> <p>Obtain a search stream of query answers, given a prompting policy.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.ProbInfo","title":"ProbInfo  <code>dataclass</code>","text":"<p>               Bases: <code>SearchMeta</code></p> <p>Distribution probability, guaranteed to be nonempty and to sum to 1.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.raw_yaml","title":"raw_yaml","text":"<pre><code>raw_yaml(type: TypeAnnot[raw_yaml[T]], res: str) -&gt; raw_yaml[T]\n</code></pre> <p>Parse a text answer that consists in a single YAML object and nothing else.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.yaml_from_last_block","title":"yaml_from_last_block","text":"<pre><code>yaml_from_last_block(type: TypeAnnot[yaml_from_last_block[T]], res: str) -&gt; yaml_from_last_block[T]\n</code></pre> <p>Parse the YAML object defined in the last code block of a text answer (between triple back quotes). In particular, this parser allows chain of thoughts.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.raw_string","title":"raw_string","text":"<pre><code>raw_string(type_annot: TypeAnnot[raw_string[T]], res: str) -&gt; raw_string[T]\n</code></pre> <p>Do not perform any parsing and return the answer as a raw string.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.trimmed_raw_string","title":"trimmed_raw_string","text":"<pre><code>trimmed_raw_string(type: TypeAnnot[trimmed_raw_string[T]], res: str) -&gt; trimmed_raw_string[T]\n</code></pre> <p>Do not perform any parsing and return the answer as a raw string, after trimming leading and trailing whitespace.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.first_word","title":"first_word","text":"<pre><code>first_word(type: TypeAnnot[first_word[T]], res: str) -&gt; first_word[T]\n</code></pre> <p>Parse the first word of the answer and turn it into an object of type T=Literal[s1,...,sn].</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.string_from_last_block","title":"string_from_last_block","text":"<pre><code>string_from_last_block(type: TypeAnnot[string_from_last_block[T]], res: str) -&gt; string_from_last_block[T]\n</code></pre> <p>Extract the string content of the last code block from the answer (surrounded by triple back quotes).</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.trimmed_string_from_last_block","title":"trimmed_string_from_last_block","text":"<pre><code>trimmed_string_from_last_block(type: TypeAnnot[trimmed_string_from_last_block[T]], res: str) -&gt; trimmed_string_from_last_block[T]\n</code></pre> <p>Extract the string content of the last code block from the answer (surrounded by triple back quotes) and trim leading and trailing whitespace.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.select_all_examples","title":"select_all_examples","text":"<pre><code>select_all_examples(examples: Sequence[Example]) -&gt; Sequence[Example]\n</code></pre> <p>Example selector that returns all available examples.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.select_random_examples","title":"select_random_examples","text":"<pre><code>select_random_examples(num_examples: int) -&gt; ExampleSelector\n</code></pre> <p>Example selector that randomly selects a given number of examples.</p> <p>All examples are selected if less examples are available than requested.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.select_with_either_tags","title":"select_with_either_tags","text":"<pre><code>select_with_either_tags(tags: Sequence[str])\n</code></pre> <p>Select examples that are annotated with at least one of a provided set of tags.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.classify","title":"classify","text":"<pre><code>classify(query: AttachedQuery[classify[T]], env: PolicyEnv, model: LLM, params: dict[str, object] | None = None, select_examples: Sequence[ExampleSelector] = (), mode: AnswerMode = None, enable_logging: bool = True, top_logprobs: int = 20, temperature: float = 1.0, bias: tuple[str, float] | None = None) -&gt; StreamGen[classify[T]]\n</code></pre> <p>Execute a classification query, attaching a probability distribution to the attached answer.</p> <p>Attributes:</p> <pre><code>query: The query to answer.\nenv: The global policy environment.\nmodel: The LLM to use for answering the query.\nparams: Prompt hyperparameters.\nselect_examples: Example selector.\nmode: The answer mode to use for parsing the query answer.\nenable_logging: Whether to log raw oracle responses.\ntop_logprobs: The number of top logprobs to request from the\n    LLM, putting an upper bound on the support size of the\n    classifier's output distributions.\ntemperature: A temperature to apply to the classifier's output\n    distribution (a temperature of 0 means that only top\n    elements are assigned a nonzero probability).\nbias: When `bias=(e, p)` is provided, the final classifier\n    distribution `D` is transformed into `(1-p)*D + p*dirac(e)`\n</code></pre> <p>See <code>few_shot</code> for details on some of the arguments above.</p>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.few_shot","title":"few_shot","text":"<pre><code>few_shot(query: AttachedQuery[few_shot[T]], env: PolicyEnv, model: LLM, *, params: dict[str, object] | None = None, select_examples: Sequence[ExampleSelector] = (), mode: AnswerMode = None, enable_logging: bool = True, temperature: float | None = None, num_concurrent: int = 1, max_requests: int | None = None, no_wrap_parse_errors: bool = False, iterative_mode: bool = False) -&gt; StreamGen[few_shot[T]]\n</code></pre> <p>The standard few-shot prompting policy.</p> <p>A prompt is formed by concatenating a system prompt, a series of examples (each of which consists in an instance prompt followed by an answer), and a final answer prompt. Then, answers are repeatedly sampled and parsed, until a spending request is declined.</p> <p>Arguments:</p> <pre><code>query: The query to answer. env: The policy environment. model:\nThe LLM to use for answering the query. params: Prompt\nhyperparameters, which are passed to prompt\n    templates as a `params` dictionary.\nselect_examples: A series of filters for selecting examples, to\n    be applied in sequence. By default, no filter is used and so\n    all available examples are fetched.\nmode: The answer mode to use for parsing the query answer.\nenable_logging: Whether to log raw oracle responses.\ntemperature: The temperature parameter to use with the LLM, as a\n    number from 0 to 2.\nnum_concurrent: The number of completions to request for each\n    LLM call. Note that most LLM providers only bill input\n    tokens once, regardless of the number of completions.\nmax_requests: The maximum number of LLM requests to perform\n    before the resulting seach stream terminates, if any.\nno_wrap_parse_errors: If set to `True`, then parser results of\n    type [`WrappedParseError`][delphyne.WrappedParseError] are unwrapped and treated as normal\n    parse errors.\niterative_mode: If set to `False` (default), answers are\n    repeatedly and independently sampled. If set to `True`, a\n    single chat conversation occurs instead: Whenever a parse\n    error occurs, a message is issued by rendering the\n    `&lt;QueryName&gt;.repair.jinja` template, asking for a new\n    attempt to be made (the [`ParseError`][delphyne.ParseError] object is available as\n    an `error` template variable). After an answer is\n    successfully generated and parsed, a message is issued by\n    rendering the `&lt;QueryName&gt;.more.jinja` template, asking for\n    another different answer to be generated.\n\n    This special mode allows creating simple conversational\n    agents with very little effort, by only defining a single\n    query. However, it does not support tool calls, and the\n    demonstration language cannot be used to illustrate how\n    `repair` and `more` messages should be handled. For\n    implementing more advanced conversational agents, see\n    the standard [`interact`][delphyne.interact] strategy.\n</code></pre>"},{"location":"dev/test-mkdocs/#delphyne.stdlib.queries.answer_with","title":"answer_with","text":"<pre><code>answer_with(query: AttachedQuery[answer_with[T]], env: PolicyEnv, answers: Sequence[str], probs: Sequence[float] | None = None, mode: AnswerMode = None) -&gt; StreamGen[answer_with[T]]\n</code></pre> <p>A prompting policy that returns a hardcoded set of answers without looking at the query. If <code>probs</code> is not provided, then all elements are yielded in sequence. If it is, the top element is yielded once, with a <code>ProbInfo</code> annotation featuring the provided distribution.</p>"},{"location":"manual/demos/","title":"Demonstrations","text":"<p>This page is under construction. In the meantime, you can read about Delphyne's key concepts in the paper Oracular Programming: A Modular Foundation for Building LLM-Enabled Software.</p>"},{"location":"manual/extension/","title":"VSCode Extension","text":"<p>A Visual Studio Code extension is available for interactively writing demonstrations, navigating strategy trees, and running oracular programs.</p> <p> </p>"},{"location":"manual/extension/#setting-up-the-extension","title":"Setting up the extension","text":"<p>After installing the Delphyne extension and opening a workspace containing a Delphyne project (whose root features a <code>delphyne.yaml</code> file), you can start the Delphyne extension by clicking on the Delphyne icon on the VSCode activity bar. Doing so will spawn a Delphyne language server if one is not running already. You can confirm that the language server is running by looking at the <code>Delphyne</code> output channel (from the <code>Output</code> tab in the panel). See the Troubleshooting section if you encounter any problem.</p> <p>Locating the language server</p> <p>The Delphyne extension uses the Python distribution currently selected for the workspace by Pylance to launch the language server. If no such distribution is configured, you can set it via the <code>Python: Select Interpreter</code> command and then restart VSCode.</p> <p>Once this is done, you can open a demonstration file and start evaluating demonstrations.</p>"},{"location":"manual/extension/#recommended-editor-configuration","title":"Recommended Editor Configuration","text":"<p>For the best experience, we recommend also installing the following VSCode extensions:</p> <ul> <li>YAML Language Support</li> <li>Better Jinja</li> </ul> <p>In addition, for optimal readability of demonstration files, line wrapping should be activated for YAML files. We recommend doing the same for Jinja files. Finally, we recommend associating the <code>*.jinja</code> extension with the <code>jinja-md</code> file format. See below for the recommended JSON configuration, which you can copy to your VSCode settings.</p> .vscode/settings.json <pre><code>\"[yaml]\": {\n    \"editor.wrappingIndent\": \"indent\",\n    \"editor.wordWrap\": \"wordWrapColumn\",\n    \"editor.indentSize\": 2,\n    \"editor.wordWrapColumn\": 100,\n    \"editor.rulers\": [100],\n},\n// Wrap template files for readability.\n\"[jinja-md]\": {\n    \"editor.wrappingIndent\": \"indent\",\n    \"editor.wordWrap\": \"wordWrapColumn\",\n    \"editor.wordWrapColumn\": 80,\n    \"editor.indentSize\": 2,\n    \"editor.rulers\": [80],\n},\n// Indicate that the Jinja templates are written in Markdown\n\"files.associations\": {\n    \"*.jinja\": \"jinja-md\"\n}\n</code></pre>"},{"location":"manual/extension/#delphyne-workspace-file","title":"The Delphyne Workspace File","text":"<p>A Delphyne workspace must have a <code>delphyne.yaml</code> file as its roots:</p> <pre><code>strategy_dirs: [\".\"]\nmodules: [\"module_1\", \"module_2\"]\ndemo_files: [\"demo_1\", \"demo_2\"]\n</code></pre> <p>This files features the following information:</p> <ul> <li>A list of directories within which strategy files can be found, relative to the root of the workspace.</li> <li>A list of module (i.e. file names without extensions) containing those strategies, to be found within those directories. For hot reloading to work, a module should alwways be listed after its dependencies.</li> <li>A list of demonstration files, to be passed implicitly to all commands (e.g. when running an oracular program).</li> </ul>"},{"location":"manual/extension/#editing-demonstrations","title":"Editing Demonstrations","text":"<p>Once activated, the Delphyne extension recognizes demonstration files via their extension <code>*.demo.yaml</code>. A proper YAML schema is automatically loaded and syntax errors are displayed within the editor. To quickly add a new demonstration, you can use the <code>demo</code> snippet (by typing <code>demo</code> and clicking on Tab). All available snippets are listed in <code>vscode-ui/snippets.json</code>.</p> <p>To evaluate a demonstration, put your cursor anywhere in its scope. A light bulb should then appear, suggesting that code actions are available. Use Cmd+. to see available code actions and select <code>Evaluate Demonstration</code>. Diagnostics should then appear, possibly after a moment of waiting (in which case a pending task should be displayed in Delphyne's <code>Tasks</code> view). If the demonstration was successfully evaluated, an <code>info</code> diagnostic should be shown for every test. Otherwise, warnings and errors can be displayed. These diagnostics will stay displayed until the demo file ir closed or the demonstration gets updated. Note that adding comments or modifying other demonstrations does not invalidate them.</p> <p>Each test in a demonstration, even a failing one, describes a path through the underlying search tree. In order to visualize the endpoint of this path, you can put your cursor on the test and select the <code>View Test Destination</code> code action. The resulting node and its context will then be displayed in Delphyne's <code>Tree</code>, <code>Node</code> and <code>Actions</code> view. In the typical case where the test is stuck on a query that is unanswered in the demonstration, one can then click on the <code>+</code> icon next to its description (within the <code>Node</code> view) to add it to the demonstration (if the query exists already, a <code>Jump To</code> icon will be shown instead). The standard workflow is then to add an answer to this query and evaluate the demonstration again.</p> <p>To evaluate all demonstrations within a file, you can use the <code>Delphyne: Evaluate All Demonstrations in File</code> command (use Cmd+Shift+P to open the command palette). To see the prompt associated to a query, put your cursor on this query and use the <code>See Prompt</code> code action. Doing so will create and run the appropriate command in a new tab.</p> <p>Automatic Reloading of Strategies</p> <p>The language server reloads all modules listed in <code>delphyne.yaml</code> for every query, using <code>importlib.reload</code>. This way, strategies can be updated interactively without effort. Note that modules are reloaded in the order in which they are listed. Thus, a module should always be listed after its dependencies.</p>"},{"location":"manual/extension/#commands","title":"Running Commands","text":"<p>Many interactions with Delphyne can be performed by executing commands. A command can be invoked via a YAML file specifying its name and arguments, starting with header <code># delphyne-command</code>. A standard command is the <code>run_strategy</code> command that can be used to run an oracular program by specifying a strategy along with a policy (demonstrations are automatically extracted from the files listed in delphyne.yaml). To create a new tab with a template for invoking the <code>run_strategy</code> command, you can use <code>Delphyne: Run Strategy</code> from the VSCode command palette.</p> A Command Example <pre><code># delphyne-command\n\ncommand: run_strategy\nargs:\n  strategy: prove_program\n  args:\n    prog: |\n      use int.Int\n\n      let main () diverges =\n        let ref a = any int in\n        let ref b = a * a + 2 in\n        let ref x = 0 in\n        while b &lt; 50 do\n          x &lt;- x * (b - 1) + 1;\n          b &lt;- b + 1;\n        done;\n        assert { x &gt;= 0 }\n  policy: prove_program_policy\n  policy_args: {}\n  num_generated: 1\n  budget:\n    num_requests: 60\n</code></pre> <p>To execute a command, one can put the cursor over it and use the <code>Execute Command</code> code action. Doing so will launch a new task that can be viewed in the Delphyne <code>Task</code> view. When the task terminates (successfully or with an error), the command's result is appended at the end of the command file (and can be discarded using the <code>Clear Output</code> code action). When a command returns a trace, the latter can be inspected via the <code>Show Trace</code> code action.</p> <p>The progress of commands can be supervised while they are running through the <code>Tasks</code> view. This view lists all currently running commands and maps each one to a set of actions. For example, a command can be cancelled or its progress indicator shown on the status bar. In addition, the <code>Update Source</code> action (pen icon) allows dumping the command's current partial result to the command file. In the case of the <code>run_strategy</code> command, this allows inspecting the current trace at any point in time while search is still undergoing.</p> <p>Note</p> <p>In the future, Delphyne will allow adding new commands by registering command scripts. </p>"},{"location":"manual/extension/#navigating-trees","title":"Navigating Strategy Trees","text":"<p>Traces can be inspected using the <code>Tree</code>, <code>Node</code> and <code>Actions</code> views (see screenshot at the top of this page). These views are synchronized together and display information about a single node at a time. The <code>Tree</code> view indicates a path from the root to the current node and allows jumping to every intermediate node on this path. The <code>Node</code> view shows the node type and all associated spaces. For each space, it shows the underlying query or allows jumping to the underlying tree. Finally, the <code>Actions</code> view lists all children of the current node that belong to the trace. Actions leading to subtrees containing success nodes are indicated by small checkmarks.</p> <p>Navigation operations can be undone by clicking on the <code>Undo</code> icon on the header of the tree view or by using shortcut Cmd+D followed by Cmd+Z. </p>"},{"location":"manual/extension/#tips-and-shortcuts","title":"Tips and Shortcuts","text":"<ul> <li>Folding is very useful to keep demonstration readable. You should learn the standard VSCode shortcuts for controlling folding (Cmd+K+Cmd+L for toggling folding under the cursor, Cmd+K+Cmd+0 for folding everything, Cmd+K+Cmd+3 for folding everything at depth 3, Cmd+K+Cmd+J for unfolding everything...). In addition, the custom Delphyne shortcut Cmd+D+Cmd+K can be used to fold all strategy and query arguments outside of the cursor's scope.</li> <li>Shortcut Cmd+D+Cmd+V can be used to focus on Delphyne's views.</li> <li>The Github Copilot Code Actions can get in the way of using Delphyne and can be disabled with the <code>\"github.copilot.editor.enableCodeActions\": false</code> setting.</li> <li>When editing YAML files (and demonstration files in particular), VSCode allows semantically expanding and shrinking the selection with respect to the underlying syntax tree via Cmd+Ctrl+Shift+Left and Cmd+Ctrl+Shift+Right.</li> <li>To close a tab (and in particular a command tab), you can use shortcut Cmd+W, followed by Cmd+D to decline saving the tab's content if prompted.</li> </ul>"},{"location":"manual/extension/#troubleshooting","title":"Troubleshooting","text":""},{"location":"manual/extension/#accessing-log-information","title":"Accessing log information","text":"<p>The Delphyne extension outputs logging information in three different output channels:</p> <ul> <li><code>Delphyne</code>: main logging channel</li> <li><code>Delphyne Server</code>: the output of the language server is redirected here (only when the server was started by the extension)</li> <li><code>Delphyne Tasks</code>: displays the logging information produced by commands such as <code>run_strategy</code></li> </ul> <p>You should consult those channels if anything goes wrong. Also, to output more information, you can ask the extension to log more information by raising the log level to <code>Debug</code> or <code>Trace</code> via the <code>Developer: Set Log Level</code> command.</p>"},{"location":"manual/extension/#killing-a-server-instance-still-running-in-the-background","title":"Killing a server instance still running in the background","text":"<p>After VSCode quitted unexpectedly, the language server may still be running in background, which may cause problem when trying to restart the extension. On Unix systems, the language server can be killed by killing the program listening to port 8000:</p> <pre><code>sudo kill -9 $(sudo lsof -t -i :8000)\n</code></pre>"},{"location":"manual/extension/#debug-server","title":"Debugging the language server","text":"<p>To debug the language server or even specific strategies, it is useful to attach a debugger to the language server. To do so, you should open VSCode at the root of the Delphyne repository and use the <code>Debug Server</code> debugging profile. This will start the server in debug mode (on port 8000). Starting the Delphyne extension when a server instance is running already will cause the extension to use this instance (as confirmed by the log output in the <code>Delphyne</code> channel). You can then put arbitrary breakpoints in the server source code or even in strategy code.</p>"},{"location":"manual/policies/","title":"Policies","text":"<p>This page is under construction. In the meantime, you can read about Delphyne's key concepts in the paper Oracular Programming: A Modular Foundation for Building LLM-Enabled Software.</p>"},{"location":"manual/strategies/","title":"Strategies and Trees","text":"<p>This page is under construction. In the meantime, you can read about Delphyne's key concepts in the paper Oracular Programming: A Modular Foundation for Building LLM-Enabled Software.</p>"},{"location":"reference/cli/","title":"Delphyne Command Line Interface","text":""},{"location":"reference/cli/#delphyne.__main__.DelphyneCLI","title":"DelphyneCLI","text":"<p>The Delphyne Command Line Interface.</p> <p>The <code>delphyne</code> package features a <code>delphyne</code> command line application that is automatically generated from the <code>DelphyneCLI</code> class using fire. In particular, this application can be used to check demonstration files, execute command files, and launch the Delphyne language server.</p> Source code in <code>src/delphyne/__main__.py</code> <pre><code>class DelphyneCLI:\n    \"\"\"\n    The Delphyne Command Line Interface.\n\n    The `delphyne` package features a `delphyne` command line\n    application that is automatically generated from the `DelphyneCLI`\n    class using [fire](https://github.com/google/python-fire). In\n    particular, this application can be used to check demonstration\n    files, execute command files, and launch the Delphyne language\n    server.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        workspace_dir: Path | None = None,\n        ensure_no_error: bool = False,\n        ensure_no_warning: bool = False,\n    ):\n        \"\"\"\n        Arguments:\n            workspace_dir: the workspace directory. If not provided, it\n                is deduced for each demonstration or command file by\n                considering the closest transitive parent directory that\n                contains a `delphyne.yaml` file. If no such directory\n                exists, the current working directory is used.\n            ensure_no_error: Exit with a nonzero code if an error is\n                produced.\n            ensure_no_warning: Exit with a nonzero code if a warning is\n                produced.\n        \"\"\"\n        self.workspace_dir = workspace_dir\n        self.ensure_no_error = ensure_no_error\n        self.ensure_no_warning = ensure_no_warning\n\n    def _process_diagnostics(\n        self,\n        warnings: list[str],\n        errors: list[str],\n        use_stderr: bool = False,\n        show_summary: bool = True,\n    ):\n        show = partial(print, file=sys.stderr if use_stderr else sys.stdout)\n        num_errors = len(errors)\n        num_warnings = len(warnings)\n        if show_summary:\n            show(f\"{num_errors} error(s), {num_warnings} warning(s)\")\n        if errors or warnings:\n            show(\"\")\n        for e in errors:\n            show(f\"Error: {e}\")\n        for w in warnings:\n            show(f\"Warning: {w}\")\n        if self.ensure_no_error and num_errors &gt; 0:\n            exit(1)\n        if self.ensure_no_warning and num_warnings &gt; 0:\n            exit(1)\n\n    def _workspace_dir_for(self, file: Path) -&gt; Path:\n        \"\"\"\n        Get the workspace directory for a given file.\n        \"\"\"\n        workspace_dir = self.workspace_dir\n        if workspace_dir is None:\n            workspace_dir = find_workspace_dir(file)\n        if workspace_dir is None:\n            workspace_dir = Path.cwd()\n        return workspace_dir\n\n    def check(self, file: str):\n        \"\"\"\n        Check a demonstration file.\n        \"\"\"\n        file_path = Path(file)\n        workspace_dir = self._workspace_dir_for(file_path)\n        config = load_config(workspace_dir, local_config_from=file_path)\n        feedback = check_demo_file(\n            file_path, config.strategy_dirs, config.modules\n        )\n        self._process_diagnostics(feedback.warnings, feedback.errors)\n\n    def run(\n        self,\n        *,\n        file: str,\n        cache: bool = False,\n        update: bool = False,\n        no_output: bool = False,\n        no_header: bool = False,\n        no_status: bool = False,\n        filter: list[str] | None = None,\n        clear: bool = False,\n    ):\n        \"\"\"\n        Execute a command file.\n\n        Print an updated command file with an `outcome` section added on\n        stdout. Print other information on stderr.\n\n        Arguments:\n            file: Path to the command file to execute.\n            cache: Enable caching (assuming the command supports it).\n            update: Update the command file in place with the outcome.\n            no_output: Do not print on stdout.\n            no_header: Only print the `outcome` section on stdout.\n            no_status: Do not show the progress bar.\n            filter: Only show the provided subset of fields for the\n                `outcome.result` section.\n            clear: When this option is passed, all other options are\n                ignored and the `clear` method is called.\n        \"\"\"\n        file_path = Path(file)\n        workspace_dir = self._workspace_dir_for(file_path)\n        config = load_config(workspace_dir, local_config_from=file_path)\n        config = replace(\n            config,\n            status_refresh_period=STATUS_REFRESH_PERIOD_IN_SECONDS,\n            result_refresh_period=None,\n        )\n        if clear:\n            self.clear(file)\n            return\n        if update:\n            no_output = True\n            no_header = False\n        if cache and not config.cache_root:\n            config = replace(config, cache_root=file_path.parent / \"cache\")\n        with open(file, \"r\") as f:\n            spec = ty.pydantic_load(CommandSpec, yaml.safe_load(f))\n        cmd, args = spec.load(config.base)\n        if cache:\n            assert hasattr(args, \"cache_dir\"), (\n                \"Command does not have a `cache_dir` argument.\"\n            )\n            assert hasattr(args, \"cache_format\"), (\n                \"Command does not have a `cache_format` argument.\"\n            )\n            if not args.cache_dir:\n                args.cache_dir = file_path.stem\n            args.cache_format = \"db\"\n        progress = StatusIndicator(sys.stderr, show=not no_status)\n        res = std.run_command(cmd, args, config, on_status=progress.on_status)\n        progress.done()\n        res_type = std.command_optional_result_wrapper_type(cmd)\n        res_python: Any = ty.pydantic_dump(res_type, res)\n        if filter and res_python[\"result\"] is not None:\n            res_python[\"result\"] = {\n                k: v for k, v in res_python[\"result\"].items() if k in filter\n            }\n        if no_header:\n            output = pretty_yaml(res_python)\n        else:\n            with open(file_path, \"r\") as f:\n                header = command_file_header(f.read())\n            output = header.rstrip() + \"\\n\"\n            output += pretty_yaml({\"outcome\": res_python})\n        if not no_output:\n            print(output)\n        if update:\n            with open(file_path, \"w\") as f:\n                f.write(output)\n        errors = [d[1] for d in res.diagnostics if d[0] == \"error\"]\n        warnings = [d[1] for d in res.diagnostics if d[0] == \"warning\"]\n        self._process_diagnostics(\n            warnings,\n            errors,\n            use_stderr=True,\n            show_summary=self.ensure_no_error or self.ensure_no_warning,\n        )\n\n    def clear(self, file: str):\n        \"\"\"\n        Clear the outcome of a command file by updating it in place.\n        \"\"\"\n        path = Path(file)\n        with open(path, \"r\") as f:\n            content = f.read()\n        new_content = command_file_header(content)\n        with open(path, \"w\") as f:\n            f.write(new_content)\n\n    def serve(self):\n        \"\"\"\n        Launch an instance of the Delphyne language server.\n        \"\"\"\n        from delphyne.server.__main__ import main\n\n        main()\n</code></pre>"},{"location":"reference/cli/#delphyne.__main__.DelphyneCLI.check","title":"check","text":"<pre><code>check(file: str)\n</code></pre> <p>Check a demonstration file.</p> Source code in <code>src/delphyne/__main__.py</code> <pre><code>def check(self, file: str):\n    \"\"\"\n    Check a demonstration file.\n    \"\"\"\n    file_path = Path(file)\n    workspace_dir = self._workspace_dir_for(file_path)\n    config = load_config(workspace_dir, local_config_from=file_path)\n    feedback = check_demo_file(\n        file_path, config.strategy_dirs, config.modules\n    )\n    self._process_diagnostics(feedback.warnings, feedback.errors)\n</code></pre>"},{"location":"reference/cli/#delphyne.__main__.DelphyneCLI.run","title":"run","text":"<pre><code>run(*, file: str, cache: bool = False, update: bool = False, no_output: bool = False, no_header: bool = False, no_status: bool = False, filter: list[str] | None = None, clear: bool = False)\n</code></pre> <p>Execute a command file.</p> <p>Print an updated command file with an <code>outcome</code> section added on stdout. Print other information on stderr.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to the command file to execute.</p> required <code>cache</code> <code>bool</code> <p>Enable caching (assuming the command supports it).</p> <code>False</code> <code>update</code> <code>bool</code> <p>Update the command file in place with the outcome.</p> <code>False</code> <code>no_output</code> <code>bool</code> <p>Do not print on stdout.</p> <code>False</code> <code>no_header</code> <code>bool</code> <p>Only print the <code>outcome</code> section on stdout.</p> <code>False</code> <code>no_status</code> <code>bool</code> <p>Do not show the progress bar.</p> <code>False</code> <code>filter</code> <code>list[str] | None</code> <p>Only show the provided subset of fields for the <code>outcome.result</code> section.</p> <code>None</code> <code>clear</code> <code>bool</code> <p>When this option is passed, all other options are ignored and the <code>clear</code> method is called.</p> <code>False</code> Source code in <code>src/delphyne/__main__.py</code> <pre><code>def run(\n    self,\n    *,\n    file: str,\n    cache: bool = False,\n    update: bool = False,\n    no_output: bool = False,\n    no_header: bool = False,\n    no_status: bool = False,\n    filter: list[str] | None = None,\n    clear: bool = False,\n):\n    \"\"\"\n    Execute a command file.\n\n    Print an updated command file with an `outcome` section added on\n    stdout. Print other information on stderr.\n\n    Arguments:\n        file: Path to the command file to execute.\n        cache: Enable caching (assuming the command supports it).\n        update: Update the command file in place with the outcome.\n        no_output: Do not print on stdout.\n        no_header: Only print the `outcome` section on stdout.\n        no_status: Do not show the progress bar.\n        filter: Only show the provided subset of fields for the\n            `outcome.result` section.\n        clear: When this option is passed, all other options are\n            ignored and the `clear` method is called.\n    \"\"\"\n    file_path = Path(file)\n    workspace_dir = self._workspace_dir_for(file_path)\n    config = load_config(workspace_dir, local_config_from=file_path)\n    config = replace(\n        config,\n        status_refresh_period=STATUS_REFRESH_PERIOD_IN_SECONDS,\n        result_refresh_period=None,\n    )\n    if clear:\n        self.clear(file)\n        return\n    if update:\n        no_output = True\n        no_header = False\n    if cache and not config.cache_root:\n        config = replace(config, cache_root=file_path.parent / \"cache\")\n    with open(file, \"r\") as f:\n        spec = ty.pydantic_load(CommandSpec, yaml.safe_load(f))\n    cmd, args = spec.load(config.base)\n    if cache:\n        assert hasattr(args, \"cache_dir\"), (\n            \"Command does not have a `cache_dir` argument.\"\n        )\n        assert hasattr(args, \"cache_format\"), (\n            \"Command does not have a `cache_format` argument.\"\n        )\n        if not args.cache_dir:\n            args.cache_dir = file_path.stem\n        args.cache_format = \"db\"\n    progress = StatusIndicator(sys.stderr, show=not no_status)\n    res = std.run_command(cmd, args, config, on_status=progress.on_status)\n    progress.done()\n    res_type = std.command_optional_result_wrapper_type(cmd)\n    res_python: Any = ty.pydantic_dump(res_type, res)\n    if filter and res_python[\"result\"] is not None:\n        res_python[\"result\"] = {\n            k: v for k, v in res_python[\"result\"].items() if k in filter\n        }\n    if no_header:\n        output = pretty_yaml(res_python)\n    else:\n        with open(file_path, \"r\") as f:\n            header = command_file_header(f.read())\n        output = header.rstrip() + \"\\n\"\n        output += pretty_yaml({\"outcome\": res_python})\n    if not no_output:\n        print(output)\n    if update:\n        with open(file_path, \"w\") as f:\n            f.write(output)\n    errors = [d[1] for d in res.diagnostics if d[0] == \"error\"]\n    warnings = [d[1] for d in res.diagnostics if d[0] == \"warning\"]\n    self._process_diagnostics(\n        warnings,\n        errors,\n        use_stderr=True,\n        show_summary=self.ensure_no_error or self.ensure_no_warning,\n    )\n</code></pre>"},{"location":"reference/cli/#delphyne.__main__.DelphyneCLI.clear","title":"clear","text":"<pre><code>clear(file: str)\n</code></pre> <p>Clear the outcome of a command file by updating it in place.</p> Source code in <code>src/delphyne/__main__.py</code> <pre><code>def clear(self, file: str):\n    \"\"\"\n    Clear the outcome of a command file by updating it in place.\n    \"\"\"\n    path = Path(file)\n    with open(path, \"r\") as f:\n        content = f.read()\n    new_content = command_file_header(content)\n    with open(path, \"w\") as f:\n        f.write(new_content)\n</code></pre>"},{"location":"reference/cli/#delphyne.__main__.DelphyneCLI.serve","title":"serve","text":"<pre><code>serve()\n</code></pre> <p>Launch an instance of the Delphyne language server.</p> Source code in <code>src/delphyne/__main__.py</code> <pre><code>def serve(self):\n    \"\"\"\n    Launch an instance of the Delphyne language server.\n    \"\"\"\n    from delphyne.server.__main__ import main\n\n    main()\n</code></pre>"},{"location":"reference/demos/definitions/","title":"Definition of Demonstrations","text":""},{"location":"reference/demos/interpreter/","title":"Evaluating Demonstrations","text":""},{"location":"reference/policies/definitions/","title":"Policy Types","text":""},{"location":"reference/policies/definitions/#delphyne.AbstractPolicy","title":"AbstractPolicy","text":"<p>               Bases: <code>Generic[N_po, P_po]</code>, <code>ABC</code></p> <p>A pair of a search policy and of an inner policy.</p> <p>More preciely, a policy for trees with effects <code>N</code> (contravariant) gathers a search policy handling <code>N</code> along with an inner policy object of type <code>P</code> (covariant).</p> Source code in <code>src/delphyne/core/policies.py</code> <pre><code>class AbstractPolicy(Generic[N_po, P_po], ABC):\n    \"\"\"\n    A pair of a search policy and of an inner policy.\n\n    More preciely, a policy for trees with effects `N` (contravariant)\n    gathers a search policy handling `N` along with an inner policy\n    object of type `P` (covariant).\n    \"\"\"\n\n    @property\n    def search(self) -&gt; \"AbstractSearchPolicy[N_po]\": ...\n    @property\n    def inner(self) -&gt; P_po: ...\n</code></pre>"},{"location":"reference/policies/definitions/#delphyne.AbstractSearchPolicy","title":"AbstractSearchPolicy","text":"<p>               Bases: <code>Protocol</code></p> <p>A search policy takes as arguments a tree with a given signature (covariant type parameter <code>N</code>), a global policy environment, and an inner policy with appropriate type, and returns a search stream.</p> Source code in <code>src/delphyne/core/policies.py</code> <pre><code>class AbstractSearchPolicy[N: tr.Node](Protocol):\n    \"\"\"\n    A search policy takes as arguments a tree with a given signature\n    (covariant type parameter `N`), a global policy environment, and an\n    inner policy with appropriate type, and returns a search stream.\n    \"\"\"\n\n    def __call__[P, T](\n        self, tree: \"Tree[N, P, T]\", env: PolicyEnv, policy: P\n    ) -&gt; AbstractStream[T]: ...\n</code></pre>"},{"location":"reference/policies/definitions/#delphyne.AbstractPromptingPolicy","title":"AbstractPromptingPolicy","text":"<p>               Bases: <code>Protocol</code></p> <p>A prompting policy takes as arguments a query (attached to a specific node) and a global policy environment, and returns a search stream.</p> Source code in <code>src/delphyne/core/policies.py</code> <pre><code>class AbstractPromptingPolicy(Protocol):\n    \"\"\"\n    A prompting policy takes as arguments a query (attached to a\n    specific node) and a global policy environment, and returns a search\n    stream.\n    \"\"\"\n\n    def __call__[T](\n        self, query: AttachedQuery[T], env: PolicyEnv\n    ) -&gt; AbstractStream[T]: ...\n</code></pre>"},{"location":"reference/policies/envs/","title":"Global Policy Environments","text":""},{"location":"reference/policies/envs/#main-class","title":"Main Class","text":""},{"location":"reference/policies/envs/#delphyne.PolicyEnv","title":"PolicyEnv","text":"<p>The global environment accessible to policies.</p> <p>It can be used for:</p> <ul> <li>Fetching prompts, data, and examples.</li> <li>Caching LLM requests.</li> <li>Tracing nodes, query, answers, and logging information.</li> </ul> <p>Attributes:</p> Name Type Description <code>requests_cache</code> <code>object | None</code> <p>The requests cache, or <code>None</code> if caching is disabled. The exact type of the request cache is not statically determined and depends on the value of constructor argument <code>make_cache</code>.</p> <code>templates</code> <p>The prompt templates manager.</p> <code>tracer</code> <p>The tracer, which can also be used for logging.</p> <code>examples</code> <p>The example database.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>class PolicyEnv:\n    \"\"\"\n    The global environment accessible to policies.\n\n    It can be used for:\n\n    - Fetching prompts, data, and examples.\n    - Caching LLM requests.\n    - Tracing nodes, query, answers, and logging information.\n\n    Attributes:\n        requests_cache: The requests cache, or `None` if caching is\n            disabled. The exact type of the request cache is not\n            statically determined and depends on the value of\n            constructor argument `make_cache`.\n        templates: The prompt templates manager.\n        tracer: The tracer, which can also be used for logging.\n        examples: The example database.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        prompt_dirs: Sequence[Path],\n        demonstration_files: Sequence[Path],\n        data_dirs: Sequence[Path],\n        cache: CacheSpec | None = None,\n        make_cache: Callable[[CacheSpec], object] | None = None,\n        do_not_match_identical_queries: bool = False,\n    ):\n        \"\"\"\n        Args:\n            prompt_dirs: A sequence of directories where Jinja prompt\n                templates can be found.\n            demonstration_files: A sequence of paths to demonstration\n                files (with or without extension `.demo.yaml`), to\n                create an example database from.\n            data_dirs: A sequence of directories where data files can be\n                found.\n            cache: A cache specification, or `None` to disable caching.\n                When caching is enabled, the `requests_cache` attribute\n                can be accessed by policies to properly wrap LLM models.\n            make_cache: A function to create an actual cache object from\n                its specification.\n        \"\"\"\n        self.templates = TemplatesManager(prompt_dirs, data_dirs)\n        self.examples = ExampleDatabase(do_not_match_identical_queries)\n        self.tracer = Tracer()\n        self.requests_cache: object | None = None\n        if cache is not None:\n            assert make_cache is not None, (\n                \"Please specify the `make_cache` argument\"\n            )\n            self.requests_cache = make_cache(cache)\n        for path in demonstration_files:\n            if not path.suffix.endswith(DEMO_FILE_EXT):\n                path = path.with_suffix(DEMO_FILE_EXT)\n            try:\n                with path.open() as f:\n                    content = yaml.safe_load(f)\n                    demos = pydantic_load(list[Demo], content)\n                    for demo in demos:\n                        self.examples.add_demonstration(demo)\n            except Exception as e:\n                raise InvalidDemoFile(path, e)\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.InvalidDemoFile","title":"InvalidDemoFile  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a demonstration file could not be parsed.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>@dataclass\nclass InvalidDemoFile(Exception):\n    \"\"\"\n    Exception raised when a demonstration file could not be parsed.\n    \"\"\"\n\n    file: Path\n    exn: Exception\n</code></pre>"},{"location":"reference/policies/envs/#example-database","title":"Example Database","text":""},{"location":"reference/policies/envs/#delphyne.Example","title":"Example  <code>dataclass</code>","text":"<p>An example, usable for few-shot prompting.</p> <p>Attributes:</p> Name Type Description <code>args</code> <code>QuerySerializedArgs</code> <p>The serialized query arguments.</p> <code>answer</code> <code>Answer</code> <p>The answer to the query.</p> <code>tags</code> <code>Sequence[str]</code> <p>A sequence of tags associated with the example, which policies can use to select appropriate examples.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>@dataclass\nclass Example:\n    \"\"\"\n    An example, usable for few-shot prompting.\n\n    Attributes:\n        args: The serialized query arguments.\n        answer: The answer to the query.\n        tags: A sequence of tags associated with the example, which\n            policies can use to select appropriate examples.\n    \"\"\"\n\n    args: QuerySerializedArgs\n    answer: Answer\n    tags: Sequence[str]\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.core.environments.QuerySerializedArgs","title":"QuerySerializedArgs","text":"<pre><code>QuerySerializedArgs: dict[str, Any]\n</code></pre> <p>Serialized query arguments, as a dictionary mapping attributed to JSON values (assemblies of integers, strings, dictionnaries, list, tuples...).</p>"},{"location":"reference/policies/envs/#delphyne.ExampleDatabase","title":"ExampleDatabase  <code>dataclass</code>","text":"<p>A simple example database.</p> <p>Attributes:</p> Name Type Description <code>do_not_match_identical_queries</code> <code>bool</code> <p>If set to <code>True</code>, the <code>examples</code> method won't return examples that match identical queries (i.e., with the exact same arguments). This is useful in the context of writing demonstrations, where one may want to see how an LLM would answer a query, even when a ground-truth answer is provided already.</p> <p>TODO: add provenance info for better error messages.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>@dataclass\nclass ExampleDatabase:\n    \"\"\"\n    A simple example database.\n\n    Attributes:\n        do_not_match_identical_queries: If set to `True`, the `examples`\n            method won't return examples that match identical queries\n            (i.e., with the exact same arguments). This is useful in the\n            context of writing demonstrations, where one may want to see\n            how an LLM would answer a query, even when a ground-truth\n            answer is provided already.\n\n    TODO: add provenance info for better error messages.\n    \"\"\"\n\n    do_not_match_identical_queries: bool = False\n\n    # Maps each query name to a list of\n    _examples: dict[_QueryName, list[Example]] = field(\n        default_factory=lambda: defaultdict(list)\n    )\n\n    def add_query_demonstration(self, demo: QueryDemo):\n        \"\"\"\n        Add all examples from a standalone query demonstration to the\n        database.\n        \"\"\"\n        if not demo.answers:\n            return\n        if (ex := demo.answers[0].example) is not None and not ex:\n            # If the user explicitly asked not to include the example.\n            # TODO: What if the user asked to include several answers?\n            # Right now, we only allow the first one to be added.\n            return\n        demo_answer = demo.answers[0]\n        answer = translate_answer(demo_answer)\n        example = Example(demo.args, answer, demo_answer.tags)\n        self._examples[demo.query].append(example)\n\n    def add_demonstration(self, demo: Demo):\n        \"\"\"\n        Add all exmples from a demonstration to the database.\n        \"\"\"\n        if isinstance(demo, QueryDemo):\n            self.add_query_demonstration(demo)\n        else:\n            assert isinstance(demo, StrategyDemo)\n            for q in demo.queries:\n                self.add_query_demonstration(q)\n\n    def examples(\n        self, query_name: str, query_args: QuerySerializedArgs\n    ) -&gt; Iterable[Example]:\n        \"\"\"\n        Obtain all potential examples that can be used for few-shot\n        prompting with a given query.\n        \"\"\"\n        for ex in self._examples[query_name]:\n            if self.do_not_match_identical_queries:\n                if _equal_query_args(ex.args, query_args):\n                    continue\n            yield ex\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.ExampleDatabase.add_query_demonstration","title":"add_query_demonstration","text":"<pre><code>add_query_demonstration(demo: QueryDemo)\n</code></pre> <p>Add all examples from a standalone query demonstration to the database.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>def add_query_demonstration(self, demo: QueryDemo):\n    \"\"\"\n    Add all examples from a standalone query demonstration to the\n    database.\n    \"\"\"\n    if not demo.answers:\n        return\n    if (ex := demo.answers[0].example) is not None and not ex:\n        # If the user explicitly asked not to include the example.\n        # TODO: What if the user asked to include several answers?\n        # Right now, we only allow the first one to be added.\n        return\n    demo_answer = demo.answers[0]\n    answer = translate_answer(demo_answer)\n    example = Example(demo.args, answer, demo_answer.tags)\n    self._examples[demo.query].append(example)\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.ExampleDatabase.add_demonstration","title":"add_demonstration","text":"<pre><code>add_demonstration(demo: Demo)\n</code></pre> <p>Add all exmples from a demonstration to the database.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>def add_demonstration(self, demo: Demo):\n    \"\"\"\n    Add all exmples from a demonstration to the database.\n    \"\"\"\n    if isinstance(demo, QueryDemo):\n        self.add_query_demonstration(demo)\n    else:\n        assert isinstance(demo, StrategyDemo)\n        for q in demo.queries:\n            self.add_query_demonstration(q)\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.ExampleDatabase.examples","title":"examples","text":"<pre><code>examples(query_name: str, query_args: QuerySerializedArgs) -&gt; Iterable[Example]\n</code></pre> <p>Obtain all potential examples that can be used for few-shot prompting with a given query.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>def examples(\n    self, query_name: str, query_args: QuerySerializedArgs\n) -&gt; Iterable[Example]:\n    \"\"\"\n    Obtain all potential examples that can be used for few-shot\n    prompting with a given query.\n    \"\"\"\n    for ex in self._examples[query_name]:\n        if self.do_not_match_identical_queries:\n            if _equal_query_args(ex.args, query_args):\n                continue\n        yield ex\n</code></pre>"},{"location":"reference/policies/envs/#tracer","title":"Tracer","text":""},{"location":"reference/policies/envs/#delphyne.TemplatesManager","title":"TemplatesManager","text":"<p>A class for managing Jinja prompt templates.</p> <p>All templates automatically have access to the following global objects:</p> <ul> <li>A <code>yaml</code> filter for converting an object into a YAML string.</li> </ul> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>class TemplatesManager:\n    \"\"\"\n    A class for managing Jinja prompt templates.\n\n    All templates automatically have access to the following global\n    objects:\n\n    - A `yaml` filter for converting an object into a YAML string.\n    \"\"\"\n\n    def __init__(self, prompt_dirs: Sequence[Path], data_dirs: Sequence[Path]):\n        \"\"\"\n        Args:\n            prompt_dirs: A sequence of directories where Jinja prompt\n                templates can be found.\n            data_dirs: A sequence of directories where data files can be\n                found.\n        \"\"\"\n        self.prompt_folders = prompt_dirs\n        self.data = _load_data(data_dirs)\n        self.env = jinja2.Environment(\n            loader=jinja2.FileSystemLoader(self.prompt_folders),\n            trim_blocks=True,\n            lstrip_blocks=True,\n        )\n        self.env.filters[\"yaml\"] = dump_yaml_object  # type: ignore\n        self.env.globals[\"fail\"] = _fail_from_template  # type: ignore\n\n    def prompt(\n        self,\n        *,\n        query_name: str,\n        prompt_kind: Literal[\"system\", \"instance\"] | str,\n        template_args: dict[str, Any],\n        default_template: str | None = None,\n    ) -&gt; str:\n        \"\"\"\n        Render a prompt message using a template.\n\n        Args:\n            query_name: The name of the query for which the prompt is\n                built. Used to determine the template file name, namely\n                \"{query_name}.{prompt_kind}.jinja\".\n            kind: The kind of prompt (e.g. \"system\" or \"instance\") that\n                is being rendered, used to determine the name of the\n                template file to use.\n            template_args: A dictionary of arguments to pass to the\n                template. It must not contain key \"data\", which is\n                reserved for the data loaded from the data directories.\n            default_template: If provided, this template will be used if\n                no template file is found for the given query name and\n                kind instead of raising an error.\n\n        Raises:\n            TemplateFileMissing: template file not found.\n            TemplateError: error raised while rendering the template.\n        \"\"\"\n\n        suffix = \".\" + prompt_kind\n        template_name = f\"{query_name}{suffix}{JINJA_EXTENSION}\"\n        prompt_file_exists = any(\n            (d / template_name).exists() for d in self.prompt_folders\n        )\n        if not prompt_file_exists:\n            if default_template is not None:\n                template = self.env.from_string(default_template)\n            else:\n                raise TemplateFileMissing(template_name)\n        else:\n            template = self.env.get_template(template_name)\n        try:\n            assert \"data\" not in template_args\n            template_args |= {\"data\": self.data}\n            return template.render(template_args)\n        except jinja2.TemplateNotFound as e:\n            raise TemplateError(template_name, e)\n        except jinja2.UndefinedError as e:\n            raise TemplateError(template_name, e)\n        except jinja2.TemplateSyntaxError as e:\n            raise TemplateError(template_name, e)\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.TemplatesManager.prompt","title":"prompt","text":"<pre><code>prompt(*, query_name: str, prompt_kind: Literal['system', 'instance'] | str, template_args: dict[str, Any], default_template: str | None = None) -&gt; str\n</code></pre> <p>Render a prompt message using a template.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>The name of the query for which the prompt is built. Used to determine the template file name, namely \"{query_name}.{prompt_kind}.jinja\".</p> required <code>kind</code> <p>The kind of prompt (e.g. \"system\" or \"instance\") that is being rendered, used to determine the name of the template file to use.</p> required <code>template_args</code> <code>dict[str, Any]</code> <p>A dictionary of arguments to pass to the template. It must not contain key \"data\", which is reserved for the data loaded from the data directories.</p> required <code>default_template</code> <code>str | None</code> <p>If provided, this template will be used if no template file is found for the given query name and kind instead of raising an error.</p> <code>None</code> <p>Raises:</p> Type Description <code>TemplateFileMissing</code> <p>template file not found.</p> <code>TemplateError</code> <p>error raised while rendering the template.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>def prompt(\n    self,\n    *,\n    query_name: str,\n    prompt_kind: Literal[\"system\", \"instance\"] | str,\n    template_args: dict[str, Any],\n    default_template: str | None = None,\n) -&gt; str:\n    \"\"\"\n    Render a prompt message using a template.\n\n    Args:\n        query_name: The name of the query for which the prompt is\n            built. Used to determine the template file name, namely\n            \"{query_name}.{prompt_kind}.jinja\".\n        kind: The kind of prompt (e.g. \"system\" or \"instance\") that\n            is being rendered, used to determine the name of the\n            template file to use.\n        template_args: A dictionary of arguments to pass to the\n            template. It must not contain key \"data\", which is\n            reserved for the data loaded from the data directories.\n        default_template: If provided, this template will be used if\n            no template file is found for the given query name and\n            kind instead of raising an error.\n\n    Raises:\n        TemplateFileMissing: template file not found.\n        TemplateError: error raised while rendering the template.\n    \"\"\"\n\n    suffix = \".\" + prompt_kind\n    template_name = f\"{query_name}{suffix}{JINJA_EXTENSION}\"\n    prompt_file_exists = any(\n        (d / template_name).exists() for d in self.prompt_folders\n    )\n    if not prompt_file_exists:\n        if default_template is not None:\n            template = self.env.from_string(default_template)\n        else:\n            raise TemplateFileMissing(template_name)\n    else:\n        template = self.env.get_template(template_name)\n    try:\n        assert \"data\" not in template_args\n        template_args |= {\"data\": self.data}\n        return template.render(template_args)\n    except jinja2.TemplateNotFound as e:\n        raise TemplateError(template_name, e)\n    except jinja2.UndefinedError as e:\n        raise TemplateError(template_name, e)\n    except jinja2.TemplateSyntaxError as e:\n        raise TemplateError(template_name, e)\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.TemplateError","title":"TemplateError  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Wrapper for template-related exceptions.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>@dataclass\nclass TemplateError(Exception):\n    \"\"\"\n    Wrapper for template-related exceptions.\n    \"\"\"\n\n    name: str\n    exn: Exception\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.TemplateFileMissing","title":"TemplateFileMissing  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a template file is missing.</p> <p>We want to make a distinction with the <code>TemplateNotFound</code> Jinja exception, which can also be raised when <code>include</code> statements fail within templates. In comparison, this exception means that the main template file does not exist.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>@dataclass\nclass TemplateFileMissing(Exception):\n    \"\"\"\n    Exception raised when a template file is missing.\n\n    We want to make a distinction with the `TemplateNotFound` Jinja\n    exception, which can also be raised when `include` statements fail\n    within templates. In comparison, this exception means that the main\n    template file does not exist.\n    \"\"\"\n\n    file: str\n</code></pre>"},{"location":"reference/policies/envs/#template-manager","title":"Template Manager","text":""},{"location":"reference/policies/envs/#delphyne.Tracer","title":"Tracer","text":"<p>A mutable trace along with a mutable list of log messages.</p> <p>Both components are protected by a lock to ensure thread-safety (some policies spawn multiple concurrent threads).</p> <p>Attributes:</p> Name Type Description <code>trace</code> <p>A mutable trace.</p> <code>messages</code> <code>list[LogMessage]</code> <p>A mutable list of log messages.</p> <code>lock</code> <p>A reentrant lock protecting access to the trace and log. The lock is publicly exposed so that threads can log several successive messages without other threads interleaving new messages in between (TODO: there are cleaner ways to achieve this).</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>class Tracer:\n    \"\"\"\n    A mutable trace along with a mutable list of log messages.\n\n    Both components are protected by a lock to ensure thread-safety\n    (some policies spawn multiple concurrent threads).\n\n    Attributes:\n        trace: A mutable trace.\n        messages: A mutable list of log messages.\n        lock: A reentrant lock protecting access to the trace and log.\n            The lock is publicly exposed so that threads can log several\n            successive messages without other threads interleaving new\n            messages in between (TODO: there are cleaner ways to achieve\n            this).\n    \"\"\"\n\n    def __init__(self):\n        self.trace = traces.Trace()\n        self.messages: list[LogMessage] = []\n\n        # Different threads may be logging information or appending to\n        # the trace in parallel.\n        self.lock = threading.RLock()\n\n    def trace_node(self, node: refs.GlobalNodePath) -&gt; None:\n        \"\"\"\n        Ensure that a node at a given reference is present in the trace.\n\n        See `tracer_hook` for registering a hook that automatically\n        calls this method on all encountered nodes.\n        \"\"\"\n        with self.lock:\n            self.trace.convert_location(traces.Location(node, None))\n\n    def trace_query(self, ref: refs.GlobalSpacePath) -&gt; None:\n        \"\"\"\n        Ensure that a query at a given reference is present in the\n        trace, even if no answer is provided for it.\n        \"\"\"\n        with self.lock:\n            self.trace.convert_query_origin(ref)\n\n    def trace_answer(\n        self, space: refs.GlobalSpacePath, answer: refs.Answer\n    ) -&gt; None:\n        \"\"\"\n        Ensure that a given query answer is present in the trace, even\n        it is is not used to reach a node.\n        \"\"\"\n        with self.lock:\n            self.trace.convert_answer_ref((space, answer))\n\n    def log(\n        self,\n        message: str,\n        metadata: dict[str, Any] | None = None,\n        location: traces.Location | None = None,\n    ):\n        \"\"\"\n        Log a message, with optional metadata and location information.\n        The metadata must be a dictionary of JSON values.\n        \"\"\"\n        with self.lock:\n            short_location = None\n            if location is not None:\n                short_location = self.trace.convert_location(location)\n            self.messages.append(LogMessage(message, metadata, short_location))\n\n    def export_log(self) -&gt; Iterable[ExportableLogMessage]:\n        \"\"\"\n        Export the log into an easily serializable format.\n        \"\"\"\n        with self.lock:\n            for m in self.messages:\n                node = None\n                space = None\n                if (loc := m.location) is not None:\n                    node = loc.node.id\n                    if loc.space is not None:\n                        space = pprint.space_ref(loc.space)\n                yield ExportableLogMessage(m.message, node, space, m.metadata)\n\n    def export_trace(self) -&gt; traces.ExportableTrace:\n        \"\"\"\n        Export the trace into an easily serializable format.\n        \"\"\"\n        with self.lock:\n            return self.trace.export()\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.Tracer.trace_node","title":"trace_node","text":"<pre><code>trace_node(node: GlobalNodePath) -&gt; None\n</code></pre> <p>Ensure that a node at a given reference is present in the trace.</p> <p>See <code>tracer_hook</code> for registering a hook that automatically calls this method on all encountered nodes.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>def trace_node(self, node: refs.GlobalNodePath) -&gt; None:\n    \"\"\"\n    Ensure that a node at a given reference is present in the trace.\n\n    See `tracer_hook` for registering a hook that automatically\n    calls this method on all encountered nodes.\n    \"\"\"\n    with self.lock:\n        self.trace.convert_location(traces.Location(node, None))\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.Tracer.trace_query","title":"trace_query","text":"<pre><code>trace_query(ref: GlobalSpacePath) -&gt; None\n</code></pre> <p>Ensure that a query at a given reference is present in the trace, even if no answer is provided for it.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>def trace_query(self, ref: refs.GlobalSpacePath) -&gt; None:\n    \"\"\"\n    Ensure that a query at a given reference is present in the\n    trace, even if no answer is provided for it.\n    \"\"\"\n    with self.lock:\n        self.trace.convert_query_origin(ref)\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.Tracer.trace_answer","title":"trace_answer","text":"<pre><code>trace_answer(space: GlobalSpacePath, answer: Answer) -&gt; None\n</code></pre> <p>Ensure that a given query answer is present in the trace, even it is is not used to reach a node.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>def trace_answer(\n    self, space: refs.GlobalSpacePath, answer: refs.Answer\n) -&gt; None:\n    \"\"\"\n    Ensure that a given query answer is present in the trace, even\n    it is is not used to reach a node.\n    \"\"\"\n    with self.lock:\n        self.trace.convert_answer_ref((space, answer))\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.Tracer.log","title":"log","text":"<pre><code>log(message: str, metadata: dict[str, Any] | None = None, location: Location | None = None)\n</code></pre> <p>Log a message, with optional metadata and location information. The metadata must be a dictionary of JSON values.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>def log(\n    self,\n    message: str,\n    metadata: dict[str, Any] | None = None,\n    location: traces.Location | None = None,\n):\n    \"\"\"\n    Log a message, with optional metadata and location information.\n    The metadata must be a dictionary of JSON values.\n    \"\"\"\n    with self.lock:\n        short_location = None\n        if location is not None:\n            short_location = self.trace.convert_location(location)\n        self.messages.append(LogMessage(message, metadata, short_location))\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.Tracer.export_log","title":"export_log","text":"<pre><code>export_log() -&gt; Iterable[ExportableLogMessage]\n</code></pre> <p>Export the log into an easily serializable format.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>def export_log(self) -&gt; Iterable[ExportableLogMessage]:\n    \"\"\"\n    Export the log into an easily serializable format.\n    \"\"\"\n    with self.lock:\n        for m in self.messages:\n            node = None\n            space = None\n            if (loc := m.location) is not None:\n                node = loc.node.id\n                if loc.space is not None:\n                    space = pprint.space_ref(loc.space)\n            yield ExportableLogMessage(m.message, node, space, m.metadata)\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.Tracer.export_trace","title":"export_trace","text":"<pre><code>export_trace() -&gt; ExportableTrace\n</code></pre> <p>Export the trace into an easily serializable format.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>def export_trace(self) -&gt; traces.ExportableTrace:\n    \"\"\"\n    Export the trace into an easily serializable format.\n    \"\"\"\n    with self.lock:\n        return self.trace.export()\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.LogMessage","title":"LogMessage  <code>dataclass</code>","text":"<p>A log message.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>The message to log.</p> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Optional metadata associated with the message, as a dictionary mapping string keys to JSON values.</p> <code>location</code> <code>ShortLocation | None</code> <p>An optional location in the strategy tree where the message was logged, if applicable.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>@dataclass(frozen=True)\nclass LogMessage:\n    \"\"\"\n    A log message.\n\n    Attributes:\n        message: The message to log.\n        metadata: Optional metadata associated with the message, as a\n            dictionary mapping string keys to JSON values.\n        location: An optional location in the strategy tree where the\n            message was logged, if applicable.\n    \"\"\"\n\n    message: str\n    metadata: dict[str, Any] | None = None\n    location: traces.ShortLocation | None = None\n</code></pre>"},{"location":"reference/policies/envs/#delphyne.ExportableLogMessage","title":"ExportableLogMessage  <code>dataclass</code>","text":"<p>An exportable log message, as a dataclass whose fields are JSON values (as opposed to <code>LogMessage</code>) and is thus easier to export.</p> Source code in <code>src/delphyne/core/environments.py</code> <pre><code>@dataclass(frozen=True)\nclass ExportableLogMessage:\n    \"\"\"\n    An exportable log message, as a dataclass whose fields are JSON\n    values (as opposed to `LogMessage`) and is thus easier to export.\n    \"\"\"\n\n    message: str\n    node: int | None\n    space: str | None\n    metadata: dict[str, Any] | None = None\n</code></pre>"},{"location":"reference/policies/streams/","title":"Search Streams","text":""},{"location":"reference/stdlib/algorithms/","title":"Search Algorithms and Utilities","text":""},{"location":"reference/stdlib/basic/","title":"Basic Definitions","text":""},{"location":"reference/stdlib/commands/","title":"Commands","text":""},{"location":"reference/stdlib/effects/","title":"Standard Nodes and Effects","text":""},{"location":"reference/stdlib/experiments/","title":"Experiments","text":""},{"location":"reference/stdlib/queries/","title":"Queries and Prompting Policies","text":""},{"location":"reference/stdlib/streams/","title":"Stream Combinators","text":""},{"location":"reference/strategies/misc/","title":"Miscellaneous","text":""},{"location":"reference/strategies/misc/#delphyne.Error","title":"Error  <code>dataclass</code>","text":"<p>Base class for rich error messages that can be created within strategies, while providing a chance to generate meaningful feedback. Parser errors are a particular case (<code>ParseError</code>).</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str | None</code> <p>A concise label for the error.</p> <code>description</code> <code>str | None</code> <p>A more detailed description of the error.</p> <code>meta</code> <code>Any | None</code> <p>Additional metadata that can be used to provide more context about the error.</p> Source code in <code>src/delphyne/core/errors.py</code> <pre><code>@dataclass\nclass Error:\n    \"\"\"\n    Base class for rich error messages that can be created within\n    strategies, while providing a chance to generate meaningful\n    feedback. Parser errors are a particular case (`ParseError`).\n\n    Attributes:\n        label: A concise label for the error.\n        description: A more detailed description of the error.\n        meta: Additional metadata that can be used to provide more\n            context about the error.\n    \"\"\"\n\n    label: str | None = None\n    description: str | None = None\n    meta: Any | None = None\n\n    def __init__(\n        self,\n        *,\n        label: str | None = None,\n        description: str | None = None,\n        meta: Any | None = None,\n    ):\n        if label is not None:\n            assert label\n            # Should we prevent some characters in labels?\n            # assert not any(c in label for c in [\" \", \"\\n\", \"\\t\"])\n        # assert label or description\n        self.label = label\n        self.description = description\n        self.meta = meta\n\n    def __str__(self):\n        elts: list[str] = []\n        if self.label:\n            elts.append(self.label)\n        if self.description:\n            elts.append(self.description)\n        if self.meta:\n            elts.append(pprint.pformat(self.meta))\n        return \"\\n\\n\".join(elts)\n</code></pre>"},{"location":"reference/strategies/queries/","title":"Queries and Chats","text":""},{"location":"reference/strategies/queries/#abstract-queries","title":"Abstract Queries","text":""},{"location":"reference/strategies/queries/#delphyne.AbstractQuery","title":"AbstractQuery","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract Class for Delphyne Queries.</p> <p>The type parameter <code>T</code> indicates the type of parsed query answers.</p> <p>A more featureful subclass is provided in the standard library (<code>Query</code>), which uses reflection for convenience.</p> <p>Answer Modes</p> <p>Queries are allowed to define multiple answer modes (<code>AnswerMode</code>), each mode being possibly associated with different settings and with a different parser.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>class AbstractQuery[T](ABC):\n    \"\"\"\n    Abstract Class for Delphyne Queries.\n\n    The type parameter `T` indicates the type of parsed query answers.\n\n    A more featureful subclass is provided in the standard library\n    (`Query`), which uses reflection for convenience.\n\n    !!! info \"Answer Modes\"\n        Queries are allowed to define multiple answer modes\n        (`AnswerMode`), each mode being possibly associated with\n        different settings and with a different parser.\n    \"\"\"\n\n    @abstractmethod\n    def generate_prompt(\n        self,\n        *,\n        kind: Literal[\"system\", \"instance\", \"feedback\"] | str,\n        mode: AnswerMode,\n        params: dict[str, object],\n        extra_args: dict[str, object] | None = None,\n        env: TemplatesManager | None,\n    ) -&gt; str:\n        \"\"\"\n        Generate a prompt message for the query.\n\n        Args:\n            kind: Kind of prompt to generate. Standard prompt kinds are\n                \"system\", \"instance\", or \"feedback\" but others can be\n                supported (within or outside the standard library).\n            mode: Answer mode selected for the query.\n            params: Query hyperparameters.\n            extra_args: Additional arguments to pass to the template.\n            env: Template manager used to load Jinja templates.\n                Exceptions may be raised when it is needed but not\n                provided.\n        \"\"\"\n        pass\n\n    def serialize_args(self) -&gt; dict[str, object]:\n        \"\"\"\n        Serialize the query arguments as a dictionary of JSON values.\n        \"\"\"\n        return cast(dict[str, object], ty.pydantic_dump(type(self), self))\n\n    @classmethod\n    def parse_instance(cls, args: dict[str, object]) -&gt; Self:\n        \"\"\"\n        Parse a query instance from a dictionary of serialized\n        arguments.\n        \"\"\"\n        return ty.pydantic_load(cls, args)\n\n    @abstractmethod\n    def answer_type(self) -&gt; ty.TypeAnnot[T] | ty.NoTypeInfo:\n        \"\"\"\n        Return the answer type for the query, or `NoTypeInfo()` if this\n        information is not available.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def query_modes(self) -&gt; Sequence[AnswerMode]:\n        \"\"\"\n        Return the sequence of available answer modes.\n        \"\"\"\n        pass\n\n    def query_prefix(self) -&gt; AnswerPrefix | None:\n        \"\"\"\n        Return the chat history featured in the query, if any.\n\n        This is useful to emulate conversational agents by issuing a\n        query repeatedly, passing it the whole, updated conversation\n        history every time (see `interact`).\n        \"\"\"\n        return None\n\n    def query_settings(self, mode: AnswerMode) -&gt; QuerySettings:\n        \"\"\"\n        Return the settings associated with the query.\n        \"\"\"\n        return QuerySettings()\n\n    @final\n    def query_name(self) -&gt; str:\n        \"\"\"\n        Return the name of the query (i.e., the name of the associated\n        class).\n        \"\"\"\n        return self.__class__.__name__\n\n    def default_tags(self) -&gt; Sequence[str]:\n        \"\"\"\n        Return a default set of tags to associate with spaces induced by\n        the query.\n\n        These tags can be overriden (see `SpaceBuilder`).\n        \"\"\"\n        return [self.query_name()]\n\n    @abstractmethod\n    def parse_answer(self, answer: Answer) -&gt; T | ParseError:\n        \"\"\"\n        Parse a query answer.\n        \"\"\"\n        pass\n\n    def finite_answer_set(self) -&gt; Sequence[Answer] | None:\n        \"\"\"\n        For queries with a finite set of possible answers, return this\n        set. Otherwise, return `None`.\n\n        Demonstration tests can use a special `#&lt;val&gt;` hint to select\n        the first answer with content `&lt;val&gt;` from this set.\n\n        Example uses include classification queries (see `classify`)\n        where a distribution of answers is extracted from LLM logits,\n        flag queries...\n        \"\"\"\n        return None\n\n    def default_answer(self) -&gt; Answer | None:\n        \"\"\"\n        Return a default answer for the query, if any.\n\n        Default answers are used to answer queries in demonstration\n        tests when no answer is provided in the `queries` section and no\n        applicable hint is available.\n        \"\"\"\n        return None\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.generate_prompt","title":"generate_prompt  <code>abstractmethod</code>","text":"<pre><code>generate_prompt(*, kind: Literal['system', 'instance', 'feedback'] | str, mode: AnswerMode, params: dict[str, object], extra_args: dict[str, object] | None = None, env: TemplatesManager | None) -&gt; str\n</code></pre> <p>Generate a prompt message for the query.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Literal['system', 'instance', 'feedback'] | str</code> <p>Kind of prompt to generate. Standard prompt kinds are \"system\", \"instance\", or \"feedback\" but others can be supported (within or outside the standard library).</p> required <code>mode</code> <code>AnswerMode</code> <p>Answer mode selected for the query.</p> required <code>params</code> <code>dict[str, object]</code> <p>Query hyperparameters.</p> required <code>extra_args</code> <code>dict[str, object] | None</code> <p>Additional arguments to pass to the template.</p> <code>None</code> <code>env</code> <code>TemplatesManager | None</code> <p>Template manager used to load Jinja templates. Exceptions may be raised when it is needed but not provided.</p> required Source code in <code>src/delphyne/core/queries.py</code> <pre><code>@abstractmethod\ndef generate_prompt(\n    self,\n    *,\n    kind: Literal[\"system\", \"instance\", \"feedback\"] | str,\n    mode: AnswerMode,\n    params: dict[str, object],\n    extra_args: dict[str, object] | None = None,\n    env: TemplatesManager | None,\n) -&gt; str:\n    \"\"\"\n    Generate a prompt message for the query.\n\n    Args:\n        kind: Kind of prompt to generate. Standard prompt kinds are\n            \"system\", \"instance\", or \"feedback\" but others can be\n            supported (within or outside the standard library).\n        mode: Answer mode selected for the query.\n        params: Query hyperparameters.\n        extra_args: Additional arguments to pass to the template.\n        env: Template manager used to load Jinja templates.\n            Exceptions may be raised when it is needed but not\n            provided.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.serialize_args","title":"serialize_args","text":"<pre><code>serialize_args() -&gt; dict[str, object]\n</code></pre> <p>Serialize the query arguments as a dictionary of JSON values.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>def serialize_args(self) -&gt; dict[str, object]:\n    \"\"\"\n    Serialize the query arguments as a dictionary of JSON values.\n    \"\"\"\n    return cast(dict[str, object], ty.pydantic_dump(type(self), self))\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.parse_instance","title":"parse_instance  <code>classmethod</code>","text":"<pre><code>parse_instance(args: dict[str, object]) -&gt; Self\n</code></pre> <p>Parse a query instance from a dictionary of serialized arguments.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>@classmethod\ndef parse_instance(cls, args: dict[str, object]) -&gt; Self:\n    \"\"\"\n    Parse a query instance from a dictionary of serialized\n    arguments.\n    \"\"\"\n    return ty.pydantic_load(cls, args)\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.answer_type","title":"answer_type  <code>abstractmethod</code>","text":"<pre><code>answer_type() -&gt; TypeAnnot[AbstractQuery[T]] | NoTypeInfo\n</code></pre> <p>Return the answer type for the query, or <code>NoTypeInfo()</code> if this information is not available.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>@abstractmethod\ndef answer_type(self) -&gt; ty.TypeAnnot[T] | ty.NoTypeInfo:\n    \"\"\"\n    Return the answer type for the query, or `NoTypeInfo()` if this\n    information is not available.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.query_modes","title":"query_modes  <code>abstractmethod</code>","text":"<pre><code>query_modes() -&gt; Sequence[AnswerMode]\n</code></pre> <p>Return the sequence of available answer modes.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>@abstractmethod\ndef query_modes(self) -&gt; Sequence[AnswerMode]:\n    \"\"\"\n    Return the sequence of available answer modes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.query_prefix","title":"query_prefix","text":"<pre><code>query_prefix() -&gt; AnswerPrefix | None\n</code></pre> <p>Return the chat history featured in the query, if any.</p> <p>This is useful to emulate conversational agents by issuing a query repeatedly, passing it the whole, updated conversation history every time (see [<code>interact</code>][delphyne.interact]).</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>def query_prefix(self) -&gt; AnswerPrefix | None:\n    \"\"\"\n    Return the chat history featured in the query, if any.\n\n    This is useful to emulate conversational agents by issuing a\n    query repeatedly, passing it the whole, updated conversation\n    history every time (see `interact`).\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.query_settings","title":"query_settings","text":"<pre><code>query_settings(mode: AnswerMode) -&gt; QuerySettings\n</code></pre> <p>Return the settings associated with the query.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>def query_settings(self, mode: AnswerMode) -&gt; QuerySettings:\n    \"\"\"\n    Return the settings associated with the query.\n    \"\"\"\n    return QuerySettings()\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.query_name","title":"query_name","text":"<pre><code>query_name() -&gt; str\n</code></pre> <p>Return the name of the query (i.e., the name of the associated class).</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>@final\ndef query_name(self) -&gt; str:\n    \"\"\"\n    Return the name of the query (i.e., the name of the associated\n    class).\n    \"\"\"\n    return self.__class__.__name__\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.default_tags","title":"default_tags","text":"<pre><code>default_tags() -&gt; Sequence[str]\n</code></pre> <p>Return a default set of tags to associate with spaces induced by the query.</p> <p>These tags can be overriden (see <code>SpaceBuilder</code>).</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>def default_tags(self) -&gt; Sequence[str]:\n    \"\"\"\n    Return a default set of tags to associate with spaces induced by\n    the query.\n\n    These tags can be overriden (see `SpaceBuilder`).\n    \"\"\"\n    return [self.query_name()]\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.parse_answer","title":"parse_answer  <code>abstractmethod</code>","text":"<pre><code>parse_answer(answer: Answer) -&gt; AbstractQuery[T] | ParseError\n</code></pre> <p>Parse a query answer.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>@abstractmethod\ndef parse_answer(self, answer: Answer) -&gt; T | ParseError:\n    \"\"\"\n    Parse a query answer.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.finite_answer_set","title":"finite_answer_set","text":"<pre><code>finite_answer_set() -&gt; Sequence[Answer] | None\n</code></pre> <p>For queries with a finite set of possible answers, return this set. Otherwise, return <code>None</code>.</p> <p>Demonstration tests can use a special <code>#&lt;val&gt;</code> hint to select the first answer with content <code>&lt;val&gt;</code> from this set.</p> <p>Example uses include classification queries (see <code>classify</code>) where a distribution of answers is extracted from LLM logits, flag queries...</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>def finite_answer_set(self) -&gt; Sequence[Answer] | None:\n    \"\"\"\n    For queries with a finite set of possible answers, return this\n    set. Otherwise, return `None`.\n\n    Demonstration tests can use a special `#&lt;val&gt;` hint to select\n    the first answer with content `&lt;val&gt;` from this set.\n\n    Example uses include classification queries (see `classify`)\n    where a distribution of answers is extracted from LLM logits,\n    flag queries...\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.AbstractQuery.default_answer","title":"default_answer","text":"<pre><code>default_answer() -&gt; Answer | None\n</code></pre> <p>Return a default answer for the query, if any.</p> <p>Default answers are used to answer queries in demonstration tests when no answer is provided in the <code>queries</code> section and no applicable hint is available.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>def default_answer(self) -&gt; Answer | None:\n    \"\"\"\n    Return a default answer for the query, if any.\n\n    Default answers are used to answer queries in demonstration\n    tests when no answer is provided in the `queries` section and no\n    applicable hint is available.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.ParseError","title":"ParseError  <code>dataclass</code>","text":"<p>               Bases: <code>Error</code>, <code>Exception</code></p> <p>Parse Error.</p> <p>Can be used as an exception or a returned value.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>@dataclass\nclass ParseError(Error, Exception):\n    \"\"\"\n    Parse Error.\n\n    Can be used as an exception or a returned value.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        label: str | None = None,\n        description: str | None = None,\n        meta: Any | None = None,\n    ):\n        if label is None:\n            label = \"parse_error\"\n        super().__init__(label=label, description=description, meta=meta)\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.QuerySettings","title":"QuerySettings  <code>dataclass</code>","text":"<p>Settings associated with a query.</p> <p>These settings can accessed by prompting policies so as to make appropriate requests to LLMs.</p> <p>Attributes:</p> Name Type Description <code>structured_output</code> <code>StructuredOutputSettings | None</code> <p>Settings for structured output, or <code>None</code> if structured output is not enabled.</p> <code>tools</code> <code>ToolSettings | None</code> <p>Settings for tool calls, or <code>None</code> if no tools are available.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>@dataclass(frozen=True)\nclass QuerySettings:\n    \"\"\"\n    Settings associated with a query.\n\n    These settings can accessed by prompting policies so as to make\n    appropriate requests to LLMs.\n\n    Attributes:\n        structured_output: Settings for structured output, or `None` if\n            structured output is not enabled.\n        tools: Settings for tool calls, or `None` if no tools are\n            available.\n    \"\"\"\n\n    structured_output: StructuredOutputSettings | None = None\n    tools: ToolSettings | None = None\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.StructuredOutputSettings","title":"StructuredOutputSettings  <code>dataclass</code>","text":"<p>Settings for LLM structured output.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>TypeAnnot[Any] | NoTypeInfo</code> <p>Expected type for the output, from which a schema can be</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>@dataclass(frozen=True)\nclass StructuredOutputSettings:\n    \"\"\"\n    Settings for LLM structured output.\n\n    Attributes:\n        type: Expected type for the output, from which a schema can be\n        derived if provided.\n    \"\"\"\n\n    type: ty.TypeAnnot[Any] | ty.NoTypeInfo\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.ToolSettings","title":"ToolSettings  <code>dataclass</code>","text":"<p>Tool call settings.</p> <p>Attributes:</p> Name Type Description <code>tool_types</code> <code>Sequence[type[Any]]</code> <p>Nonempty sequence of available tools. All tools must be classes, although more constraints can be put by specific queries and prompting policies.</p> <code>force_tool_call</code> <code>bool</code> <p>If True, oracles are informed that a tool call must be made.</p> Source code in <code>src/delphyne/core/queries.py</code> <pre><code>@dataclass(frozen=True)\nclass ToolSettings:\n    \"\"\"\n    Tool call settings.\n\n    Attributes:\n        tool_types: Nonempty sequence of available tools. All tools must\n            be classes, although more constraints can be put by specific\n            queries and prompting policies.\n        force_tool_call: If True, oracles are informed that a tool call\n            **must** be made.\n    \"\"\"\n\n    tool_types: Sequence[type[Any]]\n    force_tool_call: bool\n</code></pre>"},{"location":"reference/strategies/queries/#chat-histories","title":"Chat Histories","text":""},{"location":"reference/strategies/queries/#delphyne.AnswerPrefix","title":"AnswerPrefix","text":"<pre><code>AnswerPrefix: Sequence[AnswerPrefixElement]\n</code></pre> <p>An LLM chat history, to be passed to a query as an answer prefix (see <code>Query.query_prefix</code>).</p>"},{"location":"reference/strategies/queries/#delphyne.AnswerPrefixElement","title":"AnswerPrefixElement","text":"<pre><code>AnswerPrefixElement: OracleMessage | FeedbackMessage | ToolResult\n</code></pre> <p>LLM chat history element.</p>"},{"location":"reference/strategies/queries/#delphyne.OracleMessage","title":"OracleMessage  <code>dataclass</code>","text":"<p>Messge containing an oracle answer.</p> Source code in <code>src/delphyne/core/chats.py</code> <pre><code>@dataclass(frozen=True)\nclass OracleMessage:\n    \"\"\"\n    Messge containing an oracle answer.\n    \"\"\"\n\n    kind: Literal[\"oracle\"]\n    answer: Answer\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.FeedbackMessage","title":"FeedbackMessage  <code>dataclass</code>","text":"<p>Message containing user feedback.</p> Source code in <code>src/delphyne/core/chats.py</code> <pre><code>@dataclass(frozen=True)\nclass FeedbackMessage:\n    \"\"\"\n    Message containing user feedback.\n    \"\"\"\n\n    kind: Literal[\"feedback\"]\n    label: str | None = None\n    description: str | None = None\n    meta: Any | None = None  # must be serializable\n</code></pre>"},{"location":"reference/strategies/queries/#delphyne.ToolResult","title":"ToolResult  <code>dataclass</code>","text":"<p>User message containing the result of a tool call previously initiated by an LLM.</p> Source code in <code>src/delphyne/core/chats.py</code> <pre><code>@dataclass(frozen=True)\nclass ToolResult:\n    \"\"\"\n    User message containing the result of a tool call previously\n    initiated by an LLM.\n    \"\"\"\n\n    kind: Literal[\"tool\"]\n    call: ToolCall\n    result: str | Structured\n</code></pre>"},{"location":"reference/strategies/strategies/","title":"Strategies and Reification","text":""},{"location":"reference/strategies/strategies/#strategies","title":"Strategies","text":""},{"location":"reference/strategies/strategies/#delphyne.Strategy","title":"Strategy","text":"<pre><code>Strategy: Generator[NodeBuilder[N, P], object, T]\n</code></pre> <p>Type of a strategy computation.</p> <p>A strategy computation is a generator (i.e., a coroutine) that yields node builders and receives corresponding actions, until it returns a success value.</p> <p>Type parameter <code>N</code> (covariant) corresponds to the strategy's type signature (typically a union of node types), <code>P</code> (contravariant) is its associated inner policy type and <code>T</code> (covariant) its return type.</p> <p>Info</p> <p>Node builders are yielded instead of nodes. Indeed, strategy computations cannot create nodes since they are unaware of references. The task of concretely building nodes and maintaining references is delegated to the <code>refine</code> function.</p>"},{"location":"reference/strategies/strategies/#delphyne.NodeBuilder","title":"NodeBuilder  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[N, P]</code></p> <p>Wrapper for a function that builds a node, given the ability of spawning trees and attached queries (<code>AbstractBuilderExecutor</code>).</p> <p>Strategies do not directly yield nodes since building a node requires knowing its reference along with the associated hooks.</p> <p>Phantom type <code>P</code> tracks the ambient inner policy type.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass NodeBuilder(Generic[N, P]):\n    \"\"\"\n    Wrapper for a function that builds a node, given the ability of\n    spawning trees and attached queries (`AbstractBuilderExecutor`).\n\n    Strategies do not directly yield nodes since building a node\n    requires knowing its reference along with the associated hooks.\n\n    Phantom type `P` tracks the ambient inner policy type.\n    \"\"\"\n\n    build_node: \"Callable[[AbstractBuilderExecutor], N]\"\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.StrategyComp","title":"StrategyComp  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[N, P, T]</code></p> <p>A strategy computation that can be reified into a search tree, obtained by instantiating a strategy function.</p> <p>Such objects are usually not created directly but using the [<code>@strategy</code> decorator][delphyne.stdlib.strategy] from the standard library. Metadata information can be provided, such as: a name for the strategy, a return type and a list of tags.</p> Note <p>The name of the <code>_comp</code> function is inspected by methods such as <code>strategy_name</code>. Its signature (i.e., the name of its arguments) is inspected by <code>strategy_arguments</code>. When provided, type annotations are inspected by methods such as <code>return_type</code> and <code>inner_policy_type</code>. Thus, passing an anonymous function as <code>_comp</code> is not recommended.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass StrategyComp(Generic[N, P, T]):\n    \"\"\"\n    A *strategy computation* that can be reified into a search tree,\n    obtained by instantiating a strategy function.\n\n    Such objects are usually not created directly but using the\n    [`@strategy` decorator][delphyne.stdlib.strategy] from the standard\n    library. Metadata information can be provided, such as: a name for\n    the strategy, a return type and a list of tags.\n\n    ??? note\n        The name of the `_comp` function is inspected by methods such as\n        `strategy_name`. Its signature (i.e., the name of its arguments)\n        is inspected by `strategy_arguments`. When provided, type\n        annotations are inspected by methods such as `return_type` and\n        `inner_policy_type`. Thus, passing an anonymous function as\n        `_comp` is not recommended.\n    \"\"\"\n\n    _comp: Callable[..., Strategy[N, P, T]]\n    _args: tuple[Any, ...]\n    _kwargs: dict[str, Any]\n    _name: str | None\n    _return_type: TypeAnnot[T] | NoTypeInfo\n    _tags: Sequence[Tag]\n\n    ##### External API\n\n    def inline(self) -&gt; Strategy[N, P, T]:\n        \"\"\"\n        Inline a strategy computation within another, by executing the\n        underlying coroutine.\n\n        Example:\n\n        ```python\n        # Invoking a sub-strategy by branching over an opaque space.\n        y = yield from branch(sub_strategy(foo, bar).using(...))\n        # Invoking a sub-strategy via inlining (the signature and inner\n        # policy types of the sub strategy must be identical).\n        y = yield from sub_strategy(foo, bar).inline()\n        ```\n        \"\"\"\n        return self.run_generator()\n\n    ##### For internal use in `core` and in the standard library\n\n    def run_generator(self) -&gt; Strategy[N, P, T]:\n        \"\"\"\n        Run the coroutine associated with the strategy computation. This\n        method is mostly used by [`reify`][delphyne.core.reify] and\n        should not be needed outside of Delphyne's internals.\n        \"\"\"\n        return self._comp(*self._args, **self._kwargs)\n\n    def default_tags(self) -&gt; Sequence[Tag]:\n        \"\"\"\n        Return all default tags associated with the strategy\n        computation. Derived space builders are initialized with these\n        tags, which can later be changed (`tag` field of\n        `SpaceBuilder`).\n        \"\"\"\n        return self._tags\n\n    ### Inspection methods\n\n    def strategy_name(self) -&gt; str | None:\n        \"\"\"\n        Return the name of the instantiated strategy function, using the\n        `name` attribute if provided or using `comp.__name__` otherwise.\n        \"\"\"\n        if self._name is not None:\n            return self._name\n        return inspect.function_name(self._comp)\n\n    def strategy_arguments(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Return the dictionary of arguments that was used to instantiate\n        the underlying strategy function (using inspection for naming\n        positional arguments).\n        \"\"\"\n        return inspect.function_args_dict(self._comp, self._args, self._kwargs)\n\n    def strategy_argument_types(\n        self,\n    ) -&gt; dict[str, TypeAnnot[Any] | NoTypeInfo]:\n        \"\"\"\n        Return a dictionary with the same keys as\n        [`strategy_arguments`](delphyne.core.StrategyComp.strategy_arguments)\n        that maps every strategy argument to its type annotation (or\n        `NoTypeInfo` if none is provided).\n        \"\"\"\n        hints = typing.get_type_hints(self._comp)\n        return {\n            a: hints.get(a, NoTypeInfo()) for a in self.strategy_arguments()\n        }\n\n    def return_type(self) -&gt; TypeAnnot[T] | NoTypeInfo:\n        \"\"\"\n        Return the return type of the strategy computation, using the\n        provided metadata or using inspection otherwise (in case a type\n        annotation of the form `Strategy[..., ..., T]` is provided).\n\n        This information is useful for serializing success values after\n        running the strategy computation (see [`run_strategy`\n        command][delphyne.stdlib.commands.run_strategy]) or for\n        providing superior printing of values in the Delphyne tree view.\n        \"\"\"\n        if not isinstance(self._return_type, NoTypeInfo):\n            return self._return_type\n        strategy_type = inspect.function_return_type(self._comp)\n        if isinstance(strategy_type, NoTypeInfo):\n            return NoTypeInfo()\n        return inspect.return_type_of_strategy_type(strategy_type)\n\n    def inner_policy_type(self) -&gt; TypeAnnot[T] | NoTypeInfo:\n        \"\"\"\n        Return the inner policy type of the strategy computation, using\n        inspection (when a type annotation of the form `Strategy[..., P,\n        ...]` is provided).\n\n        This information is not currently used but could be leveraged in\n        the future to dynamically check the compatibility of an\n        associated policy.\n        \"\"\"\n        strategy_type = inspect.function_return_type(self._comp)\n        if isinstance(strategy_type, NoTypeInfo):\n            return NoTypeInfo()\n        return inspect.inner_policy_type_of_strategy_type(strategy_type)\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.StrategyComp.inline","title":"inline","text":"<pre><code>inline() -&gt; Strategy[N, P, T]\n</code></pre> <p>Inline a strategy computation within another, by executing the underlying coroutine.</p> <p>Example:</p> <pre><code># Invoking a sub-strategy by branching over an opaque space.\ny = yield from branch(sub_strategy(foo, bar).using(...))\n# Invoking a sub-strategy via inlining (the signature and inner\n# policy types of the sub strategy must be identical).\ny = yield from sub_strategy(foo, bar).inline()\n</code></pre> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def inline(self) -&gt; Strategy[N, P, T]:\n    \"\"\"\n    Inline a strategy computation within another, by executing the\n    underlying coroutine.\n\n    Example:\n\n    ```python\n    # Invoking a sub-strategy by branching over an opaque space.\n    y = yield from branch(sub_strategy(foo, bar).using(...))\n    # Invoking a sub-strategy via inlining (the signature and inner\n    # policy types of the sub strategy must be identical).\n    y = yield from sub_strategy(foo, bar).inline()\n    ```\n    \"\"\"\n    return self.run_generator()\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.StrategyComp.run_generator","title":"run_generator","text":"<pre><code>run_generator() -&gt; Strategy[N, P, T]\n</code></pre> <p>Run the coroutine associated with the strategy computation. This method is mostly used by <code>reify</code> and should not be needed outside of Delphyne's internals.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def run_generator(self) -&gt; Strategy[N, P, T]:\n    \"\"\"\n    Run the coroutine associated with the strategy computation. This\n    method is mostly used by [`reify`][delphyne.core.reify] and\n    should not be needed outside of Delphyne's internals.\n    \"\"\"\n    return self._comp(*self._args, **self._kwargs)\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.StrategyComp.default_tags","title":"default_tags","text":"<pre><code>default_tags() -&gt; Sequence[Tag]\n</code></pre> <p>Return all default tags associated with the strategy computation. Derived space builders are initialized with these tags, which can later be changed (<code>tag</code> field of <code>SpaceBuilder</code>).</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def default_tags(self) -&gt; Sequence[Tag]:\n    \"\"\"\n    Return all default tags associated with the strategy\n    computation. Derived space builders are initialized with these\n    tags, which can later be changed (`tag` field of\n    `SpaceBuilder`).\n    \"\"\"\n    return self._tags\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.StrategyComp.strategy_name","title":"strategy_name","text":"<pre><code>strategy_name() -&gt; str | None\n</code></pre> <p>Return the name of the instantiated strategy function, using the <code>name</code> attribute if provided or using <code>comp.__name__</code> otherwise.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def strategy_name(self) -&gt; str | None:\n    \"\"\"\n    Return the name of the instantiated strategy function, using the\n    `name` attribute if provided or using `comp.__name__` otherwise.\n    \"\"\"\n    if self._name is not None:\n        return self._name\n    return inspect.function_name(self._comp)\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.StrategyComp.strategy_arguments","title":"strategy_arguments","text":"<pre><code>strategy_arguments() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary of arguments that was used to instantiate the underlying strategy function (using inspection for naming positional arguments).</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def strategy_arguments(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Return the dictionary of arguments that was used to instantiate\n    the underlying strategy function (using inspection for naming\n    positional arguments).\n    \"\"\"\n    return inspect.function_args_dict(self._comp, self._args, self._kwargs)\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.StrategyComp.strategy_argument_types","title":"strategy_argument_types","text":"<pre><code>strategy_argument_types() -&gt; dict[str, TypeAnnot[Any] | NoTypeInfo]\n</code></pre> <p>Return a dictionary with the same keys as <code>strategy_arguments</code> that maps every strategy argument to its type annotation (or <code>NoTypeInfo</code> if none is provided).</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def strategy_argument_types(\n    self,\n) -&gt; dict[str, TypeAnnot[Any] | NoTypeInfo]:\n    \"\"\"\n    Return a dictionary with the same keys as\n    [`strategy_arguments`](delphyne.core.StrategyComp.strategy_arguments)\n    that maps every strategy argument to its type annotation (or\n    `NoTypeInfo` if none is provided).\n    \"\"\"\n    hints = typing.get_type_hints(self._comp)\n    return {\n        a: hints.get(a, NoTypeInfo()) for a in self.strategy_arguments()\n    }\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.StrategyComp.return_type","title":"return_type","text":"<pre><code>return_type() -&gt; TypeAnnot[T] | NoTypeInfo\n</code></pre> <p>Return the return type of the strategy computation, using the provided metadata or using inspection otherwise (in case a type annotation of the form <code>Strategy[..., ..., T]</code> is provided).</p> <p>This information is useful for serializing success values after running the strategy computation (see [<code>run_strategy</code> command][delphyne.stdlib.commands.run_strategy]) or for providing superior printing of values in the Delphyne tree view.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def return_type(self) -&gt; TypeAnnot[T] | NoTypeInfo:\n    \"\"\"\n    Return the return type of the strategy computation, using the\n    provided metadata or using inspection otherwise (in case a type\n    annotation of the form `Strategy[..., ..., T]` is provided).\n\n    This information is useful for serializing success values after\n    running the strategy computation (see [`run_strategy`\n    command][delphyne.stdlib.commands.run_strategy]) or for\n    providing superior printing of values in the Delphyne tree view.\n    \"\"\"\n    if not isinstance(self._return_type, NoTypeInfo):\n        return self._return_type\n    strategy_type = inspect.function_return_type(self._comp)\n    if isinstance(strategy_type, NoTypeInfo):\n        return NoTypeInfo()\n    return inspect.return_type_of_strategy_type(strategy_type)\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.StrategyComp.inner_policy_type","title":"inner_policy_type","text":"<pre><code>inner_policy_type() -&gt; TypeAnnot[T] | NoTypeInfo\n</code></pre> <p>Return the inner policy type of the strategy computation, using inspection (when a type annotation of the form <code>Strategy[..., P, ...]</code> is provided).</p> <p>This information is not currently used but could be leveraged in the future to dynamically check the compatibility of an associated policy.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def inner_policy_type(self) -&gt; TypeAnnot[T] | NoTypeInfo:\n    \"\"\"\n    Return the inner policy type of the strategy computation, using\n    inspection (when a type annotation of the form `Strategy[..., P,\n    ...]` is provided).\n\n    This information is not currently used but could be leveraged in\n    the future to dynamically check the compatibility of an\n    associated policy.\n    \"\"\"\n    strategy_type = inspect.function_return_type(self._comp)\n    if isinstance(strategy_type, NoTypeInfo):\n        return NoTypeInfo()\n    return inspect.inner_policy_type_of_strategy_type(strategy_type)\n</code></pre>"},{"location":"reference/strategies/strategies/#reification","title":"Reification","text":""},{"location":"reference/strategies/strategies/#delphyne.reify","title":"reify","text":"<pre><code>reify(strategy: StrategyComp[reify[N], reify[P], reify[T]], monitor: TreeMonitor = TreeMonitor(), allow_noncopyable_actions: bool = False) -&gt; Tree[reify[N], reify[P], reify[T]]\n</code></pre> <p>Reify a strategy computation into a tree.</p> <p>The resulting tree raises <code>StrategyException</code> whenever the underlying strategy raises an uncaught exception.</p> <p>Internally, trees are implemented by having each node keep track of a sequence of actions leading to it. Calling <code>child</code> appends a new action to this path and replays the strategy computation from the start with the new, augmented path.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>StrategyComp[reify[N], reify[P], reify[T]]</code> <p>The strategy to reify.</p> required <code>monitor</code> <code>TreeMonitor</code> <p>An optional cache, along with node creation hooks.</p> <code>TreeMonitor()</code> <code>allow_noncopyable_actions</code> <code>bool</code> <p>Allow actions to be nonserializable objects (such as functions) that cannot be deepcopied. Allowing such actions opens the door to unsafe side effects corrupting the resulting tree, so it must be done with care. See discussion below on side effects.</p> <code>False</code> <p>On Side Effects in Strategies</p> <p>Strategy functions are allowed to have side effects (see <code>tests/example_strategies/imperative_strategy</code> for example). For this to be sound, actions are always deepcopied before being sent back to strategy coroutines. This requirement can be weakened by setting <code>allow_noncopyable_actions</code> to <code>True</code>. In this case, noncopyable actions must be immutable. For example, a pure function can be used as an action but a closure that captures a mutable piece of state cannot (in which case computing the child of a node could affect its siblings by mutating some actions in their paths).</p> <p>In addition, non-copyable strategy arguments must never be mutated. Copyable arguments such as lists of copyable values can be mutated, since <code>reify</code> automaticallt performs deepcopies. Noncopyable arguments such as functions are allowed (e.g., to enable implementing higher-order strategies) but they must be pure and not mutate any state.</p> <p>When <code>allow_noncopyable_actions</code> is set to <code>False</code>, a dynamic check is performed to ensure that actions are copyable: an action is considered copyable if it can be serialized into JSON by pydantic (this is necessary since calling <code>deepcopy</code> on a closure returns the same closure unchanged).</p> Source code in <code>src/delphyne/core/reification.py</code> <pre><code>def reify[N: Node, P, T](\n    strategy: StrategyComp[N, P, T],\n    monitor: TreeMonitor = TreeMonitor(),\n    allow_noncopyable_actions: bool = False,\n) -&gt; Tree[N, P, T]:\n    \"\"\"\n    Reify a strategy computation into a tree.\n\n    The resulting tree raises `StrategyException` whenever the\n    underlying strategy raises an uncaught exception.\n\n    Internally, trees are implemented by having each node keep track of\n    a sequence of actions leading to it. Calling `child` appends a new\n    action to this path and replays the strategy computation from the\n    start with the new, augmented path.\n\n    Arguments:\n        strategy: The strategy to reify.\n        monitor: An optional cache, along with node creation hooks.\n        allow_noncopyable_actions: Allow\n            actions to be nonserializable objects (such as functions)\n            that cannot be deepcopied. Allowing such actions opens the\n            door to unsafe side effects corrupting the resulting tree,\n            so it must be done with care. See discussion below on side\n            effects.\n\n    !!! note \"On Side Effects in Strategies\"\n        Strategy functions are allowed to have side effects (see\n        `tests/example_strategies/imperative_strategy` for example). For\n        this to be sound, actions are always deepcopied before being\n        sent back to strategy coroutines. This requirement can be\n        weakened by setting `allow_noncopyable_actions` to `True`. In\n        this case, noncopyable actions must be immutable. For example, a\n        pure function can be used as an action but a closure that\n        captures a mutable piece of state cannot (in which case\n        computing the child of a node could affect its siblings by\n        mutating some actions in their paths).\n\n        In addition, non-copyable strategy arguments must never be\n        mutated. Copyable arguments such as lists of copyable values can\n        be mutated, since `reify` automaticallt performs deepcopies.\n        Noncopyable arguments such as functions are allowed (e.g., to\n        enable implementing higher-order strategies) but they must be\n        pure and not mutate any state.\n\n        When `allow_noncopyable_actions` is set to `False`, a dynamic\n        check is performed to ensure that actions are copyable: an\n        action is considered copyable if it can be serialized into JSON\n        by pydantic (this is necessary since calling `deepcopy` on a\n        closure returns the same closure unchanged).\n    \"\"\"\n    return _reify(\n        strategy=strategy,\n        root_ref=None,\n        monitor=monitor,\n        allow_noncopyable_actions=allow_noncopyable_actions,\n    )\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.StrategyException","title":"StrategyException  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a strategy encounters an internal error (e.g. a failed assertion or an index-out-of-bounds error).</p> <p>Attributes:</p> Name Type Description <code>exn</code> <code>Exception</code> <p>The original exception that was raised.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass\nclass StrategyException(Exception):\n    \"\"\"\n    Raised when a strategy encounters an internal error (e.g. a failed\n    assertion or an index-out-of-bounds error).\n\n    Attributes:\n        exn: The original exception that was raised.\n    \"\"\"\n\n    exn: Exception\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.TreeMonitor","title":"TreeMonitor  <code>dataclass</code>","text":"<p>A record that gathers a tree cache along with a series of hooks to be called on node creation.</p> <p>When no monitor is passed to <code>reify</code>, the resulting tree is a pure, immutable datastructure. Passing a monitor allows adding limited side effects in the form of caching and hooks.</p> <p>Attributes:</p> Name Type Description <code>cache</code> <code>TreeCache | TreeCache | None</code> <p>a cache for never recomputing the same node twice. hooks:</p> Source code in <code>src/delphyne/core/reification.py</code> <pre><code>@dataclass(frozen=True)\nclass TreeMonitor:\n    \"\"\"\n    A record that gathers a tree cache along with a series of hooks to\n    be called on node creation.\n\n    When no monitor is passed to `reify`, the resulting tree is a pure,\n    immutable datastructure. Passing a monitor allows adding limited\n    side effects in the form of caching and hooks.\n\n    Attributes:\n        cache: a cache for never recomputing the same node twice. hooks:\n        functions to be called every time a new node is created.\n            For example, hooks can be used to automatically produce a\n            trace that keeps track of all visited nodes (see\n            `tracer_hook`).\n    \"\"\"\n\n    cache: TreeCache | TreeCache | None = None\n    hooks: Sequence[TreeHook] = ()\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.TreeCache","title":"TreeCache","text":"<pre><code>TreeCache: dict[GlobalNodePath, Tree[Any, Any, Any]]\n</code></pre> <p>A cache for never recomputing the same node twice.</p> <p>Each encountered subtree and (recursively) nested tree is stored, indexed by its global reference.</p>"},{"location":"reference/strategies/strategies/#delphyne.TreeHook","title":"TreeHook","text":"<pre><code>TreeHook: Callable[[Tree[Any, Any, Any]], None]\n</code></pre> <p>A function to be called every time a new tree node is created.</p>"},{"location":"reference/strategies/strategies/#delphyne.tracer_hook","title":"tracer_hook","text":"<pre><code>tracer_hook(tracer: Tracer) -&gt; Callable[[Tree[Any, Any, Any]], None]\n</code></pre> <p>Standard hook to be passed to <code>TreeMonitor</code> to automatically log visited nodes into a trace.</p> Source code in <code>src/delphyne/core/reification.py</code> <pre><code>def tracer_hook(tracer: en.Tracer) -&gt; Callable[[Tree[Any, Any, Any]], None]:\n    \"\"\"\n    Standard hook to be passed to `TreeMonitor` to automatically log\n    visited nodes into a trace.\n    \"\"\"\n    return lambda tree: tracer.trace_node(tree.ref)\n</code></pre>"},{"location":"reference/strategies/strategies/#internals","title":"Internals","text":""},{"location":"reference/strategies/strategies/#delphyne.core.trees.NestedTreeSpawner","title":"NestedTreeSpawner","text":"<p>               Bases: <code>Protocol</code></p> <p>A function providing the ability to spawn nested trees attached to a given node.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>class NestedTreeSpawner(Protocol):\n    \"\"\"\n    A function providing the ability to spawn nested trees attached to a\n    given node.\n    \"\"\"\n\n    def __call__[N: Node, P, T](\n        self, strategy: \"StrategyComp[N, P, T]\"\n    ) -&gt; \"NestedTree[N, P, T]\": ...\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.core.trees.QuerySpawner","title":"QuerySpawner","text":"<p>               Bases: <code>Protocol</code></p> <p>A function providing the ability to attach queries to a given node.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>class QuerySpawner(Protocol):\n    \"\"\"\n    A function providing the ability to attach queries to a given node.\n    \"\"\"\n\n    def __call__[T](self, query: AbstractQuery[T]) -&gt; \"AttachedQuery[T]\": ...\n</code></pre>"},{"location":"reference/strategies/strategies/#delphyne.core.trees.AbstractBuilderExecutor","title":"AbstractBuilderExecutor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for builder executors.</p> <p>An executor implements the ability of converting space builders into actual spaces. The <code>reify</code> function relies on such an executor internally.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>class AbstractBuilderExecutor(ABC):\n    \"\"\"\n    Abstract class for builder executors.\n\n    An executor implements the ability of converting space builders into\n    actual spaces. The `reify` function relies on such an executor\n    internally.\n    \"\"\"\n\n    @abstractmethod\n    def parametric[S](\n        self,\n        space_name: SpaceName,\n        parametric_builder: Callable[..., SpaceBuilder[S]],\n    ) -&gt; Callable[..., S]: ...\n\n    @abstractmethod\n    def nonparametric[S](self, name: SpaceName, builder: SpaceBuilder[S]) -&gt; S:\n        return self.parametric(name, lambda: builder)()\n</code></pre>"},{"location":"reference/strategies/traces/","title":"References and Traces","text":""},{"location":"reference/strategies/traces/#references-summary","title":"References Summary","text":""},{"location":"reference/strategies/traces/#delphyne.core.refs","title":"delphyne.core.refs","text":"<p>References to nodes, values, spaces and space elements.</p> <p>References are serializable, immutable values that can be used to identify nodes, spaces and values in a tree (possibly deeply nested). References are useful for tooling and for representing serializable traces (<code>Trace</code>). Also, references are attached to success nodes and query answers (<code>Tracked</code>) so as to allow caching and enforce the locality invariant (see <code>Tree</code>).</p> <p>Local references identify a node, space or space element relative to a given tree node. Global references are expressed relative to a single, global origin.</p> <p>In addition, three kinds of references can be distinguished:</p> <ul> <li>Full references: the default kind of references produced by       <code>reify</code>. Query answers are stored as strings and elements of       spaces induced by strategies are denoted by sequences of value       references.</li> <li>Id-based references: shorter references, where query answers and       success values are identified by unique identifiers. This concise       format is used for exporting traces (see <code>Trace</code>).</li> <li>Hint-based references: query answers and success values are       identified by sequences of hints. This format is used in the       demonstration language (e.g. argument of test instruction <code>go       compare(['', 'foo bar'])</code>) and when visualizing traces resulting       from demonstrations.</li> </ul>"},{"location":"reference/strategies/traces/#query-answers","title":"Query Answers","text":""},{"location":"reference/strategies/traces/#delphyne.Answer","title":"Answer  <code>dataclass</code>","text":"<p>An answer to a query.</p> <p>It can serve as a space element reference if the space in question is a query and the proposed answer correctly parses.</p> <p>Attributes:</p> Name Type Description <code>mode</code> <code>AnswerMode</code> <p>the answer mode (see <code>AnswerMode</code>).</p> <code>content</code> <code>str | Structured</code> <p>the answer content, which can be a raw string or a structured answer (see <code>Structured</code>).</p> <code>tool_calls</code> <code>tuple[ToolCall, ...]</code> <p>an optional sequence of tool calls.</p> <code>justification</code> <code>str | None</code> <p>additional explanations for the answers, which are not passed to the parser but can be appended at the end of the answer in examples. In particular, this is useful when defining queries for which the oracle is not asked to produce a justification for its answer, but justifications can still be provided in examples for the sake of few-shot prompting.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass Answer:\n    \"\"\"\n    An answer to a query.\n\n    It can serve as a _space element reference_ if the space in question\n    is a query and the proposed answer correctly parses.\n\n    Attributes:\n        mode: the answer mode (see `AnswerMode`).\n        content: the answer content, which can be a raw string or a\n            structured answer (see `Structured`).\n        tool_calls: an optional sequence of tool calls.\n        justification: additional explanations for the answers, which\n            are not passed to the parser but can be appended at the end\n            of the answer in examples. In particular, this is useful\n            when defining queries for which the oracle is not asked to\n            produce a justification for its answer, but justifications\n            can still be provided in examples for the sake of few-shot\n            prompting.\n    \"\"\"\n\n    mode: AnswerMode\n    content: str | Structured\n    tool_calls: tuple[ToolCall, ...] = ()\n    justification: str | None = None\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.AnswerMode","title":"AnswerMode","text":"<pre><code>AnswerMode: str | None\n</code></pre> <p>A name for an answer mode, which can be a string or <code>None</code> (the latter is typically used for naming default modes).</p> <p>Queries are allowed to define multiple answer modes, each mode being possibly associated with different settings and with a different parser. An <code>Answer</code> value features the mode that must be used to parse it.</p>"},{"location":"reference/strategies/traces/#delphyne.Structured","title":"Structured  <code>dataclass</code>","text":"<p>Wrapper for structured LLM answers.</p> <p>Many LLM APIs allow producing JSON answers (sometimes following a given schema) instead of plain text.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass Structured:\n    \"\"\"\n    Wrapper for structured LLM answers.\n\n    Many LLM APIs allow producing JSON answers (sometimes following a\n    given schema) instead of plain text.\n    \"\"\"\n\n    structured: Any  # JSON object\n\n    def __hash__(self) -&gt; int:\n        # See `ToolCall.__hash__` for explanations.\n        import json\n\n        return hash(json.dumps(self.__dict__))\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.ToolCall","title":"ToolCall  <code>dataclass</code>","text":"<p>A tool call, usually produced by an LLM oracle.</p> <p>Tool calls can be attached to LLM answers (see <code>Answer</code>).</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass ToolCall:\n    \"\"\"\n    A tool call, usually produced by an LLM oracle.\n\n    Tool calls can be attached to LLM answers (see `Answer`).\n    \"\"\"\n\n    name: str\n    args: Mapping[str, Any]\n\n    def __hash__(self) -&gt; int:\n        # Tool calls need to be hashable since they are part of answers\n        # and references. However, they can feature arbitrary JSON\n        # objects. This, we compute a hash for the serialized value.\n        import json\n\n        return hash(json.dumps(self.__dict__))\n</code></pre>"},{"location":"reference/strategies/traces/#references","title":"References","text":""},{"location":"reference/strategies/traces/#delphyne.core.refs.NodeRef","title":"NodeRef","text":"<pre><code>NodeRef: NodePath | NodeId\n</code></pre> <p>A node reference is either a path or a node identifier.</p> <p>Only one of these forms may be allowed depending on the context (e.g. in the id-based references used for exporting traces, only node identifiers are used, while in the full references attached to trees by <code>reify</code>, only paths are used).</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.NodePath","title":"NodePath","text":"<pre><code>NodePath: tuple[ValueRef, ...]\n</code></pre> <p>Encodes a sequence of actions leading to a node with respect to a given root.</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.NodeId","title":"NodeId  <code>dataclass</code>","text":"<p>Global identifier of a node within a trace.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass NodeId:\n    \"\"\"\n    Global identifier of a node within a trace.\n    \"\"\"\n\n    id: int\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.ValueRef","title":"ValueRef","text":"<pre><code>ValueRef: Assembly[AtomicValueRef]\n</code></pre> <p>A reference to a local value, which is obtained by combining elements of (possibly multiple) local spaces.</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.Assembly","title":"Assembly","text":"<pre><code>Assembly: T | None | tuple[Assembly[T], ...]\n</code></pre> <p>An S-expression whose atoms have type <code>T</code>.</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.AtomicValueRef","title":"AtomicValueRef","text":"<pre><code>AtomicValueRef: IndexedRef | SpaceElementRef\n</code></pre> <p>An atomic value reference is a space element reference that is indexed zero or a finite number of times: space_elt_ref[i1][i2]...[in].</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.IndexedRef","title":"IndexedRef  <code>dataclass</code>","text":"<p>Indexing an atomic value reference.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass IndexedRef:\n    \"\"\"\n    Indexing an atomic value reference.\n    \"\"\"\n\n    ref: AtomicValueRef\n    index: int\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.SpaceElementRef","title":"SpaceElementRef  <code>dataclass</code>","text":"<p>A reference to an element of a local space.</p> <p>When the <code>space</code> field is <code>None</code>, the primary field is considered instead (if it exists).</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass SpaceElementRef:\n    \"\"\"\n    A reference to an element of a local space.\n\n    When the `space` field is `None`, the primary field is considered\n    instead (if it exists).\n    \"\"\"\n\n    space: SpaceRef | None\n    element: AnswerRef | NodeRef | HintsRef\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.SpaceRef","title":"SpaceRef  <code>dataclass</code>","text":"<p>A reference to a specific local space.</p> <p>The <code>arg</code> argument should be <code>()</code> for nonparametric spaces and a n-uple for spaces parametric in n arguments. This differs from Orakell where all parametric spaces have one argument.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass SpaceRef:\n    \"\"\"\n    A reference to a specific local space.\n\n    The `arg` argument should be `()` for nonparametric spaces and a\n    n-uple for spaces parametric in n arguments. This differs from\n    Orakell where all parametric spaces have one argument.\n    \"\"\"\n\n    name: SpaceName\n    args: tuple[ValueRef, ...]\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.SpaceName","title":"SpaceName  <code>dataclass</code>","text":"<p>A name identifying a parametric space.</p> <p>This name can feature integer indices. For example, <code>subs[0]</code> denotes the first subgoal of a [<code>Join</code>][delphyne.Join] node.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass SpaceName:\n    \"\"\"\n    A name identifying a parametric space.\n\n    This name can feature integer indices. For example, `subs[0]`\n    denotes the first subgoal of a `Join` node.\n    \"\"\"\n\n    name: str\n    indices: tuple[int, ...]\n\n    def __getitem__(self, index: int) -&gt; \"SpaceName\":\n        return SpaceName(self.name, (*self.indices, index))\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.AnswerRef","title":"AnswerRef","text":"<pre><code>AnswerRef: Answer | AnswerId\n</code></pre> <p>A reference to a query answer.</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.AnswerId","title":"AnswerId  <code>dataclass</code>","text":"<p>The identifier to an <code>Answer</code> object stored within a trace.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass AnswerId:\n    \"\"\"\n    The identifier to an `Answer` object stored within a trace.\n    \"\"\"\n\n    id: int\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.HintsRef","title":"HintsRef  <code>dataclass</code>","text":"<p>References a local space element via a sequence of hints.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass HintsRef:\n    \"\"\"\n    References a local space element via a sequence of hints.\n    \"\"\"\n\n    hints: tuple[Hint, ...]\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.Hint","title":"Hint  <code>dataclass</code>","text":"<p>A hint for selecting a query answer.</p> <p>A hint can be associated to a qualifier, which is the name of an imported demonstration defining the hint.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass Hint:\n    \"\"\"A hint for selecting a query answer.\n\n    A hint can be associated to a qualifier, which is the name of an\n    imported demonstration defining the hint.\n    \"\"\"\n\n    qualifier: str | None\n    hint: HintValue\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.HintValue","title":"HintValue","text":"<pre><code>HintValue: str\n</code></pre> <p>A string that hints at a query answer.</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.GlobalNodePath","title":"GlobalNodePath","text":"<pre><code>GlobalNodePath: tuple[tuple[SpaceRef, NodePath], ...]\n</code></pre> <p>Path to a node from the global origin, as a sequence of (space to enter, path to follow) instruction pairs.</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.GlobalSpacePath","title":"GlobalSpacePath","text":"<pre><code>GlobalSpacePath: tuple[GlobalNodePath, SpaceRef]\n</code></pre> <p>A path to a global node</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.NodeOrigin","title":"NodeOrigin","text":"<pre><code>NodeOrigin: ChildOf | NestedTreeOf\n</code></pre> <p>Origin of a tree.</p> <p>A tree is either the child of another tree or the root of a nested tree. Traces can be exported as mappings from node identifiers to node origin information featuring id-based references (see <code>Trace</code>).</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.ChildOf","title":"ChildOf  <code>dataclass</code>","text":"<p>The tree of interest is the child of another one.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass ChildOf:\n    \"\"\"\n    The tree of interest is the child of another one.\n    \"\"\"\n\n    node: NodeId\n    action: ValueRef\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.NestedTreeOf","title":"NestedTreeOf  <code>dataclass</code>","text":"<p>The tree of interest is the root of a tree that induces a given space.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass NestedTreeOf:\n    \"\"\"\n    The tree of interest is the root of a tree that induces a given\n    space.\n    \"\"\"\n\n    node: NodeId\n    space: SpaceRef\n</code></pre>"},{"location":"reference/strategies/traces/#tracked-values","title":"Tracked Values","text":""},{"location":"reference/strategies/traces/#delphyne.core.refs.Tracked","title":"Tracked  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A tracked value, which pairs a value with a reference.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>T</code> <p>the value being tracked. ref: a local reference to the</p> <code>node</code> <code>GlobalNodePath</code> <p>a global reference to the node to which the space that the value originates from is attached. In particular, this field is useful to check the locality invariant at runtime (e.g., when passing a tracked value to <code>Tree.child</code>).</p> <code>type_annot</code> <code>TypeAnnot[T] | NoTypeInfo</code> <p>an optional type annotation for the [<code>value</code>][delphyne.value] field. This is mostly used for improving the rendering of values when exporting trace information for external tools.</p> <p>Tracked sequences (or pairs) can be indexed using <code>__getitem__</code>, resulting in tracked values with <code>IndexedRef</code> references. Since <code>__getitem__</code> is defined, tracked values are also iterable.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass Tracked(Generic[T]):\n    \"\"\"\n    A tracked value, which pairs a value with a reference.\n\n    Attributes:\n        value: the value being tracked. ref: a local reference to the\n        value, relative to the node\n            reference by the `node` field.\n        node: a global reference to the node to which the space that the\n            value originates from is attached. In particular, this field\n            is useful to check the locality invariant at runtime (e.g.,\n            when passing a tracked value to `Tree.child`).\n        type_annot: an optional type annotation for the `value` field.\n            This is mostly used for improving the rendering of values\n            when exporting trace information for external tools.\n\n    Tracked sequences (or pairs) can be indexed using `__getitem__`,\n    resulting in tracked values with `IndexedRef` references. Since\n    `__getitem__` is defined, tracked values are also iterable.\n    \"\"\"\n\n    value: T\n    ref: AtomicValueRef\n    node: GlobalNodePath\n    type_annot: TypeAnnot[T] | NoTypeInfo\n\n    @overload\n    def __getitem__[A, B](\n        self: \"Tracked[tuple[A, B]]\", index: Literal[0]\n    ) -&gt; \"Tracked[A]\": ...\n\n    @overload\n    def __getitem__[A, B](\n        self: \"Tracked[tuple[A, B]]\", index: Literal[1]\n    ) -&gt; \"Tracked[B]\": ...\n\n    @overload\n    def __getitem__[U](\n        self: \"Tracked[Sequence[U]]\", index: int\n    ) -&gt; \"Tracked[U]\": ...\n\n    def __getitem__[U](\n        self: \"Tracked[Sequence[U] | tuple[Any, ...]]\", index: int\n    ) -&gt; \"Tracked[U | Any]\":\n        return Tracked(\n            self.value[index],\n            IndexedRef(self.ref, index),\n            self.node,\n            insp.element_type_of_sequence_type(self.type_annot, index),\n        )\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.Value","title":"Value","text":"<pre><code>Value: ExtAssembly[Tracked[Any]]\n</code></pre> <p>An assembly of local, tracked values.</p> <p>Values can serve as actions or space parameters.</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.ExtAssembly","title":"ExtAssembly","text":"<pre><code>ExtAssembly: T | None | Sequence[ExtAssembly[T]]\n</code></pre> <p>Generalizing <code>Assembly</code> to allow arbitrary sequences (and not just tuples). The distinction is important because <code>ValueRef</code> needs to be hashable and so cannot contain lists, while <code>Value</code> can contain lists.</p>"},{"location":"reference/strategies/traces/#delphyne.core.refs.check_local_value","title":"check_local_value","text":"<pre><code>check_local_value(val: Value, node: GlobalNodePath)\n</code></pre> <p>Raise a <code>LocalityError</code> exception if a given value is not a local value relative to a given node.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>def check_local_value(val: Value, node: GlobalNodePath):\n    \"\"\"\n    Raise a `LocalityError` exception if a given value is not a local\n    value relative to a given node.\n    \"\"\"\n    match val:\n        case None:\n            pass\n        case Sequence():\n            for v in val:\n                check_local_value(v, node)\n        case Tracked():\n            if val.node != node:\n                raise LocalityError(\n                    expected_node_ref=node,\n                    node_ref=val.node,\n                    local_ref=val.ref,\n                )\n        case _:\n            assert False\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.refs.LocalityError","title":"LocalityError  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the locality invariant is violated.</p> <p>See <code>Tree</code> and <code>check_local_value</code>.</p> Source code in <code>src/delphyne/core/refs.py</code> <pre><code>@dataclass(frozen=True)\nclass LocalityError(Exception):\n    \"\"\"\n    Exception raised when the locality invariant is violated.\n\n    See `Tree` and `check_local_value`.\n    \"\"\"\n\n    expected_node_ref: GlobalNodePath\n    node_ref: GlobalNodePath\n    local_ref: AtomicValueRef\n</code></pre>"},{"location":"reference/strategies/traces/#traces","title":"Traces","text":""},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace","title":"Trace","text":"<p>A collection of reachable nodes and spaces, which is encoded in a concise way by introducing unique identifiers for answers and nodes.</p> <p>Traces are mutable. Methods are provided to convert full references into id-based references, creating fresh identifiers for new nodes and queries on the fly. Backward conversion methods are also provided for converting id-based references back into full references (assuming id-based references are valid, without which these methods fail with assertion errors).</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>dict[NodeId, NodeOrigin]</code> <p>a mapping from node identifiers to their origin.</p> <code>node_ids</code> <code>dict[NodeOrigin, NodeId]</code> <p>reverse map of <code>nodes</code>.</p> <code>answers</code> <code>dict[AnswerId, tuple[QueryOrigin, Answer]]</code> <p>a mapping from answer identifiers to actual answers, along with origin information on the associated query.</p> <code>answer_ids</code> <code>dict[QueryOrigin, dict[Answer, AnswerId]]</code> <p>reverse map of <code>answers</code>.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>class Trace:\n    \"\"\"\n    A collection of reachable nodes and spaces, which is encoded in a\n    concise way by introducing unique identifiers for answers and nodes.\n\n    Traces are mutable. Methods are provided to convert full references\n    into id-based references, creating fresh identifiers for new nodes\n    and queries on the fly. Backward conversion methods are also\n    provided for converting id-based references back into full\n    references (assuming id-based references are valid, without which\n    these methods fail with assertion errors).\n\n    Attributes:\n        nodes: a mapping from node identifiers to their origin.\n        node_ids: reverse map of `nodes`.\n        answers: a mapping from answer identifiers to actual answers,\n            along with origin information on the associated query.\n        answer_ids: reverse map of `answers`.\n    \"\"\"\n\n    GLOBAL_ORIGIN_ID = refs.NodeId(0)\n\n    def __init__(self):\n        \"\"\"\n        Create an empty trace.\n        \"\"\"\n        self.nodes: dict[refs.NodeId, refs.NodeOrigin] = {}\n        self.node_ids: dict[refs.NodeOrigin, refs.NodeId] = {}\n        self.answers: dict[refs.AnswerId, tuple[QueryOrigin, refs.Answer]] = {}\n        self.answer_ids: dict[\n            QueryOrigin, dict[refs.Answer, refs.AnswerId]\n        ] = {}\n        self._last_node_id: int = 0\n        self._last_answer_id: int = 0\n\n    def fresh_or_cached_node_id(self, origin: refs.NodeOrigin) -&gt; refs.NodeId:\n        \"\"\"\n        Obtain the identifier of a node described by its origin.\n        Create a new identifier on the fly if it does not exist yet.\n        \"\"\"\n        if origin in self.node_ids:\n            return self.node_ids[origin]\n        else:\n            self._last_node_id += 1\n            id = refs.NodeId(self._last_node_id)\n            self.nodes[id] = origin\n            self.node_ids[origin] = id\n            return id\n\n    def fresh_or_cached_answer_id(\n        self, answer: refs.Answer, origin: QueryOrigin\n    ) -&gt; refs.AnswerId:\n        \"\"\"\n        Obtain the identifier of an answer, given its content and the\n        origin of the query that it corresponds to. Create a new, fresh\n        identifier on the fly if it does not exist yet.\n        \"\"\"\n        if origin not in self.answer_ids:\n            self.answer_ids[origin] = {}\n        if answer in self.answer_ids[origin]:\n            return self.answer_ids[origin][answer]\n        else:\n            self._last_answer_id += 1\n            id = refs.AnswerId(self._last_answer_id)\n            self.answers[id] = (origin, answer)\n            self.answer_ids[origin][answer] = id\n            return id\n\n    def register_query(self, origin: QueryOrigin) -&gt; None:\n        \"\"\"\n        Ensure that a query appears in the trace, even if not answers\n        are associated with it yet.\n\n        This is particularly useful for the demonstration interpreter.\n        Indeed, when a test gets stuck on an unanswered query, it is\n        desirable for this query to be part of the returned trace so\n        that the user can visualize it.\n        \"\"\"\n        if origin not in self.answer_ids:\n            self.answer_ids[origin] = {}\n\n    def export(self) -&gt; ExportableTrace:\n        \"\"\"\n        Export a trace into a lightweight, serializable format.\n        \"\"\"\n        nodes = {\n            id.id: pprint.node_origin(origin)\n            for id, origin in self.nodes.items()\n        }\n        queries: list[ExportableQueryInfo] = []\n        for q, a in self.answer_ids.items():\n            ref = pprint.space_ref(q.ref)\n            answers = {id.id: value for value, id in a.items()}\n            queries.append(ExportableQueryInfo(q.node.id, ref, answers))\n        return ExportableTrace(nodes, queries)\n\n    def check_consistency(self) -&gt; None:\n        \"\"\"\n        Perform a sanity check on the trace.\n\n        Each node identifier is expanded into a full reference and then\n        converted back to an identifier, which must be equal to the\n        original one.\n        \"\"\"\n        for id in self.nodes:\n            expanded = self.expand_node_id(id)\n            assert id == self.convert_global_node_path(expanded)\n\n    ### Convert full references into id-based references\n\n    def convert_location(self, location: Location) -&gt; ShortLocation:\n        \"\"\"\n        Convert a full location into an id-based one.\n        \"\"\"\n        id = self.convert_global_node_path(location.node)\n        space = None\n        if location.space is not None:\n            space = self._convert_space_ref(id, location.space)\n        return ShortLocation(id, space)\n\n    def convert_query_origin(self, ref: refs.GlobalSpacePath) -&gt; QueryOrigin:\n        \"\"\"\n        Convert a full, global space reference denoting a quey origin\n        into an id-based reference.\n        \"\"\"\n        id = self.convert_global_node_path(ref[0])\n        space = self._convert_space_ref(id, ref[1])\n        origin = QueryOrigin(id, space)\n        self.register_query(origin)\n        return origin\n\n    def convert_answer_ref(\n        self, ref: tuple[refs.GlobalSpacePath, refs.Answer]\n    ) -&gt; refs.AnswerId:\n        \"\"\"\n        Convert a full answer reference into an answer id.\n        \"\"\"\n        node_path, space = ref[0]\n        id = self.convert_global_node_path(node_path)\n        space = self._convert_space_ref(id, space)\n        origin = QueryOrigin(id, space)\n        return self.fresh_or_cached_answer_id(ref[1], origin)\n\n    def convert_global_node_path(\n        self, path: refs.GlobalNodePath\n    ) -&gt; refs.NodeId:\n        \"\"\"\n        Convert a full, global node reference into an id-based one.\n        \"\"\"\n        id = Trace.GLOBAL_ORIGIN_ID\n        for space, node_path in path:\n            space_ref = self._convert_space_ref(id, space)\n            id = self.fresh_or_cached_node_id(refs.NestedTreeOf(id, space_ref))\n            id = self._convert_node_path(id, node_path)\n        return id\n\n    def convert_global_space_path(\n        self, path: refs.GlobalSpacePath\n    ) -&gt; refs.SpaceRef:\n        \"\"\"\n        Convert a full global space reference into an id-based one.\n        \"\"\"\n        node_path, space_ref = path\n        id = self.convert_global_node_path(node_path)\n        return self._convert_space_ref(id, space_ref)\n\n    def _convert_node_path(\n        self, id: refs.NodeId, path: refs.NodePath\n    ) -&gt; refs.NodeId:\n        \"\"\"\n        Convert a full local node path into an identifier, relative to a\n        given node.\n        \"\"\"\n        for a in path:\n            action_ref = self._convert_value_ref(id, a)\n            id = self.fresh_or_cached_node_id(refs.ChildOf(id, action_ref))\n        return id\n\n    def _convert_space_ref(\n        self, id: refs.NodeId, ref: refs.SpaceRef\n    ) -&gt; refs.SpaceRef:\n        \"\"\"\n        Convert a full local space reference into an id-based one, relative\n        to a given node.\n        \"\"\"\n        args = tuple(self._convert_value_ref(id, a) for a in ref.args)\n        return refs.SpaceRef(ref.name, args)\n\n    def _convert_atomic_value_ref(\n        self, id: refs.NodeId, ref: refs.AtomicValueRef\n    ) -&gt; refs.AtomicValueRef:\n        \"\"\"\n        Convert a full local atomic value reference into an id-based one,\n        relative to a given node.\n        \"\"\"\n        if isinstance(ref, refs.IndexedRef):\n            return refs.IndexedRef(\n                self._convert_atomic_value_ref(id, ref.ref), ref.index\n            )\n        else:\n            return self._convert_space_element_ref(id, ref)\n\n    def _convert_value_ref(\n        self, id: refs.NodeId, ref: refs.ValueRef\n    ) -&gt; refs.ValueRef:\n        \"\"\"\n        Convert a full local value reference into an id-based one,\n        relative to a given node.\n        \"\"\"\n        if ref is None:\n            return None\n        elif isinstance(ref, tuple):\n            return tuple(self._convert_value_ref(id, a) for a in ref)\n        else:\n            return self._convert_atomic_value_ref(id, ref)\n\n    def _convert_space_element_ref(\n        self, id: refs.NodeId, ref: refs.SpaceElementRef\n    ) -&gt; refs.SpaceElementRef:\n        \"\"\"\n        Convert a full local space element reference into an id-based one,\n        relative to a given node.\n        \"\"\"\n        space = None\n        if ref.space is not None:\n            space = self._convert_space_ref(id, ref.space)\n        match ref.element:\n            case refs.Answer():\n                assert space is not None\n                origin = QueryOrigin(id, space)\n                element = self.fresh_or_cached_answer_id(ref.element, origin)\n            case refs.AnswerId() | refs.NodeId():\n                element = ref.element\n            case refs.HintsRef():\n                assert False\n            case tuple():\n                assert space is not None\n                nested_root_orig = refs.NestedTreeOf(id, space)\n                nested_root = self.fresh_or_cached_node_id(nested_root_orig)\n                element = self._convert_node_path(nested_root, ref.element)\n        return refs.SpaceElementRef(space, element)\n\n    ### Reverse direction: expanding id-based references into full ones.\n\n    def expand_space_ref(\n        self, id: refs.NodeId, ref: refs.SpaceRef\n    ) -&gt; refs.SpaceRef:\n        \"\"\"\n        Convert a local id-based space reference into a full one,\n        relative to a given node.\n        \"\"\"\n        args = tuple(self.expand_value_ref(id, a) for a in ref.args)\n        return refs.SpaceRef(ref.name, args)\n\n    def expand_value_ref(\n        self, id: refs.NodeId, ref: refs.ValueRef\n    ) -&gt; refs.ValueRef:\n        \"\"\"\n        Convert a local id-based value reference into a full one,\n        relative to a given node.\n        \"\"\"\n        if ref is None:\n            return None\n        elif isinstance(ref, tuple):\n            return tuple(self.expand_value_ref(id, a) for a in ref)\n        else:\n            return self._expand_atomic_value_ref(id, ref)\n\n    def expand_node_id(self, id: refs.NodeId) -&gt; refs.GlobalNodePath:\n        \"\"\"\n        Convert a node identifier into a full, global node reference.\n        \"\"\"\n        rev_path: list[tuple[refs.SpaceRef, refs.NodePath]] = []\n        while id != Trace.GLOBAL_ORIGIN_ID:\n            id, space, path = self._recover_path(id)\n            rev_path.append((space, path))\n        return tuple(reversed(rev_path))\n\n    def _expand_atomic_value_ref(\n        self, id: refs.NodeId, ref: refs.AtomicValueRef\n    ) -&gt; refs.AtomicValueRef:\n        \"\"\"\n        Convert a local id-based atomic value reference into a full one,\n        relative to a given node.\n        \"\"\"\n        if isinstance(ref, refs.IndexedRef):\n            return refs.IndexedRef(\n                self._expand_atomic_value_ref(id, ref.ref), ref.index\n            )\n        else:\n            return self._expand_space_element_ref(id, ref)\n\n    def _expand_space_element_ref(\n        self, id: refs.NodeId, ref: refs.SpaceElementRef\n    ) -&gt; refs.SpaceElementRef:\n        \"\"\"\n        Convert a local id-based space element reference into a full\n        one, relative to a given node.\n        \"\"\"\n        assert isinstance(ref, refs.SpaceElementRef)\n        assert ref.space is not None\n        space = self.expand_space_ref(id, ref.space)\n        match ref.element:\n            case refs.AnswerId():\n                _orig, ans = self.answers[ref.element]\n                element = ans\n            case refs.NodeId():\n                orig, _, element = self._recover_path(ref.element)\n                assert orig == id\n            case _:\n                assert False\n        return refs.SpaceElementRef(space, element)\n\n    def _recover_path(\n        self, dst: refs.NodeId\n    ) -&gt; tuple[refs.NodeId, refs.SpaceRef, refs.NodePath]:\n        \"\"\"\n        Find the node from which the tree containing `dst` originates.\n\n        Return the node in which the full surrounding tree is nested,\n        the associated space reference, and a path to `dst` from the\n        root of the surrounding tree.\n        \"\"\"\n        rev_path: list[refs.ValueRef] = []\n        while True:\n            dst_origin = self.nodes[dst]\n            match dst_origin:\n                case refs.ChildOf(before, action):\n                    rev_path.append(self.expand_value_ref(before, action))\n                    dst = before\n                case refs.NestedTreeOf(orig, space):\n                    space = self.expand_space_ref(orig, space)\n                    return orig, space, tuple(reversed(rev_path))\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.fresh_or_cached_node_id","title":"fresh_or_cached_node_id","text":"<pre><code>fresh_or_cached_node_id(origin: NodeOrigin) -&gt; NodeId\n</code></pre> <p>Obtain the identifier of a node described by its origin. Create a new identifier on the fly if it does not exist yet.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def fresh_or_cached_node_id(self, origin: refs.NodeOrigin) -&gt; refs.NodeId:\n    \"\"\"\n    Obtain the identifier of a node described by its origin.\n    Create a new identifier on the fly if it does not exist yet.\n    \"\"\"\n    if origin in self.node_ids:\n        return self.node_ids[origin]\n    else:\n        self._last_node_id += 1\n        id = refs.NodeId(self._last_node_id)\n        self.nodes[id] = origin\n        self.node_ids[origin] = id\n        return id\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.fresh_or_cached_answer_id","title":"fresh_or_cached_answer_id","text":"<pre><code>fresh_or_cached_answer_id(answer: Answer, origin: QueryOrigin) -&gt; AnswerId\n</code></pre> <p>Obtain the identifier of an answer, given its content and the origin of the query that it corresponds to. Create a new, fresh identifier on the fly if it does not exist yet.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def fresh_or_cached_answer_id(\n    self, answer: refs.Answer, origin: QueryOrigin\n) -&gt; refs.AnswerId:\n    \"\"\"\n    Obtain the identifier of an answer, given its content and the\n    origin of the query that it corresponds to. Create a new, fresh\n    identifier on the fly if it does not exist yet.\n    \"\"\"\n    if origin not in self.answer_ids:\n        self.answer_ids[origin] = {}\n    if answer in self.answer_ids[origin]:\n        return self.answer_ids[origin][answer]\n    else:\n        self._last_answer_id += 1\n        id = refs.AnswerId(self._last_answer_id)\n        self.answers[id] = (origin, answer)\n        self.answer_ids[origin][answer] = id\n        return id\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.register_query","title":"register_query","text":"<pre><code>register_query(origin: QueryOrigin) -&gt; None\n</code></pre> <p>Ensure that a query appears in the trace, even if not answers are associated with it yet.</p> <p>This is particularly useful for the demonstration interpreter. Indeed, when a test gets stuck on an unanswered query, it is desirable for this query to be part of the returned trace so that the user can visualize it.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def register_query(self, origin: QueryOrigin) -&gt; None:\n    \"\"\"\n    Ensure that a query appears in the trace, even if not answers\n    are associated with it yet.\n\n    This is particularly useful for the demonstration interpreter.\n    Indeed, when a test gets stuck on an unanswered query, it is\n    desirable for this query to be part of the returned trace so\n    that the user can visualize it.\n    \"\"\"\n    if origin not in self.answer_ids:\n        self.answer_ids[origin] = {}\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.export","title":"export","text":"<pre><code>export() -&gt; ExportableTrace\n</code></pre> <p>Export a trace into a lightweight, serializable format.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def export(self) -&gt; ExportableTrace:\n    \"\"\"\n    Export a trace into a lightweight, serializable format.\n    \"\"\"\n    nodes = {\n        id.id: pprint.node_origin(origin)\n        for id, origin in self.nodes.items()\n    }\n    queries: list[ExportableQueryInfo] = []\n    for q, a in self.answer_ids.items():\n        ref = pprint.space_ref(q.ref)\n        answers = {id.id: value for value, id in a.items()}\n        queries.append(ExportableQueryInfo(q.node.id, ref, answers))\n    return ExportableTrace(nodes, queries)\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.check_consistency","title":"check_consistency","text":"<pre><code>check_consistency() -&gt; None\n</code></pre> <p>Perform a sanity check on the trace.</p> <p>Each node identifier is expanded into a full reference and then converted back to an identifier, which must be equal to the original one.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def check_consistency(self) -&gt; None:\n    \"\"\"\n    Perform a sanity check on the trace.\n\n    Each node identifier is expanded into a full reference and then\n    converted back to an identifier, which must be equal to the\n    original one.\n    \"\"\"\n    for id in self.nodes:\n        expanded = self.expand_node_id(id)\n        assert id == self.convert_global_node_path(expanded)\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.convert_location","title":"convert_location","text":"<pre><code>convert_location(location: Location) -&gt; ShortLocation\n</code></pre> <p>Convert a full location into an id-based one.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def convert_location(self, location: Location) -&gt; ShortLocation:\n    \"\"\"\n    Convert a full location into an id-based one.\n    \"\"\"\n    id = self.convert_global_node_path(location.node)\n    space = None\n    if location.space is not None:\n        space = self._convert_space_ref(id, location.space)\n    return ShortLocation(id, space)\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.convert_query_origin","title":"convert_query_origin","text":"<pre><code>convert_query_origin(ref: GlobalSpacePath) -&gt; QueryOrigin\n</code></pre> <p>Convert a full, global space reference denoting a quey origin into an id-based reference.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def convert_query_origin(self, ref: refs.GlobalSpacePath) -&gt; QueryOrigin:\n    \"\"\"\n    Convert a full, global space reference denoting a quey origin\n    into an id-based reference.\n    \"\"\"\n    id = self.convert_global_node_path(ref[0])\n    space = self._convert_space_ref(id, ref[1])\n    origin = QueryOrigin(id, space)\n    self.register_query(origin)\n    return origin\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.convert_answer_ref","title":"convert_answer_ref","text":"<pre><code>convert_answer_ref(ref: tuple[GlobalSpacePath, Answer]) -&gt; AnswerId\n</code></pre> <p>Convert a full answer reference into an answer id.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def convert_answer_ref(\n    self, ref: tuple[refs.GlobalSpacePath, refs.Answer]\n) -&gt; refs.AnswerId:\n    \"\"\"\n    Convert a full answer reference into an answer id.\n    \"\"\"\n    node_path, space = ref[0]\n    id = self.convert_global_node_path(node_path)\n    space = self._convert_space_ref(id, space)\n    origin = QueryOrigin(id, space)\n    return self.fresh_or_cached_answer_id(ref[1], origin)\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.convert_global_node_path","title":"convert_global_node_path","text":"<pre><code>convert_global_node_path(path: GlobalNodePath) -&gt; NodeId\n</code></pre> <p>Convert a full, global node reference into an id-based one.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def convert_global_node_path(\n    self, path: refs.GlobalNodePath\n) -&gt; refs.NodeId:\n    \"\"\"\n    Convert a full, global node reference into an id-based one.\n    \"\"\"\n    id = Trace.GLOBAL_ORIGIN_ID\n    for space, node_path in path:\n        space_ref = self._convert_space_ref(id, space)\n        id = self.fresh_or_cached_node_id(refs.NestedTreeOf(id, space_ref))\n        id = self._convert_node_path(id, node_path)\n    return id\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.convert_global_space_path","title":"convert_global_space_path","text":"<pre><code>convert_global_space_path(path: GlobalSpacePath) -&gt; SpaceRef\n</code></pre> <p>Convert a full global space reference into an id-based one.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def convert_global_space_path(\n    self, path: refs.GlobalSpacePath\n) -&gt; refs.SpaceRef:\n    \"\"\"\n    Convert a full global space reference into an id-based one.\n    \"\"\"\n    node_path, space_ref = path\n    id = self.convert_global_node_path(node_path)\n    return self._convert_space_ref(id, space_ref)\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.expand_space_ref","title":"expand_space_ref","text":"<pre><code>expand_space_ref(id: NodeId, ref: SpaceRef) -&gt; SpaceRef\n</code></pre> <p>Convert a local id-based space reference into a full one, relative to a given node.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def expand_space_ref(\n    self, id: refs.NodeId, ref: refs.SpaceRef\n) -&gt; refs.SpaceRef:\n    \"\"\"\n    Convert a local id-based space reference into a full one,\n    relative to a given node.\n    \"\"\"\n    args = tuple(self.expand_value_ref(id, a) for a in ref.args)\n    return refs.SpaceRef(ref.name, args)\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.expand_value_ref","title":"expand_value_ref","text":"<pre><code>expand_value_ref(id: NodeId, ref: ValueRef) -&gt; ValueRef\n</code></pre> <p>Convert a local id-based value reference into a full one, relative to a given node.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def expand_value_ref(\n    self, id: refs.NodeId, ref: refs.ValueRef\n) -&gt; refs.ValueRef:\n    \"\"\"\n    Convert a local id-based value reference into a full one,\n    relative to a given node.\n    \"\"\"\n    if ref is None:\n        return None\n    elif isinstance(ref, tuple):\n        return tuple(self.expand_value_ref(id, a) for a in ref)\n    else:\n        return self._expand_atomic_value_ref(id, ref)\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Trace.expand_node_id","title":"expand_node_id","text":"<pre><code>expand_node_id(id: NodeId) -&gt; GlobalNodePath\n</code></pre> <p>Convert a node identifier into a full, global node reference.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>def expand_node_id(self, id: refs.NodeId) -&gt; refs.GlobalNodePath:\n    \"\"\"\n    Convert a node identifier into a full, global node reference.\n    \"\"\"\n    rev_path: list[tuple[refs.SpaceRef, refs.NodePath]] = []\n    while id != Trace.GLOBAL_ORIGIN_ID:\n        id, space, path = self._recover_path(id)\n        rev_path.append((space, path))\n    return tuple(reversed(rev_path))\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.QueryOrigin","title":"QueryOrigin  <code>dataclass</code>","text":"<p>A global, id-based reference to the space induced by a query.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>@dataclass(frozen=True)\nclass QueryOrigin:\n    \"\"\"\n    A global, id-based reference to the space induced by a query.\n    \"\"\"\n\n    node: refs.NodeId\n    ref: refs.SpaceRef\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.ExportableTrace","title":"ExportableTrace  <code>dataclass</code>","text":"<p>A lightweight trace format that can be easily exported to JSON/YAML.</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>dict[int, NodeOriginStr]</code> <p>a mapping from node ids to serialized origin information.</p> <code>queries</code> <code>list[ExportableQueryInfo]</code> <p>a list of encountered queries with associated answers.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>@dataclass\nclass ExportableTrace:\n    \"\"\"\n    A lightweight trace format that can be easily exported to JSON/YAML.\n\n    Attributes:\n        nodes: a mapping from node ids to serialized origin information.\n        queries: a list of encountered queries with associated answers.\n    \"\"\"\n\n    nodes: dict[int, NodeOriginStr]\n    queries: list[ExportableQueryInfo]\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.ExportableQueryInfo","title":"ExportableQueryInfo  <code>dataclass</code>","text":"<p>Information about a query encountered in an exportable trace.</p> <p>Attributes:</p> Name Type Description <code>node</code> <code>int</code> <p>Identifier of the node that the query is attached to.</p> <code>space</code> <code>str</code> <p>Local, id-based reference of the space that the query belongs to. Serialized using <code>pprint.space_ref</code>.</p> <code>answers</code> <code>dict[int, Answer]</code> <p>Mapping from answer identifiers to actual answers. Answer identifiers are unique across a whole exportable trace (and not only across an <code>ExportableQueryInfo</code> value).</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>@dataclass\nclass ExportableQueryInfo:\n    \"\"\"\n    Information about a query encountered in an exportable trace.\n\n    Attributes:\n        node: Identifier of the node that the query is attached to.\n        space: Local, id-based reference of the space that the query\n            belongs to. Serialized using `pprint.space_ref`.\n        answers: Mapping from answer identifiers to actual answers.\n            Answer identifiers are unique across a whole exportable\n            trace (and not only across an `ExportableQueryInfo` value).\n    \"\"\"\n\n    node: int\n    space: str\n    answers: dict[int, refs.Answer]\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.NodeOriginStr","title":"NodeOriginStr","text":"<pre><code>NodeOriginStr: str\n</code></pre> <p>A concise, serialized representation for <code>NodeOrigin</code>.</p>"},{"location":"reference/strategies/traces/#delphyne.core.traces.Location","title":"Location  <code>dataclass</code>","text":"<p>A full, global reference to either a node or a space.</p> <p>This is useful in particular for attaching location information to logging messages.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>@dataclass(frozen=True)\nclass Location:\n    \"\"\"\n    A **full**, global reference to either a node or a space.\n\n    This is useful in particular for attaching location information to\n    logging messages.\n    \"\"\"\n\n    node: refs.GlobalNodePath\n    space: refs.SpaceRef | None\n</code></pre>"},{"location":"reference/strategies/traces/#delphyne.core.traces.ShortLocation","title":"ShortLocation  <code>dataclass</code>","text":"<p>An id-based, global reference to either a node or a space.</p> <p>This is the id-based counterpart of <code>Location</code>. Policies typically log messages with <code>Location</code> values attached (since trees feature full references), which are then converted into <code>ShortLocation</code> in the final exportable log.</p> Source code in <code>src/delphyne/core/traces.py</code> <pre><code>@dataclass(frozen=True)\nclass ShortLocation:\n    \"\"\"\n    An **id-based**, global reference to either a node or a space.\n\n    This is the id-based counterpart of `Location`. Policies typically\n    log messages with `Location` values attached (since trees feature\n    full references), which are then converted into `ShortLocation` in\n    the final exportable log.\n    \"\"\"\n\n    node: refs.NodeId\n    space: refs.SpaceRef | None\n</code></pre>"},{"location":"reference/strategies/trees/","title":"Trees and Spaces","text":""},{"location":"reference/strategies/trees/#trees","title":"Trees","text":""},{"location":"reference/strategies/trees/#delphyne.Tree","title":"Tree  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[N, P, T]</code></p> <p>Strategy Trees.</p> <p>A strategy tree can be obtained by reifying a strategy computation (see <code>reify</code>). Its type parameters are: a type signature <code>N</code>, an associated inner policy type <code>P</code>, and a return type <code>T</code>.</p> <p>Trees are immutable.</p> <p>Attributes:</p> Name Type Description <code>node</code> <code>N | Success[T]</code> <p>The current node of the tree, which is either a success leaf or a node of type compatible with signature <code>N</code>.</p> <code>child</code> <code>Callable[[Value], Tree[N, P, T]]</code> <p>A function that maps an action (i.e., a local value) to a child tree.</p> <code>ref</code> <code>GlobalNodePath</code> <p>A global reference to the node.</p> <p>Locality Invariant</p> <p>Only local values can be used as actions (passed to <code>child</code>) or as arguments of parametric local spaces. A local value consists in an assembly of elements of local spaces (see <code>Value</code>). This invariant is enforced at runtime and it guarantees that a policy can always make progress at any given node without being provided additional context. It is also a key assumption for establishing the completeness of the demonstration language (i.e., a demonstration with a single <code>run | success</code> test can always be extracted from a successful run of an oracular program).</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass Tree(Generic[N, P, T]):\n    \"\"\"\n    Strategy Trees.\n\n    A strategy tree can be obtained by reifying a strategy computation\n    (see `reify`). Its type parameters are: a type signature `N`, an\n    associated inner policy type `P`, and a return type `T`.\n\n    Trees are **immutable**.\n\n    Attributes:\n        node: The current node of the tree, which is either a success\n            leaf or a node of type compatible with signature `N`.\n        child: A function that maps an action (i.e., a local value) to a\n            child tree.\n        ref: A global reference to the node.\n\n    !!! info \"Locality Invariant\"\n        Only *local values* can be used as actions (passed to `child`)\n        or as arguments of parametric local spaces. A *local value*\n        consists in an assembly of elements of local spaces (see\n        `Value`). This invariant is enforced at runtime and it\n        guarantees that a policy can always make progress at any given\n        node without being provided additional context. It is also a key\n        assumption for establishing the completeness of the\n        demonstration language (i.e., a demonstration with a single `run\n        | success` test can always be extracted from a successful run of\n        an oracular program).\n    \"\"\"\n\n    node: \"N | Success[T]\"\n    child: \"Callable[[Value], Tree[N, P, T]]\"\n    ref: GlobalNodePath\n\n    def transform[M: Node](\n        self,\n        node: \"M | Success[T]\",\n        transformer: \"AbstractTreeTransformer[N, M]\",\n    ) -&gt; \"Tree[M, P, T]\":\n        \"\"\"\n        Recursively apply a function to all embedded trees and subtrees\n        of a tree.\n\n        This is a pure method that does not modify its arguments. It is\n        useful to implement tree transformers such as `elim_compute`.\n        \"\"\"\n\n        def child(action: Value) -&gt; Tree[M, P, T]:\n            return transformer(self.child(action))\n\n        node = node.map_embedded(transformer)\n        return Tree(node, child, self.ref)\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Tree.transform","title":"transform","text":"<pre><code>transform(node: transform[M] | Success[T], transformer: AbstractTreeTransformer[N, transform[M]]) -&gt; Tree[transform[M], P, T]\n</code></pre> <p>Recursively apply a function to all embedded trees and subtrees of a tree.</p> <p>This is a pure method that does not modify its arguments. It is useful to implement tree transformers such as [<code>elim_compute</code>][delphyne.elim_compute].</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def transform[M: Node](\n    self,\n    node: \"M | Success[T]\",\n    transformer: \"AbstractTreeTransformer[N, M]\",\n) -&gt; \"Tree[M, P, T]\":\n    \"\"\"\n    Recursively apply a function to all embedded trees and subtrees\n    of a tree.\n\n    This is a pure method that does not modify its arguments. It is\n    useful to implement tree transformers such as `elim_compute`.\n    \"\"\"\n\n    def child(action: Value) -&gt; Tree[M, P, T]:\n        return transformer(self.child(action))\n\n    node = node.map_embedded(transformer)\n    return Tree(node, child, self.ref)\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Success","title":"Success  <code>dataclass</code>","text":"<p>A success leaf, carrying a tracked value.</p> Implementation Note <p>Although it largely implements the same interface via duck typing, <code>Success</code> does not inherit <code>Node</code>. The reason is that <code>Tree[N, P, T].node</code> has type <code>Success[T] | N</code>. If <code>Success</code> inherited <code>Node</code>, it would be possible for <code>N</code> to include a value of type <code>Success[T2]</code> for some <code>T2 != T</code>, which we want to rule out.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass Success[T]:\n    \"\"\"\n    A success leaf, carrying a tracked value.\n\n    ??? note \"Implementation Note\"\n        Although it largely implements the same interface via duck\n        typing, `Success` does not inherit `Node`. The reason is that\n        `Tree[N, P, T].node` has type `Success[T] | N`. If `Success`\n        inherited `Node`, it would be possible for `N` to include a\n        value of type `Success[T2]` for some `T2 != T`, which we want to\n        rule out.\n    \"\"\"\n\n    success: Tracked[T]\n\n    def leaf_node(self) -&gt; bool:\n        return True\n\n    def valid_action(self, action: object) -&gt; bool:\n        return False\n\n    def navigate(self) -&gt; Navigation:\n        assert False\n\n    def summary_message(self) -&gt; str | None:\n        return None\n\n    def primary_space(self) -&gt; None:\n        return None\n\n    def primary_space_ref(self) -&gt; None:\n        return None\n\n    def effect_name(self) -&gt; str:\n        return self.__class__.__name__\n\n    def get_tags(self) -&gt; Sequence[Tag]:\n        return ()\n\n    def nested_space(\n        self, name: refs.SpaceName, args: tuple[Value, ...]\n    ) -&gt; Space[Any] | None:\n        return None\n\n    def map_embedded(\n        self, trans: \"AbstractTreeTransformer[Any, Any]\"\n    ) -&gt; \"Success[T]\":\n        return self\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node","title":"Node","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract type for a tree node.</p> <p>New effects can be added to the strategy language by subclassing <code>Node</code> and then defining a triggering function that calls the <code>spawn</code> class method (manually defining such a wrapper allows providing users with precise type annotations: i.e., [<code>branch</code>][delphyne.branch] for [<code>Branch</code>][delphyne.Branch]).</p> <p>Methods to override:</p> <ul> <li>The <code>navigate</code> method must be overriden for all node types.</li> <li>The <code>leaf_node</code> method must be overriden for all leaf nodes.</li> <li>The following methods are also frequently overriden:     <code>summary_message</code>, <code>valid_action</code>, <code>primary_space</code>, and     <code>get_extra_tags</code>.</li> </ul> <p>Other methods are implemented via inspection and are not typically overriden.</p> On the absence of type parameters <p>In order to precisely type the fields of node subclasses (e.g. [<code>Branch</code>][delphyne.Branch]), <code>Node</code> would need to have type parameters standing for the surrounding inner policy type, the action type, etc. However, Python's type system is not expressive enough to properly constrain such type parameters in the definition of trees since it lacks GADTs and higher-kinded types. In particular, the way we express signatures as unions of subtypes of <code>Node</code> would not work if <code>Node</code> were parametric.</p> <p>As a result, types such as inner policy types and action types must be represented using <code>Any</code> in the definition of nodes (e.g. [<code>Branch</code>][delphyne.Branch]) and the type safety of search policy implementations (e.g. [<code>dfs</code>][delphyne.dfs]) cannot be fully enforced statically. However, effect triggering functions such as [<code>branch</code>][delphyne.branch] can typically be typed precisely, providing static type safety for strategy writers.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>class Node(ABC):\n    \"\"\"\n    Abstract type for a tree node.\n\n    New effects can be added to the strategy language by subclassing\n    `Node` and then defining a triggering function that calls the\n    `spawn` class method (manually defining such a wrapper allows\n    providing users with precise type annotations: i.e., `branch` for\n    `Branch`).\n\n    **Methods to override:**\n\n    - The `navigate` method must be overriden for all node types.\n    - The `leaf_node` method must be overriden for all leaf nodes.\n    - The following methods are also frequently overriden:\n        `summary_message`, `valid_action`, `primary_space`, and\n        `get_extra_tags`.\n\n    Other methods are implemented via inspection and are not typically\n    overriden.\n\n    ??? note \"On the absence of type parameters\"\n        In order to precisely type the fields of node subclasses (e.g.\n        `Branch`), `Node` would need to have type parameters standing\n        for the surrounding inner policy type, the action type, etc.\n        However, Python's type system is not expressive enough to\n        properly constrain such type parameters in the definition of\n        trees since it lacks GADTs and higher-kinded types. In\n        particular, the way we express signatures as unions of subtypes\n        of `Node` would not work if `Node` were parametric.\n\n        As a result, types such as inner policy types and action types\n        must be represented using `Any` in the definition of nodes (e.g.\n        `Branch`) and the type safety of search policy implementations\n        (e.g. `dfs`) cannot be fully enforced statically. However,\n        effect *triggering functions* such as `branch` can typically be\n        typed precisely, providing static type safety for strategy\n        writers.\n    \"\"\"\n\n    # Methods that **must** be overriden\n\n    @abstractmethod\n    def navigate(self) -&gt; \"Navigation\":\n        \"\"\"\n        The navigation method, to be defined for each node type.\n\n        It should only be called when `self.leaf_node()` returns False.\n\n        See `Navigation` for details.\n        \"\"\"\n        pass\n\n    # Methods that are _sometimes_ overriden\n\n    def summary_message(self) -&gt; str | None:\n        \"\"\"\n        Return an optional summary message for the node, to be\n        displayed in the Delphyne extension's Tree View.\n        \"\"\"\n        return None\n\n    def leaf_node(self) -&gt; bool:\n        \"\"\"\n        Return True if the node is a leaf node (e.g., `Fail`) and False\n        otherwise.\n\n        Leaf nodes do not have to define `navigate` and are treated\n        specially by the demonstration interpreter.\n        \"\"\"\n        return False\n\n    def valid_action(self, action: object) -&gt; bool:\n        \"\"\"\n        Return whether an action is valid.\n\n        This method is used to dynamically check actions passed to\n        `Tree.child`, **after** the `Tracked` wrapper is removed. By\n        default, it always returns `True` (unless the node is a leaf\n        node, in which case it returns `False`).\n        \"\"\"\n        return False if self.leaf_node() else True\n\n    def primary_space(self) -&gt; \"Space[object] | None\":\n        \"\"\"\n        Optionally return the node's primary space.\n\n        Primary spaces are useful to shorten space references,\n        especially when writing demonstration tests. For example, if\n        `cands` is the primary space of the current node, then\n        `compare([cands{''}, cands{'foo bar'}])` can be abbreviated into\n        `compare(['', 'foo bar'])`.\n\n        By default, all tags of a node's primary space are also\n        inherited by this node (see `get_tags` method).\n        \"\"\"\n        return None\n\n    def get_extra_tags(self) -&gt; Sequence[Tag]:\n        \"\"\"\n        Return the extra tags associated with the node, in addition to\n        the default ones inherited from the primary space (see\n        `get_tags` method).\n        \"\"\"\n        return []\n\n    # Inspecting the kinds of node fields\n\n    @classmethod\n    def fields(cls) -&gt; NodeFields:\n        \"\"\"\n        Return a dictionary mapping each field of the node to some\n        metadata (e.g., whether the field denotes a local space).\n\n        Such metadata is useful in particular to implement `spawn`.\n\n        The default implementation uses inspection, via\n        `detect_node_structure`. See the\n        [`node_fields`][delphyne.core.node_fields] module for details.\n        \"\"\"\n        f = detect_node_structure(\n            cls, embedded_class=EmbeddedTree, space_class=Space\n        )\n        if f is None:\n            msg = f\"Impossible to autodetect the structure of {cls}\"\n            assert False, msg\n        return f\n\n    # Methods with a sensible default behavior that are _rarely_ overriden\n\n    def effect_name(self) -&gt; str:\n        \"\"\"\n        Name of the associated effect.\n\n        Used for generating message errors and in the VSCode extension.\n        \"\"\"\n        return self.__class__.__name__\n\n    def get_tags(self) -&gt; Sequence[Tag]:\n        \"\"\"\n        Return all tags attached to the node.\n\n        Tags are leveraged by the demonstration language to identify\n        nodes (e.g., `at` test command).\n\n        By default, this method returns all tags from the primary space\n        (if any), along with any additional tag returned by\n        `get_extra_tags`.\n        \"\"\"\n        if (primary := self.primary_space()) is not None:\n            return [*primary.tags(), *self.get_extra_tags()]\n        return self.get_extra_tags()\n\n    # Methods that should not be overriden\n\n    @final\n    def primary_space_ref(self) -&gt; refs.SpaceRef | None:\n        \"\"\"\n        Convenience method for returning a reference to the node's\n        primary space, if it is defined.\n        \"\"\"\n        space = self.primary_space()\n        if space is None:\n            return None\n        return space.source().ref[1]\n\n    @final\n    def nested_space(\n        self, name: refs.SpaceName, args: tuple[Value, ...]\n    ) -&gt; Space[Any] | None:\n        \"\"\"\n        Dynamically retrieve a local space given its name and\n        parameters.\n\n        For nonparametric spaces, `args` should be the empty tuple.\n\n        This method is used by the demonstration interpreter.\n        \"\"\"\n        try:\n            f: Any = getattr(self, name.name)\n            for i in name.indices:\n                f = f[i]\n            if not args:\n                # TODO: we could check that the field is not supposed to be\n                # parametric\n                assert isinstance(f, Space)\n                return cast(Space[Any], f)\n            else:\n                assert isinstance(f, Callable)\n                f = cast(Callable[..., Space[Any]], f)\n                return f(*args)\n        except (TypeError, AttributeError):\n            return None\n\n    @final\n    @classmethod\n    def spawn(cls, spawner: \"AbstractBuilderExecutor\", **args: Any):\n        \"\"\"\n        Spawn an instance of the node type, using a dictionary of\n        arguments to populate its fields.\n\n        Arguments are processed according to their kind (see\n        [delphyne.core.node_fields][]). For example opaque space\n        builders (`Opaque`) are turned into opaque spaces\n        (`OpaqueSpace`) and strategy computations (`StrategyComp`) are\n        turned into embedded trees (`EmbeddedTree`).\n        \"\"\"\n\n        def convert(\n            name: refs.SpaceName, field: nf.FieldKind, obj: Any\n        ) -&gt; Any:\n            match field:\n                case nf.SpaceF():\n                    return spawner.nonparametric(name, obj)\n                case nf.ParametricF(nf.SpaceF()):\n                    return spawner.parametric(name, obj)\n                case nf.EmbeddedF():\n                    builder = EmbeddedTree.builder(obj)\n                    return spawner.nonparametric(name, builder)\n                case nf.ParametricF(nf.EmbeddedF()):\n                    parametric_builder = EmbeddedTree.parametric_builder(obj)\n                    return spawner.parametric(name, parametric_builder)\n                case nf.DataF():\n                    return obj\n                case nf.SequenceF(f):\n                    return [convert(name[i], f, x) for i, x in enumerate(obj)]\n                case nf.OptionalF(f):\n                    assert convert(name, f, obj) if obj is not None else None\n                case _:\n                    assert False\n\n        args_new = {\n            fname: convert(refs.SpaceName(fname, ()), fkind, args[fname])\n            for fname, fkind in cls.fields().items()\n        }\n        return cls(**args_new)\n\n    @final\n    def map_embedded[N: Node](\n        self: N, trans: \"AbstractTreeTransformer[Any, Any]\"\n    ) -&gt; N:\n        \"\"\"\n        Apply a function to all embedded trees.\n\n        This is a pure method that returns an updated node. It is useful\n        for implementing `Tree.transform`, which in turn is useful for\n        implementing standard tree transformers such as `elim_join` and\n        `elim_compute`.\n        \"\"\"\n\n        def convert_embedded(\n            emb: EmbeddedTree[Any, Any, Any],\n        ) -&gt; EmbeddedTree[Any, Any, Any]:\n            assert isinstance(emb, EmbeddedTree), (\n                f\"Expected an EmbeddedTree, got {type(emb)}\"\n            )\n            nested = NestedTree(\n                strategy=emb.nested.strategy,\n                ref=emb.nested.ref,\n                spawn_tree=lambda: trans(emb.nested.spawn_tree()),\n            )\n            return EmbeddedTree(nested, _tags=emb.tags())\n\n        def convert_parametric_embedded(obj: Any) -&gt; Callable[[Any], Any]:\n            return lambda arg: convert_embedded(obj(arg))\n\n        def convert(field: nf.FieldKind, obj: Any) -&gt; Any:\n            match field:\n                case nf.SpaceF() | nf.ParametricF(nf.SpaceF()) | nf.DataF():\n                    return obj\n                case nf.EmbeddedF():\n                    return convert_embedded(obj)\n                case nf.ParametricF(nf.EmbeddedF()):\n                    return convert_parametric_embedded(obj)\n                case nf.SequenceF(f):\n                    return [convert(f, x) for x in obj]\n                case nf.OptionalF(f):\n                    return convert(f, obj) if obj is not None else None\n                case _:\n                    assert False\n\n        args_new = {\n            fname: convert(fkind, getattr(self, fname))\n            for fname, fkind in self.fields().items()\n        }\n        return type(self)(**args_new)\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.navigate","title":"navigate  <code>abstractmethod</code>","text":"<pre><code>navigate() -&gt; Navigation\n</code></pre> <p>The navigation method, to be defined for each node type.</p> <p>It should only be called when <code>self.leaf_node()</code> returns False.</p> <p>See <code>Navigation</code> for details.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@abstractmethod\ndef navigate(self) -&gt; \"Navigation\":\n    \"\"\"\n    The navigation method, to be defined for each node type.\n\n    It should only be called when `self.leaf_node()` returns False.\n\n    See `Navigation` for details.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.summary_message","title":"summary_message","text":"<pre><code>summary_message() -&gt; str | None\n</code></pre> <p>Return an optional summary message for the node, to be displayed in the Delphyne extension's Tree View.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def summary_message(self) -&gt; str | None:\n    \"\"\"\n    Return an optional summary message for the node, to be\n    displayed in the Delphyne extension's Tree View.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.leaf_node","title":"leaf_node","text":"<pre><code>leaf_node() -&gt; bool\n</code></pre> <p>Return True if the node is a leaf node (e.g., [<code>Fail</code>][delphyne.Fail]) and False otherwise.</p> <p>Leaf nodes do not have to define <code>navigate</code> and are treated specially by the demonstration interpreter.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def leaf_node(self) -&gt; bool:\n    \"\"\"\n    Return True if the node is a leaf node (e.g., `Fail`) and False\n    otherwise.\n\n    Leaf nodes do not have to define `navigate` and are treated\n    specially by the demonstration interpreter.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.valid_action","title":"valid_action","text":"<pre><code>valid_action(action: object) -&gt; bool\n</code></pre> <p>Return whether an action is valid.</p> <p>This method is used to dynamically check actions passed to <code>Tree.child</code>, after the <code>Tracked</code> wrapper is removed. By default, it always returns <code>True</code> (unless the node is a leaf node, in which case it returns <code>False</code>).</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def valid_action(self, action: object) -&gt; bool:\n    \"\"\"\n    Return whether an action is valid.\n\n    This method is used to dynamically check actions passed to\n    `Tree.child`, **after** the `Tracked` wrapper is removed. By\n    default, it always returns `True` (unless the node is a leaf\n    node, in which case it returns `False`).\n    \"\"\"\n    return False if self.leaf_node() else True\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.primary_space","title":"primary_space","text":"<pre><code>primary_space() -&gt; Space[object] | None\n</code></pre> <p>Optionally return the node's primary space.</p> <p>Primary spaces are useful to shorten space references, especially when writing demonstration tests. For example, if <code>cands</code> is the primary space of the current node, then <code>compare([cands{''}, cands{'foo bar'}])</code> can be abbreviated into <code>compare(['', 'foo bar'])</code>.</p> <p>By default, all tags of a node's primary space are also inherited by this node (see <code>get_tags</code> method).</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def primary_space(self) -&gt; \"Space[object] | None\":\n    \"\"\"\n    Optionally return the node's primary space.\n\n    Primary spaces are useful to shorten space references,\n    especially when writing demonstration tests. For example, if\n    `cands` is the primary space of the current node, then\n    `compare([cands{''}, cands{'foo bar'}])` can be abbreviated into\n    `compare(['', 'foo bar'])`.\n\n    By default, all tags of a node's primary space are also\n    inherited by this node (see `get_tags` method).\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.get_extra_tags","title":"get_extra_tags","text":"<pre><code>get_extra_tags() -&gt; Sequence[Tag]\n</code></pre> <p>Return the extra tags associated with the node, in addition to the default ones inherited from the primary space (see <code>get_tags</code> method).</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def get_extra_tags(self) -&gt; Sequence[Tag]:\n    \"\"\"\n    Return the extra tags associated with the node, in addition to\n    the default ones inherited from the primary space (see\n    `get_tags` method).\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.fields","title":"fields  <code>classmethod</code>","text":"<pre><code>fields() -&gt; NodeFields\n</code></pre> <p>Return a dictionary mapping each field of the node to some metadata (e.g., whether the field denotes a local space).</p> <p>Such metadata is useful in particular to implement <code>spawn</code>.</p> <p>The default implementation uses inspection, via <code>detect_node_structure</code>. See the <code>node_fields</code> module for details.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@classmethod\ndef fields(cls) -&gt; NodeFields:\n    \"\"\"\n    Return a dictionary mapping each field of the node to some\n    metadata (e.g., whether the field denotes a local space).\n\n    Such metadata is useful in particular to implement `spawn`.\n\n    The default implementation uses inspection, via\n    `detect_node_structure`. See the\n    [`node_fields`][delphyne.core.node_fields] module for details.\n    \"\"\"\n    f = detect_node_structure(\n        cls, embedded_class=EmbeddedTree, space_class=Space\n    )\n    if f is None:\n        msg = f\"Impossible to autodetect the structure of {cls}\"\n        assert False, msg\n    return f\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.effect_name","title":"effect_name","text":"<pre><code>effect_name() -&gt; str\n</code></pre> <p>Name of the associated effect.</p> <p>Used for generating message errors and in the VSCode extension.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def effect_name(self) -&gt; str:\n    \"\"\"\n    Name of the associated effect.\n\n    Used for generating message errors and in the VSCode extension.\n    \"\"\"\n    return self.__class__.__name__\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.get_tags","title":"get_tags","text":"<pre><code>get_tags() -&gt; Sequence[Tag]\n</code></pre> <p>Return all tags attached to the node.</p> <p>Tags are leveraged by the demonstration language to identify nodes (e.g., <code>at</code> test command).</p> <p>By default, this method returns all tags from the primary space (if any), along with any additional tag returned by <code>get_extra_tags</code>.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def get_tags(self) -&gt; Sequence[Tag]:\n    \"\"\"\n    Return all tags attached to the node.\n\n    Tags are leveraged by the demonstration language to identify\n    nodes (e.g., `at` test command).\n\n    By default, this method returns all tags from the primary space\n    (if any), along with any additional tag returned by\n    `get_extra_tags`.\n    \"\"\"\n    if (primary := self.primary_space()) is not None:\n        return [*primary.tags(), *self.get_extra_tags()]\n    return self.get_extra_tags()\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.primary_space_ref","title":"primary_space_ref","text":"<pre><code>primary_space_ref() -&gt; SpaceRef | None\n</code></pre> <p>Convenience method for returning a reference to the node's primary space, if it is defined.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@final\ndef primary_space_ref(self) -&gt; refs.SpaceRef | None:\n    \"\"\"\n    Convenience method for returning a reference to the node's\n    primary space, if it is defined.\n    \"\"\"\n    space = self.primary_space()\n    if space is None:\n        return None\n    return space.source().ref[1]\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.nested_space","title":"nested_space","text":"<pre><code>nested_space(name: SpaceName, args: tuple[Value, ...]) -&gt; Space[Any] | None\n</code></pre> <p>Dynamically retrieve a local space given its name and parameters.</p> <p>For nonparametric spaces, <code>args</code> should be the empty tuple.</p> <p>This method is used by the demonstration interpreter.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@final\ndef nested_space(\n    self, name: refs.SpaceName, args: tuple[Value, ...]\n) -&gt; Space[Any] | None:\n    \"\"\"\n    Dynamically retrieve a local space given its name and\n    parameters.\n\n    For nonparametric spaces, `args` should be the empty tuple.\n\n    This method is used by the demonstration interpreter.\n    \"\"\"\n    try:\n        f: Any = getattr(self, name.name)\n        for i in name.indices:\n            f = f[i]\n        if not args:\n            # TODO: we could check that the field is not supposed to be\n            # parametric\n            assert isinstance(f, Space)\n            return cast(Space[Any], f)\n        else:\n            assert isinstance(f, Callable)\n            f = cast(Callable[..., Space[Any]], f)\n            return f(*args)\n    except (TypeError, AttributeError):\n        return None\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.spawn","title":"spawn  <code>classmethod</code>","text":"<pre><code>spawn(spawner: AbstractBuilderExecutor, **args: Any)\n</code></pre> <p>Spawn an instance of the node type, using a dictionary of arguments to populate its fields.</p> <p>Arguments are processed according to their kind (see delphyne.core.node_fields). For example opaque space builders ([<code>Opaque</code>][delphyne.Opaque]) are turned into opaque spaces ([<code>OpaqueSpace</code>][delphyne.OpaqueSpace]) and strategy computations (<code>StrategyComp</code>) are turned into embedded trees (<code>EmbeddedTree</code>).</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@final\n@classmethod\ndef spawn(cls, spawner: \"AbstractBuilderExecutor\", **args: Any):\n    \"\"\"\n    Spawn an instance of the node type, using a dictionary of\n    arguments to populate its fields.\n\n    Arguments are processed according to their kind (see\n    [delphyne.core.node_fields][]). For example opaque space\n    builders (`Opaque`) are turned into opaque spaces\n    (`OpaqueSpace`) and strategy computations (`StrategyComp`) are\n    turned into embedded trees (`EmbeddedTree`).\n    \"\"\"\n\n    def convert(\n        name: refs.SpaceName, field: nf.FieldKind, obj: Any\n    ) -&gt; Any:\n        match field:\n            case nf.SpaceF():\n                return spawner.nonparametric(name, obj)\n            case nf.ParametricF(nf.SpaceF()):\n                return spawner.parametric(name, obj)\n            case nf.EmbeddedF():\n                builder = EmbeddedTree.builder(obj)\n                return spawner.nonparametric(name, builder)\n            case nf.ParametricF(nf.EmbeddedF()):\n                parametric_builder = EmbeddedTree.parametric_builder(obj)\n                return spawner.parametric(name, parametric_builder)\n            case nf.DataF():\n                return obj\n            case nf.SequenceF(f):\n                return [convert(name[i], f, x) for i, x in enumerate(obj)]\n            case nf.OptionalF(f):\n                assert convert(name, f, obj) if obj is not None else None\n            case _:\n                assert False\n\n    args_new = {\n        fname: convert(refs.SpaceName(fname, ()), fkind, args[fname])\n        for fname, fkind in cls.fields().items()\n    }\n    return cls(**args_new)\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Node.map_embedded","title":"map_embedded","text":"<pre><code>map_embedded(trans: AbstractTreeTransformer[Any, Any]) -&gt; map_embedded[N]\n</code></pre> <p>Apply a function to all embedded trees.</p> <p>This is a pure method that returns an updated node. It is useful for implementing <code>Tree.transform</code>, which in turn is useful for implementing standard tree transformers such as <code>elim_join</code> and [<code>elim_compute</code>][delphyne.elim_compute].</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@final\ndef map_embedded[N: Node](\n    self: N, trans: \"AbstractTreeTransformer[Any, Any]\"\n) -&gt; N:\n    \"\"\"\n    Apply a function to all embedded trees.\n\n    This is a pure method that returns an updated node. It is useful\n    for implementing `Tree.transform`, which in turn is useful for\n    implementing standard tree transformers such as `elim_join` and\n    `elim_compute`.\n    \"\"\"\n\n    def convert_embedded(\n        emb: EmbeddedTree[Any, Any, Any],\n    ) -&gt; EmbeddedTree[Any, Any, Any]:\n        assert isinstance(emb, EmbeddedTree), (\n            f\"Expected an EmbeddedTree, got {type(emb)}\"\n        )\n        nested = NestedTree(\n            strategy=emb.nested.strategy,\n            ref=emb.nested.ref,\n            spawn_tree=lambda: trans(emb.nested.spawn_tree()),\n        )\n        return EmbeddedTree(nested, _tags=emb.tags())\n\n    def convert_parametric_embedded(obj: Any) -&gt; Callable[[Any], Any]:\n        return lambda arg: convert_embedded(obj(arg))\n\n    def convert(field: nf.FieldKind, obj: Any) -&gt; Any:\n        match field:\n            case nf.SpaceF() | nf.ParametricF(nf.SpaceF()) | nf.DataF():\n                return obj\n            case nf.EmbeddedF():\n                return convert_embedded(obj)\n            case nf.ParametricF(nf.EmbeddedF()):\n                return convert_parametric_embedded(obj)\n            case nf.SequenceF(f):\n                return [convert(f, x) for x in obj]\n            case nf.OptionalF(f):\n                return convert(f, obj) if obj is not None else None\n            case _:\n                assert False\n\n    args_new = {\n        fname: convert(fkind, getattr(self, fname))\n        for fname, fkind in self.fields().items()\n    }\n    return type(self)(**args_new)\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Navigation","title":"Navigation","text":"<pre><code>Navigation: Generator[Space[Any], Tracked[Any], Value]\n</code></pre> <p>A navigation generator.</p> <p>A navigation generator is returned by the <code>navigate</code> method of non-leaf nodes. It yields local spaces and receives corresponding elements until an action is generated and returned.</p>"},{"location":"reference/strategies/trees/#delphyne.NavigationError","title":"NavigationError  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when an error occurs during navigation.</p> <p>For internal errors that should not occur within normal use, assertions shoule be used instead. This exception is meant to represent errors that can occur during normal use, and reported in the user interface. For an example, see [<code>Abduction</code>][delphyne.Abduction].</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>A human-readable error message.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass NavigationError(Exception):\n    \"\"\"\n    Exception raised when an error occurs during navigation.\n\n    For internal errors that should not occur within normal use,\n    assertions shoule be used instead. This exception is meant to\n    represent errors that can occur during normal use, and reported in\n    the user interface. For an example, see `Abduction`.\n\n    Attributes:\n        message: A human-readable error message.\n    \"\"\"\n\n    message: str\n</code></pre>"},{"location":"reference/strategies/trees/#node-fields","title":"Node Fields","text":""},{"location":"reference/strategies/trees/#delphyne.core.node_fields","title":"delphyne.core.node_fields","text":"<p>Classifying and inferring different kinds of node fields.</p> <p>When spawning a node via <code>Tree.spawn</code>, different field arguments must be processed differently. For example, an opaque space builder ([<code>Opaque</code>][delphyne.Opaque]) must be turned into an opaque space ([<code>OpaqueSpace</code>][delphyne.OpaqueSpace]) by providing an appropriate space reference. Other fields such as data fields must not be processed.</p> <p>This module defines a type for classifying node fields (<code>FieldType</code>) along with a utility function to automatically classify the fields of a custom node via inspection (<code>detect_node_structure</code>).</p>"},{"location":"reference/strategies/trees/#delphyne.core.node_fields.NodeFields","title":"NodeFields","text":"<pre><code>NodeFields: dict[str, FieldKind]\n</code></pre> <p>A dictionary mapping each field name to its kind.</p>"},{"location":"reference/strategies/trees/#delphyne.core.node_fields.FieldKind","title":"FieldKind","text":"<pre><code>FieldKind: LeafFieldKind | SequenceF | OptionalF\n</code></pre> <p>Kind of a node field.</p> <p>A node field can be an embedded tree, another local space, a parametric embedded tree or space, a sequence of such elements or an optional element.</p>"},{"location":"reference/strategies/trees/#delphyne.core.node_fields.FieldKind","title":"FieldKind","text":"<pre><code>FieldKind: LeafFieldKind | SequenceF | OptionalF\n</code></pre> <p>Kind of a node field.</p> <p>A node field can be an embedded tree, another local space, a parametric embedded tree or space, a sequence of such elements or an optional element.</p>"},{"location":"reference/strategies/trees/#delphyne.core.node_fields.LeafFieldKind","title":"LeafFieldKind","text":"<pre><code>LeafFieldKind: SpaceF | EmbeddedF | DataF | ParametricF\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.core.node_fields.SpaceF","title":"SpaceF  <code>dataclass</code>","text":"<p>A space field that does not correspond to an embedded nested tree.</p> Source code in <code>src/delphyne/core/node_fields.py</code> <pre><code>@dataclass\nclass SpaceF:\n    \"\"\"\n    A space field that does not correspond to an embedded nested tree.\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.core.node_fields.EmbeddedF","title":"EmbeddedF  <code>dataclass</code>","text":"<p>A field corresponding to a nested embedded space.</p> <p>Recognizing this particular case is useful so that triggering functions can directly accept strategy computations as arguments (<code>StrategyComp</code>) instead of space builders (<code>SpaceBuilder</code>).</p> Source code in <code>src/delphyne/core/node_fields.py</code> <pre><code>@dataclass\nclass EmbeddedF:\n    \"\"\"\n    A field corresponding to a nested embedded space.\n\n    Recognizing this particular case is useful so that triggering\n    functions can directly accept strategy computations as arguments\n    (`StrategyComp`) instead of space builders (`SpaceBuilder`).\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.core.node_fields.ParametricF","title":"ParametricF  <code>dataclass</code>","text":"<p>A field corresponding to a parametric space.</p> <p>Attributes:</p> Name Type Description <code>res</code> <code>SpaceF | EmbeddedF</code> <p>kind of the result space.</p> Source code in <code>src/delphyne/core/node_fields.py</code> <pre><code>@dataclass\nclass ParametricF:\n    \"\"\"\n    A field corresponding to a parametric space.\n\n    Attributes:\n        res: kind of the result space.\n    \"\"\"\n\n    res: SpaceF | EmbeddedF\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.core.node_fields.DataF","title":"DataF  <code>dataclass</code>","text":"<p>A field that corresponds to some other kind of data.</p> Source code in <code>src/delphyne/core/node_fields.py</code> <pre><code>@dataclass\nclass DataF:\n    \"\"\"\n    A field that corresponds to some other kind of data.\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.core.node_fields.SequenceF","title":"SequenceF  <code>dataclass</code>","text":"<p>A field corresponding to a sequence of spaces.</p> Source code in <code>src/delphyne/core/node_fields.py</code> <pre><code>@dataclass\nclass SequenceF:\n    \"\"\"\n    A field corresponding to a sequence of spaces.\n    \"\"\"\n\n    element: \"FieldKind\"\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.core.node_fields.OptionalF","title":"OptionalF  <code>dataclass</code>","text":"<p>A field corresponding to a sequence of spaces.</p> Source code in <code>src/delphyne/core/node_fields.py</code> <pre><code>@dataclass\nclass OptionalF:\n    \"\"\"\n    A field corresponding to a sequence of spaces.\n    \"\"\"\n\n    element: \"FieldKind\"\n</code></pre>"},{"location":"reference/strategies/trees/#spaces","title":"Spaces","text":""},{"location":"reference/strategies/trees/#delphyne.Space","title":"Space","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract type for a space.</p> <p>Tree nodes feature local spaces (possibly parametric), that are backed by either queries or nested trees. Examples of spaces include <code>EmbeddedTree</code>, [<code>OpaqueSpace</code>][delphyne.OpaqueSpace] and <code>TransparentQuery</code>.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>class Space[T](ABC):\n    \"\"\"\n    Abstract type for a space.\n\n    Tree nodes feature local spaces (possibly parametric), that are\n    backed by either queries or nested trees. Examples of spaces\n    include `EmbeddedTree`, `OpaqueSpace` and `TransparentQuery`.\n    \"\"\"\n\n    @abstractmethod\n    def tags(self) -&gt; Sequence[Tag]:\n        \"\"\"\n        Return the tags associated with the space.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def source(self) -&gt; \"NestedTree[Any, Any, T] | AttachedQuery[T]\":\n        \"\"\"\n        Return the source of the space, which is either a nested tree\n        or an attached query.\n\n        This method is mostly useful to the demonstration interpreter.\n        It is not typically used in policies since it breaks\n        abstraction (e.g., whether or not an opaque space is defined via\n        a query or a strategy is irrelevant).\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Space.tags","title":"tags  <code>abstractmethod</code>","text":"<pre><code>tags() -&gt; Sequence[Tag]\n</code></pre> <p>Return the tags associated with the space.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@abstractmethod\ndef tags(self) -&gt; Sequence[Tag]:\n    \"\"\"\n    Return the tags associated with the space.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Space.source","title":"source  <code>abstractmethod</code>","text":"<pre><code>source() -&gt; NestedTree[Any, Any, Space[T]] | AttachedQuery[Space[T]]\n</code></pre> <p>Return the source of the space, which is either a nested tree or an attached query.</p> <p>This method is mostly useful to the demonstration interpreter. It is not typically used in policies since it breaks abstraction (e.g., whether or not an opaque space is defined via a query or a strategy is irrelevant).</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@abstractmethod\ndef source(self) -&gt; \"NestedTree[Any, Any, T] | AttachedQuery[T]\":\n    \"\"\"\n    Return the source of the space, which is either a nested tree\n    or an attached query.\n\n    This method is mostly useful to the demonstration interpreter.\n    It is not typically used in policies since it breaks\n    abstraction (e.g., whether or not an opaque space is defined via\n    a query or a strategy is irrelevant).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.Tag","title":"Tag","text":"<pre><code>Tag: str\n</code></pre> <p>String tags for nodes and spaces.</p> <p>Nodes and spaces can be assigned string identifiers, which may be referenced in demonstration tests or when defining inner policies (e.g., <code>IPDict</code>). Tags should contain only alphanumeric characters, underscores, dots, and dashes.</p>"},{"location":"reference/strategies/trees/#delphyne.AttachedQuery","title":"AttachedQuery  <code>dataclass</code>","text":"<p>Wrapper for a query attached to a specific space.</p> <p>Attributes:</p> Name Type Description <code>query</code> <code>AbstractQuery[AttachedQuery[T]]</code> <p>The wrapped query.</p> <code>ref</code> <code>GlobalSpacePath</code> <p>A global reference to the space to which the query is attached.</p> <code>parse_answer</code> <code>Callable[[Answer], Tracked[AttachedQuery[T]] | ParseError]</code> <p>A wrapper around <code>self.query.parse_answer</code>, which attaches proper tracking information to answers.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass AttachedQuery[T]:\n    \"\"\"\n    Wrapper for a query attached to a specific space.\n\n    Attributes:\n        query: The wrapped query.\n        ref: A global reference to the space to which the query is\n            attached.\n        parse_answer: A wrapper around `self.query.parse_answer`,\n            which attaches proper tracking information to answers.\n    \"\"\"\n\n    query: AbstractQuery[T]\n    ref: refs.GlobalSpacePath\n    parse_answer: Callable[[refs.Answer], Tracked[T] | ParseError]\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.NestedTree","title":"NestedTree  <code>dataclass</code>","text":"<p>Wrapper for a tree attached to a particular node.</p> <p>The <code>AttachedQuery</code> type plays an equivalent role for queries.</p> <p>Note</p> <p>One cannot count on the [<code>strategy</code>][delphyne.strategy] field having the same node type as <code>spawn_tree</code> since nested trees can be applied tree transformers (see <code>Node.map_embedded</code>).</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass NestedTree[N: Node, P, T]:\n    \"\"\"\n    Wrapper for a tree attached to a particular node.\n\n    The `AttachedQuery` type plays an equivalent role for queries.\n\n    !!! note\n        One cannot count on the `strategy` field having the same node\n        type as `spawn_tree` since nested trees can be applied tree\n        transformers (see `Node.map_embedded`).\n    \"\"\"\n\n    strategy: StrategyComp[Node, P, T]\n    ref: refs.GlobalSpacePath\n    spawn_tree: \"Callable[[], Tree[N, P, T]]\"\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.TransparentQuery","title":"TransparentQuery  <code>dataclass</code>","text":"<p>               Bases: <code>Space[TransparentQuery[T]]</code></p> <p>A space that is defined by a single, transparent query.</p> <p>As opposed to [<code>OpaqueSpace</code>][delphyne.OpaqueSpace], the query is meant to be directly exposed to policies. This is used to define [<code>Compute</code>][delphyne.Compute] and [<code>Flag</code>][delphyne.Flag] nodes for example.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass TransparentQuery[T](Space[T]):\n    \"\"\"\n    A space that is defined by a single, *transparent* query.\n\n    As opposed to `OpaqueSpace`, the query is meant to be directly\n    exposed to policies. This is used to define `Compute` and `Flag`\n    nodes for example.\n    \"\"\"\n\n    attached: AttachedQuery[T]\n    _tags: \"Sequence[Tag]\"\n\n    @override\n    def source(self) -&gt; AttachedQuery[T]:\n        return self.attached\n\n    @override\n    def tags(self) -&gt; Sequence[Tag]:\n        return self._tags\n\n    @staticmethod\n    def build[T1](\n        query: AbstractQuery[T1],\n    ) -&gt; \"SpaceBuilder[TransparentQuery[T1]]\":\n        return SpaceBuilder(\n            build=lambda _, spawner, tags: TransparentQuery(\n                spawner(query), tags\n            ),\n            tags=query.default_tags(),\n        )\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.EmbeddedTree","title":"EmbeddedTree  <code>dataclass</code>","text":"<p>               Bases: <code>Space[EmbeddedTree[T]]</code></p> <p>Space defined by a nested tree with the same signature and inner policy as its surrounding tree.</p> <p>This is useful to define effects such as [<code>Join</code>][delphyne.Join].</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass EmbeddedTree[N: Node, P, T](Space[T]):\n    \"\"\"\n    Space defined by a nested tree with the same signature and inner\n    policy as its surrounding tree.\n\n    This is useful to define effects such as `Join`.\n    \"\"\"\n\n    nested: NestedTree[N, P, T]\n    _tags: Sequence[Tag]\n\n    @staticmethod\n    def builder[N1: Node, P1, T1](\n        strategy: StrategyComp[N1, P1, T1],\n    ) -&gt; \"SpaceBuilder[EmbeddedTree[N1, P1, T1]]\":\n        return SpaceBuilder[EmbeddedTree[N1, P1, T1]](\n            build=lambda spawn, _, tags: EmbeddedTree(spawn(strategy), tags),\n            tags=strategy.default_tags(),\n        )\n\n    @staticmethod\n    def parametric_builder[A, N1: Node, P1, T1](\n        parametric_strategy: Callable[[A], StrategyComp[N1, P1, T1]],\n    ) -&gt; \"Callable[[A], SpaceBuilder[EmbeddedTree[N1, P1, T1]]]\":\n        return lambda arg: EmbeddedTree.builder(parametric_strategy(arg))\n\n    def source(self) -&gt; \"NestedTree[Any, Any, T]\":\n        return self.nested\n\n    def tags(self) -&gt; Sequence[Tag]:\n        return self._tags\n\n    def spawn_tree(self) -&gt; \"Tree[N, P, T]\":\n        return self.nested.spawn_tree()\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.SpaceBuilder","title":"SpaceBuilder  <code>dataclass</code>","text":"<p>Wrapper for a function that builds a space, given the ability to spawn nested trees and attached queries.</p> <p>Effect triggering functions such as [<code>branch</code>][delphyne.branch] do not directly take spaces as their arguments but space builders instead.</p> <p>Space builders are also equipped with modifiable tags, to be ultimately passed to the resulting space.</p> <p>Attributes:</p> Name Type Description <code>build</code> <code>Callable[[NestedTreeSpawner, QuerySpawner, Sequence[Tag]], SpaceBuilder[S]]</code> <p>Wrapped builder function</p> <code>tags</code> <code>Sequence[Tag]</code> <p>Tags to be assocaited to the space.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>@dataclass(frozen=True)\nclass SpaceBuilder[S]:\n    \"\"\"\n    Wrapper for a function that builds a space, given the ability to\n    spawn nested trees and attached queries.\n\n    Effect triggering functions such as `branch` do not directly take\n    spaces as their arguments but space builders instead.\n\n    Space builders are also equipped with modifiable tags, to be\n    ultimately passed to the resulting space.\n\n    Attributes:\n        build: Wrapped builder function\n        tags: Tags to be assocaited to the space.\n    \"\"\"\n\n    build: Callable[[NestedTreeSpawner, QuerySpawner, Sequence[Tag]], S]\n    tags: Sequence[Tag]\n\n    def tagged(self, *tags: Tag) -&gt; \"SpaceBuilder[S]\":\n        \"\"\"\n        Add new tags to the space builder.\n        \"\"\"\n        return replace(self, tags=(*self.tags, *tags))\n\n    def __call__(\n        self, spawner: NestedTreeSpawner, query_spawner: QuerySpawner\n    ) -&gt; S:\n        \"\"\"\n        Build a space, given the provided capabilities along with the\n        current set of tags.\n        \"\"\"\n        return self.build(spawner, query_spawner, self.tags)\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.SpaceBuilder.tagged","title":"tagged","text":"<pre><code>tagged(*tags: Tag) -&gt; SpaceBuilder[SpaceBuilder[S]]\n</code></pre> <p>Add new tags to the space builder.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>def tagged(self, *tags: Tag) -&gt; \"SpaceBuilder[S]\":\n    \"\"\"\n    Add new tags to the space builder.\n    \"\"\"\n    return replace(self, tags=(*self.tags, *tags))\n</code></pre>"},{"location":"reference/strategies/trees/#miscellaneous","title":"Miscellaneous","text":""},{"location":"reference/strategies/trees/#delphyne.ComputationNode","title":"ComputationNode","text":"<p>               Bases: <code>Node</code></p> <p>Abstract type for computation nodes.</p> <p>A computation node has an additional method that can be called to compute an answer. The demonstration interpreter uses this information to navigate computation nodes while accumulating implicit answers.</p> <p>The standard [<code>Compute</code>][delphyne.Compute] node inherits this class.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>class ComputationNode(Node):\n    \"\"\"\n    Abstract type for computation nodes.\n\n    A computation node has an additional method that can be called to\n    compute an _answer_. The demonstration interpreter uses this\n    information to navigate computation nodes while accumulating\n    implicit answers.\n\n    The standard `Compute` node inherits this class.\n    \"\"\"\n\n    @abstractmethod\n    def run_computation(self) -&gt; str:\n        pass\n</code></pre>"},{"location":"reference/strategies/trees/#delphyne.AbstractTreeTransformer","title":"AbstractTreeTransformer","text":"<p>               Bases: <code>Protocol</code></p> <p>A function that transforms any tree with signature N into a tree with signature M, preserving its inner policy type and return type.</p> Source code in <code>src/delphyne/core/trees.py</code> <pre><code>class AbstractTreeTransformer[N: Node, M: Node](Protocol):\n    \"\"\"\n    A function that transforms any tree with signature N into a tree\n    with signature M, preserving its inner policy type and return type.\n    \"\"\"\n\n    def __call__[T, P](self, tree: \"Tree[N, P, T]\") -&gt; \"Tree[M, P, T]\": ...\n</code></pre>"}]}